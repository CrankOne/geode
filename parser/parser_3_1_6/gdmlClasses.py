#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Nov 17 12:42:41 2020 by generateDS.py version 2.37.1.
# Python 3.7.8 (default, Aug 15 2020, 19:20:38)  [GCC 9.3.0]
#
# Command line options:
#   ('-m', '')
#   ('-f', '')
#   ('-o', 'parser_3_1_6/gdmlClasses.py')
#   ('--export', 'write literal etree')
#   ('--root-element', 'gdml')
#   ('-s', 'parser_3_1_6/gdmlSubclasses.py')
#
# Command line arguments:
#   schema-3_1_6/gdml.xsd
#
# Command line:
#   /var/src/.venv/bin/generateDS.py -m -f -o "parser_3_1_6/gdmlClasses.py" --export="write literal etree" --root-element="gdml" -s "parser_3_1_6/gdmlSubclasses.py" schema-3_1_6/gdml.xsd
#
# Current working directory (os.getcwd()):
#   parser
#

from six.moves import zip_longest
import os
import sys
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ModuleNotFoundError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModuleNotFoundError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModuleNotFoundError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModuleNotFoundError:

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModuleNotFoundError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModuleNotFoundError as exp:
    
    class GeneratedsSuper(object):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer valuess')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class stateType(str, Enum):
    """Material physical state"""
    GAS='gas'
    LIQUID='liquid'
    SOLID='solid'
    UNKNOWN='unknown'


class IdentifiableVolumeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiableVolumeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiableVolumeType.subclass:
            return IdentifiableVolumeType.subclass(*args_, **kwargs_)
        else:
            return IdentifiableVolumeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentifiableVolumeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentifiableVolumeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IdentifiableVolumeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifiableVolumeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IdentifiableVolumeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IdentifiableVolumeType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentifiableVolumeType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='IdentifiableVolumeType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='IdentifiableVolumeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class IdentifiableVolumeType


class SinglePlacementType(GeneratedsSuper):
    """Represents a single unique copy a of an associated logical volume
    in geometrical hierarchy"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, copynumber=None, file=None, volumeref=None, position=None, positionref=None, rotation=None, rotationref=None, scale=None, scaleref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.copynumber = _cast(int, copynumber)
        self.copynumber_nsprefix_ = None
        self.file = file
        self.file_nsprefix_ = None
        self.volumeref = volumeref
        self.volumeref_nsprefix_ = None
        self.position = position
        self.position_nsprefix_ = None
        self.positionref = positionref
        self.positionref_nsprefix_ = None
        self.rotation = rotation
        self.rotation_nsprefix_ = None
        self.rotationref = rotationref
        self.rotationref_nsprefix_ = None
        self.scale = scale
        self.scale_nsprefix_ = None
        self.scaleref = scaleref
        self.scaleref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SinglePlacementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SinglePlacementType.subclass:
            return SinglePlacementType.subclass(*args_, **kwargs_)
        else:
            return SinglePlacementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_file(self):
        return self.file
    def set_file(self, file):
        self.file = file
    fileProp = property(get_file, set_file)
    def get_volumeref(self):
        return self.volumeref
    def set_volumeref(self, volumeref):
        self.volumeref = volumeref
    volumerefProp = property(get_volumeref, set_volumeref)
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    positionProp = property(get_position, set_position)
    def get_positionref(self):
        return self.positionref
    def set_positionref(self, positionref):
        self.positionref = positionref
    positionrefProp = property(get_positionref, set_positionref)
    def get_rotation(self):
        return self.rotation
    def set_rotation(self, rotation):
        self.rotation = rotation
    rotationProp = property(get_rotation, set_rotation)
    def get_rotationref(self):
        return self.rotationref
    def set_rotationref(self, rotationref):
        self.rotationref = rotationref
    rotationrefProp = property(get_rotationref, set_rotationref)
    def get_scale(self):
        return self.scale
    def set_scale(self, scale):
        self.scale = scale
    scaleProp = property(get_scale, set_scale)
    def get_scaleref(self):
        return self.scaleref
    def set_scaleref(self, scaleref):
        self.scaleref = scaleref
    scalerefProp = property(get_scaleref, set_scaleref)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_copynumber(self):
        return self.copynumber
    def set_copynumber(self, copynumber):
        self.copynumber = copynumber
    copynumberProp = property(get_copynumber, set_copynumber)
    def hasContent_(self):
        if (
            self.file is not None or
            self.volumeref is not None or
            self.position is not None or
            self.positionref is not None or
            self.rotation is not None or
            self.rotationref is not None or
            self.scale is not None or
            self.scaleref is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SinglePlacementType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SinglePlacementType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SinglePlacementType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SinglePlacementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SinglePlacementType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SinglePlacementType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.copynumber is not None and 'copynumber' not in already_processed:
            already_processed.add('copynumber')
            outfile.write(' copynumber="%s"' % self.gds_format_integer(self.copynumber, input_name='copynumber'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SinglePlacementType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.file is not None:
            namespaceprefix_ = self.file_nsprefix_ + ':' if (UseCapturedNS_ and self.file_nsprefix_) else ''
            self.file.export(outfile, level, namespaceprefix_, namespacedef_='', name_='file', pretty_print=pretty_print)
        if self.volumeref is not None:
            namespaceprefix_ = self.volumeref_nsprefix_ + ':' if (UseCapturedNS_ and self.volumeref_nsprefix_) else ''
            self.volumeref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='volumeref', pretty_print=pretty_print)
        if self.position is not None:
            namespaceprefix_ = self.position_nsprefix_ + ':' if (UseCapturedNS_ and self.position_nsprefix_) else ''
            self.position.export(outfile, level, namespaceprefix_, namespacedef_='', name_='position', pretty_print=pretty_print)
        if self.positionref is not None:
            namespaceprefix_ = self.positionref_nsprefix_ + ':' if (UseCapturedNS_ and self.positionref_nsprefix_) else ''
            self.positionref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='positionref', pretty_print=pretty_print)
        if self.rotation is not None:
            namespaceprefix_ = self.rotation_nsprefix_ + ':' if (UseCapturedNS_ and self.rotation_nsprefix_) else ''
            self.rotation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rotation', pretty_print=pretty_print)
        if self.rotationref is not None:
            namespaceprefix_ = self.rotationref_nsprefix_ + ':' if (UseCapturedNS_ and self.rotationref_nsprefix_) else ''
            self.rotationref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rotationref', pretty_print=pretty_print)
        if self.scale is not None:
            namespaceprefix_ = self.scale_nsprefix_ + ':' if (UseCapturedNS_ and self.scale_nsprefix_) else ''
            self.scale.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scale', pretty_print=pretty_print)
        if self.scaleref is not None:
            namespaceprefix_ = self.scaleref_nsprefix_ + ':' if (UseCapturedNS_ and self.scaleref_nsprefix_) else ''
            self.scaleref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scaleref', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SinglePlacementType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.copynumber is not None:
            element.set('copynumber', self.gds_format_integer(self.copynumber))
        if self.file is not None:
            file_ = self.file
            file_.to_etree(element, name_='file', mapping_=mapping_, nsmap_=nsmap_)
        if self.volumeref is not None:
            volumeref_ = self.volumeref
            volumeref_.to_etree(element, name_='volumeref', mapping_=mapping_, nsmap_=nsmap_)
        if self.position is not None:
            position_ = self.position
            position_.to_etree(element, name_='position', mapping_=mapping_, nsmap_=nsmap_)
        if self.positionref is not None:
            positionref_ = self.positionref
            positionref_.to_etree(element, name_='positionref', mapping_=mapping_, nsmap_=nsmap_)
        if self.rotation is not None:
            rotation_ = self.rotation
            rotation_.to_etree(element, name_='rotation', mapping_=mapping_, nsmap_=nsmap_)
        if self.rotationref is not None:
            rotationref_ = self.rotationref
            rotationref_.to_etree(element, name_='rotationref', mapping_=mapping_, nsmap_=nsmap_)
        if self.scale is not None:
            scale_ = self.scale
            scale_.to_etree(element, name_='scale', mapping_=mapping_, nsmap_=nsmap_)
        if self.scaleref is not None:
            scaleref_ = self.scaleref
            scaleref_.to_etree(element, name_='scaleref', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='SinglePlacementType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.copynumber is not None and 'copynumber' not in already_processed:
            already_processed.add('copynumber')
            showIndent(outfile, level)
            outfile.write('copynumber=%d,\n' % (self.copynumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.file is not None:
            showIndent(outfile, level)
            outfile.write('file=model_.FileReferenceType(\n')
            self.file.exportLiteral(outfile, level, name_='file')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.volumeref is not None:
            showIndent(outfile, level)
            outfile.write('volumeref=model_.ReferenceType(\n')
            self.volumeref.exportLiteral(outfile, level, name_='volumeref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.position is not None:
            showIndent(outfile, level)
            outfile.write('position=model_.positionType(\n')
            self.position.exportLiteral(outfile, level, name_='position')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.positionref is not None:
            showIndent(outfile, level)
            outfile.write('positionref=model_.ReferenceType(\n')
            self.positionref.exportLiteral(outfile, level, name_='positionref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rotation is not None:
            showIndent(outfile, level)
            outfile.write('rotation=model_.rotationType(\n')
            self.rotation.exportLiteral(outfile, level, name_='rotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rotationref is not None:
            showIndent(outfile, level)
            outfile.write('rotationref=model_.ReferenceType(\n')
            self.rotationref.exportLiteral(outfile, level, name_='rotationref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scale is not None:
            showIndent(outfile, level)
            outfile.write('scale=model_.scaleType(\n')
            self.scale.exportLiteral(outfile, level, name_='scale')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scaleref is not None:
            showIndent(outfile, level)
            outfile.write('scaleref=model_.ReferenceType(\n')
            self.scaleref.exportLiteral(outfile, level, name_='scaleref')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('copynumber', node)
        if value is not None and 'copynumber' not in already_processed:
            already_processed.add('copynumber')
            self.copynumber = self.gds_parse_integer(value, node, 'copynumber')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'file':
            obj_ = FileReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.file = obj_
            obj_.original_tagname_ = 'file'
        elif nodeName_ == 'volumeref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.volumeref = obj_
            obj_.original_tagname_ = 'volumeref'
        elif nodeName_ == 'position':
            obj_ = positionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.position = obj_
            obj_.original_tagname_ = 'position'
        elif nodeName_ == 'positionref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.positionref = obj_
            obj_.original_tagname_ = 'positionref'
        elif nodeName_ == 'rotation':
            obj_ = rotationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rotation = obj_
            obj_.original_tagname_ = 'rotation'
        elif nodeName_ == 'rotationref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rotationref = obj_
            obj_.original_tagname_ = 'rotationref'
        elif nodeName_ == 'scale':
            obj_ = scaleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scale = obj_
            obj_.original_tagname_ = 'scale'
        elif nodeName_ == 'scaleref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scaleref = obj_
            obj_.original_tagname_ = 'scaleref'
# end class SinglePlacementType


class DivisionPlacementType(GeneratedsSuper):
    """Represents a division of the associated logical volume
    in geometrical hierarchy"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, axis=None, number=None, width=None, offset=None, unit='mm', volumeref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.axis = _cast(None, axis)
        self.axis_nsprefix_ = None
        self.number = _cast(None, number)
        self.number_nsprefix_ = None
        self.width = _cast(None, width)
        self.width_nsprefix_ = None
        self.offset = _cast(None, offset)
        self.offset_nsprefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.volumeref = volumeref
        self.volumeref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DivisionPlacementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DivisionPlacementType.subclass:
            return DivisionPlacementType.subclass(*args_, **kwargs_)
        else:
            return DivisionPlacementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_volumeref(self):
        return self.volumeref
    def set_volumeref(self, volumeref):
        self.volumeref = volumeref
    volumerefProp = property(get_volumeref, set_volumeref)
    def get_axis(self):
        return self.axis
    def set_axis(self, axis):
        self.axis = axis
    axisProp = property(get_axis, set_axis)
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    numberProp = property(get_number, set_number)
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    widthProp = property(get_width, set_width)
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    offsetProp = property(get_offset, set_offset)
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.volumeref is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DivisionPlacementType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DivisionPlacementType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DivisionPlacementType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DivisionPlacementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DivisionPlacementType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DivisionPlacementType'):
        if self.axis is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            outfile.write(' axis=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.axis), input_name='axis')), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number=%s' % (quote_attrib(self.number), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (quote_attrib(self.width), ))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset=%s' % (quote_attrib(self.offset), ))
        if self.unit != "mm" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DivisionPlacementType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.volumeref is not None:
            namespaceprefix_ = self.volumeref_nsprefix_ + ':' if (UseCapturedNS_ and self.volumeref_nsprefix_) else ''
            self.volumeref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='volumeref', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DivisionPlacementType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.axis is not None:
            element.set('axis', self.gds_format_string(self.axis))
        if self.number is not None:
            element.set('number', self.number)
        if self.width is not None:
            element.set('width', self.width)
        if self.offset is not None:
            element.set('offset', self.offset)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.volumeref is not None:
            volumeref_ = self.volumeref
            volumeref_.to_etree(element, name_='volumeref', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DivisionPlacementType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.axis is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            showIndent(outfile, level)
            outfile.write('axis="%s",\n' % (self.axis,))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            showIndent(outfile, level)
            outfile.write('number=%s,\n' % (self.number,))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            showIndent(outfile, level)
            outfile.write('width=%s,\n' % (self.width,))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            showIndent(outfile, level)
            outfile.write('offset=%s,\n' % (self.offset,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.volumeref is not None:
            showIndent(outfile, level)
            outfile.write('volumeref=model_.ReferenceType(\n')
            self.volumeref.exportLiteral(outfile, level, name_='volumeref')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('axis', node)
        if value is not None and 'axis' not in already_processed:
            already_processed.add('axis')
            self.axis = value
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = value
            self.validate_ExpressionOrIDREFType(self.number)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
            self.validate_ExpressionOrIDREFType(self.width)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = value
            self.validate_ExpressionOrIDREFType(self.offset)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'volumeref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.volumeref = obj_
            obj_.original_tagname_ = 'volumeref'
# end class DivisionPlacementType


class VolumeType(IdentifiableVolumeType):
    """Represents a top of a geometrical sub-hierarchy not placed in space
    None of its children can coincide with its boundary defined by an
    associated solid
    Two different placements of the same logical volume represent two different
    geometrical
    hierarchies in space"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiableVolumeType
    def __init__(self, name=None, materialref=None, solidref=None, physvol=None, divisionvol=None, replicavol=None, paramvol=None, loop=None, auxiliary=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(VolumeType, self).__init__(name,  **kwargs_)
        self.materialref = materialref
        self.materialref_nsprefix_ = None
        self.solidref = solidref
        self.solidref_nsprefix_ = None
        if physvol is None:
            self.physvol = []
        else:
            self.physvol = physvol
        self.physvol_nsprefix_ = None
        self.divisionvol = divisionvol
        self.divisionvol_nsprefix_ = None
        self.replicavol = replicavol
        self.replicavol_nsprefix_ = None
        self.paramvol = paramvol
        self.paramvol_nsprefix_ = None
        if loop is None:
            self.loop = []
        else:
            self.loop = loop
        self.loop_nsprefix_ = None
        if auxiliary is None:
            self.auxiliary = []
        else:
            self.auxiliary = auxiliary
        self.auxiliary_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumeType.subclass:
            return VolumeType.subclass(*args_, **kwargs_)
        else:
            return VolumeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_materialref(self):
        return self.materialref
    def set_materialref(self, materialref):
        self.materialref = materialref
    materialrefProp = property(get_materialref, set_materialref)
    def get_solidref(self):
        return self.solidref
    def set_solidref(self, solidref):
        self.solidref = solidref
    solidrefProp = property(get_solidref, set_solidref)
    def get_physvol(self):
        return self.physvol
    def set_physvol(self, physvol):
        self.physvol = physvol
    def add_physvol(self, value):
        self.physvol.append(value)
    def insert_physvol_at(self, index, value):
        self.physvol.insert(index, value)
    def replace_physvol_at(self, index, value):
        self.physvol[index] = value
    physvolProp = property(get_physvol, set_physvol)
    def get_divisionvol(self):
        return self.divisionvol
    def set_divisionvol(self, divisionvol):
        self.divisionvol = divisionvol
    divisionvolProp = property(get_divisionvol, set_divisionvol)
    def get_replicavol(self):
        return self.replicavol
    def set_replicavol(self, replicavol):
        self.replicavol = replicavol
    replicavolProp = property(get_replicavol, set_replicavol)
    def get_paramvol(self):
        return self.paramvol
    def set_paramvol(self, paramvol):
        self.paramvol = paramvol
    paramvolProp = property(get_paramvol, set_paramvol)
    def get_loop(self):
        return self.loop
    def set_loop(self, loop):
        self.loop = loop
    def add_loop(self, value):
        self.loop.append(value)
    def insert_loop_at(self, index, value):
        self.loop.insert(index, value)
    def replace_loop_at(self, index, value):
        self.loop[index] = value
    loopProp = property(get_loop, set_loop)
    def get_auxiliary(self):
        return self.auxiliary
    def set_auxiliary(self, auxiliary):
        self.auxiliary = auxiliary
    def add_auxiliary(self, value):
        self.auxiliary.append(value)
    def insert_auxiliary_at(self, index, value):
        self.auxiliary.insert(index, value)
    def replace_auxiliary_at(self, index, value):
        self.auxiliary[index] = value
    auxiliaryProp = property(get_auxiliary, set_auxiliary)
    def hasContent_(self):
        if (
            self.materialref is not None or
            self.solidref is not None or
            self.physvol or
            self.divisionvol is not None or
            self.replicavol is not None or
            self.paramvol is not None or
            self.loop or
            self.auxiliary or
            super(VolumeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VolumeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VolumeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VolumeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VolumeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VolumeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VolumeType'):
        super(VolumeType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VolumeType')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VolumeType', fromsubclass_=False, pretty_print=True):
        super(VolumeType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.materialref is not None:
            namespaceprefix_ = self.materialref_nsprefix_ + ':' if (UseCapturedNS_ and self.materialref_nsprefix_) else ''
            self.materialref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='materialref', pretty_print=pretty_print)
        if self.solidref is not None:
            namespaceprefix_ = self.solidref_nsprefix_ + ':' if (UseCapturedNS_ and self.solidref_nsprefix_) else ''
            self.solidref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='solidref', pretty_print=pretty_print)
        for physvol_ in self.physvol:
            namespaceprefix_ = self.physvol_nsprefix_ + ':' if (UseCapturedNS_ and self.physvol_nsprefix_) else ''
            physvol_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='physvol', pretty_print=pretty_print)
        if self.divisionvol is not None:
            namespaceprefix_ = self.divisionvol_nsprefix_ + ':' if (UseCapturedNS_ and self.divisionvol_nsprefix_) else ''
            self.divisionvol.export(outfile, level, namespaceprefix_, namespacedef_='', name_='divisionvol', pretty_print=pretty_print)
        if self.replicavol is not None:
            namespaceprefix_ = self.replicavol_nsprefix_ + ':' if (UseCapturedNS_ and self.replicavol_nsprefix_) else ''
            self.replicavol.export(outfile, level, namespaceprefix_, namespacedef_='', name_='replicavol', pretty_print=pretty_print)
        if self.paramvol is not None:
            namespaceprefix_ = self.paramvol_nsprefix_ + ':' if (UseCapturedNS_ and self.paramvol_nsprefix_) else ''
            self.paramvol.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paramvol', pretty_print=pretty_print)
        for loop_ in self.loop:
            namespaceprefix_ = self.loop_nsprefix_ + ':' if (UseCapturedNS_ and self.loop_nsprefix_) else ''
            loop_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='loop', pretty_print=pretty_print)
        for auxiliary_ in self.auxiliary:
            namespaceprefix_ = self.auxiliary_nsprefix_ + ':' if (UseCapturedNS_ and self.auxiliary_nsprefix_) else ''
            auxiliary_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='auxiliary', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='VolumeType', mapping_=None, nsmap_=None):
        element = super(VolumeType, self).to_etree(parent_element, name_, mapping_)
        if self.materialref is not None:
            materialref_ = self.materialref
            materialref_.to_etree(element, name_='materialref', mapping_=mapping_, nsmap_=nsmap_)
        if self.solidref is not None:
            solidref_ = self.solidref
            solidref_.to_etree(element, name_='solidref', mapping_=mapping_, nsmap_=nsmap_)
        for physvol_ in self.physvol:
            physvol_.to_etree(element, name_='physvol', mapping_=mapping_, nsmap_=nsmap_)
        if self.divisionvol is not None:
            divisionvol_ = self.divisionvol
            divisionvol_.to_etree(element, name_='divisionvol', mapping_=mapping_, nsmap_=nsmap_)
        if self.replicavol is not None:
            replicavol_ = self.replicavol
            replicavol_.to_etree(element, name_='replicavol', mapping_=mapping_, nsmap_=nsmap_)
        if self.paramvol is not None:
            paramvol_ = self.paramvol
            paramvol_.to_etree(element, name_='paramvol', mapping_=mapping_, nsmap_=nsmap_)
        for loop_ in self.loop:
            loop_.to_etree(element, name_='loop', mapping_=mapping_, nsmap_=nsmap_)
        for auxiliary_ in self.auxiliary:
            auxiliary_.to_etree(element, name_='auxiliary', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='VolumeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VolumeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VolumeType, self).exportLiteralChildren(outfile, level, name_)
        if self.materialref is not None:
            showIndent(outfile, level)
            outfile.write('materialref=model_.ReferenceType(\n')
            self.materialref.exportLiteral(outfile, level, name_='materialref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.solidref is not None:
            showIndent(outfile, level)
            outfile.write('solidref=model_.ReferenceType(\n')
            self.solidref.exportLiteral(outfile, level, name_='solidref')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('physvol=[\n')
        level += 1
        for physvol_ in self.physvol:
            showIndent(outfile, level)
            outfile.write('model_.SinglePlacementType(\n')
            physvol_.exportLiteral(outfile, level, name_='SinglePlacementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.divisionvol is not None:
            showIndent(outfile, level)
            outfile.write('divisionvol=model_.DivisionPlacementType(\n')
            self.divisionvol.exportLiteral(outfile, level, name_='divisionvol')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.replicavol is not None:
            showIndent(outfile, level)
            outfile.write('replicavol=model_.replicavol(\n')
            self.replicavol.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.paramvol is not None:
            showIndent(outfile, level)
            outfile.write('paramvol=model_.ParameterisedPlacementType(\n')
            self.paramvol.exportLiteral(outfile, level, name_='paramvol')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('loop=[\n')
        level += 1
        for loop_ in self.loop:
            showIndent(outfile, level)
            outfile.write('model_.loop(\n')
            loop_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('auxiliary=[\n')
        level += 1
        for auxiliary_ in self.auxiliary:
            showIndent(outfile, level)
            outfile.write('model_.AuxiliaryType(\n')
            auxiliary_.exportLiteral(outfile, level, name_='AuxiliaryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VolumeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'materialref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.materialref = obj_
            obj_.original_tagname_ = 'materialref'
        elif nodeName_ == 'solidref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.solidref = obj_
            obj_.original_tagname_ = 'solidref'
        elif nodeName_ == 'physvol':
            obj_ = SinglePlacementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.physvol.append(obj_)
            obj_.original_tagname_ = 'physvol'
        elif nodeName_ == 'divisionvol':
            obj_ = DivisionPlacementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.divisionvol = obj_
            obj_.original_tagname_ = 'divisionvol'
        elif nodeName_ == 'replicavol':
            obj_ = ReplicaPlacementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.replicavol = obj_
            obj_.original_tagname_ = 'replicavol'
        elif nodeName_ == 'paramvol':
            obj_ = ParameterisedPlacementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.paramvol = obj_
            obj_.original_tagname_ = 'paramvol'
        elif nodeName_ == 'loop':
            obj_ = loop.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.loop.append(obj_)
            obj_.original_tagname_ = 'loop'
        elif nodeName_ == 'auxiliary':
            obj_ = AuxiliaryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.auxiliary.append(obj_)
            obj_.original_tagname_ = 'auxiliary'
        super(VolumeType, self).buildChildren(child_, node, nodeName_, True)
# end class VolumeType


class AssemblyVolumeType(IdentifiableVolumeType):
    """Allows to create a group of volumes bound together without a boundary
    All the volumes exits inside the same virtual reference system of the
    assmebly volume
    they belong to
    When assembly volume is placed all its children follow the global
    transformation applied
    to their assembly volume
    After the assembly volume is placed its children exist as standalone
    placements in space
    independent of each other"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiableVolumeType
    def __init__(self, name=None, physvol=None, replicavol=None, paramvol=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AssemblyVolumeType, self).__init__(name,  **kwargs_)
        if physvol is None:
            self.physvol = []
        else:
            self.physvol = physvol
        self.physvol_nsprefix_ = None
        self.replicavol = replicavol
        self.replicavol_nsprefix_ = None
        self.paramvol = paramvol
        self.paramvol_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssemblyVolumeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssemblyVolumeType.subclass:
            return AssemblyVolumeType.subclass(*args_, **kwargs_)
        else:
            return AssemblyVolumeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_physvol(self):
        return self.physvol
    def set_physvol(self, physvol):
        self.physvol = physvol
    def add_physvol(self, value):
        self.physvol.append(value)
    def insert_physvol_at(self, index, value):
        self.physvol.insert(index, value)
    def replace_physvol_at(self, index, value):
        self.physvol[index] = value
    physvolProp = property(get_physvol, set_physvol)
    def get_replicavol(self):
        return self.replicavol
    def set_replicavol(self, replicavol):
        self.replicavol = replicavol
    replicavolProp = property(get_replicavol, set_replicavol)
    def get_paramvol(self):
        return self.paramvol
    def set_paramvol(self, paramvol):
        self.paramvol = paramvol
    paramvolProp = property(get_paramvol, set_paramvol)
    def hasContent_(self):
        if (
            self.physvol or
            self.replicavol is not None or
            self.paramvol is not None or
            super(AssemblyVolumeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AssemblyVolumeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssemblyVolumeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AssemblyVolumeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssemblyVolumeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AssemblyVolumeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AssemblyVolumeType'):
        super(AssemblyVolumeType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssemblyVolumeType')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AssemblyVolumeType', fromsubclass_=False, pretty_print=True):
        super(AssemblyVolumeType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for physvol_ in self.physvol:
            namespaceprefix_ = self.physvol_nsprefix_ + ':' if (UseCapturedNS_ and self.physvol_nsprefix_) else ''
            physvol_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='physvol', pretty_print=pretty_print)
        if self.replicavol is not None:
            namespaceprefix_ = self.replicavol_nsprefix_ + ':' if (UseCapturedNS_ and self.replicavol_nsprefix_) else ''
            self.replicavol.export(outfile, level, namespaceprefix_, namespacedef_='', name_='replicavol', pretty_print=pretty_print)
        if self.paramvol is not None:
            namespaceprefix_ = self.paramvol_nsprefix_ + ':' if (UseCapturedNS_ and self.paramvol_nsprefix_) else ''
            self.paramvol.export(outfile, level, namespaceprefix_, namespacedef_='', name_='paramvol', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AssemblyVolumeType', mapping_=None, nsmap_=None):
        element = super(AssemblyVolumeType, self).to_etree(parent_element, name_, mapping_)
        for physvol_ in self.physvol:
            physvol_.to_etree(element, name_='physvol', mapping_=mapping_, nsmap_=nsmap_)
        if self.replicavol is not None:
            replicavol_ = self.replicavol
            replicavol_.to_etree(element, name_='replicavol', mapping_=mapping_, nsmap_=nsmap_)
        if self.paramvol is not None:
            paramvol_ = self.paramvol
            paramvol_.to_etree(element, name_='paramvol', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='AssemblyVolumeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AssemblyVolumeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AssemblyVolumeType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('physvol=[\n')
        level += 1
        for physvol_ in self.physvol:
            showIndent(outfile, level)
            outfile.write('model_.SinglePlacementType(\n')
            physvol_.exportLiteral(outfile, level, name_='SinglePlacementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.replicavol is not None:
            showIndent(outfile, level)
            outfile.write('replicavol=model_.replicavol(\n')
            self.replicavol.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.paramvol is not None:
            showIndent(outfile, level)
            outfile.write('paramvol=model_.ParameterisedPlacementType(\n')
            self.paramvol.exportLiteral(outfile, level, name_='paramvol')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AssemblyVolumeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'physvol':
            obj_ = SinglePlacementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.physvol.append(obj_)
            obj_.original_tagname_ = 'physvol'
        elif nodeName_ == 'replicavol':
            obj_ = ReplicaPlacementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.replicavol = obj_
            obj_.original_tagname_ = 'replicavol'
        elif nodeName_ == 'paramvol':
            obj_ = ParameterisedPlacementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.paramvol = obj_
            obj_.original_tagname_ = 'paramvol'
        super(AssemblyVolumeType, self).buildChildren(child_, node, nodeName_, True)
# end class AssemblyVolumeType


class LogicalSurfaceType(GeneratedsSuper):
    """Base type for logical surfaces (for the moment only optical)"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, surfaceproperty=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.surfaceproperty = _cast(None, surfaceproperty)
        self.surfaceproperty_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalSurfaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalSurfaceType.subclass:
            return LogicalSurfaceType.subclass(*args_, **kwargs_)
        else:
            return LogicalSurfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_surfaceproperty(self):
        return self.surfaceproperty
    def set_surfaceproperty(self, surfaceproperty):
        self.surfaceproperty = surfaceproperty
    surfacepropertyProp = property(get_surfaceproperty, set_surfaceproperty)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LogicalSurfaceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LogicalSurfaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LogicalSurfaceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LogicalSurfaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LogicalSurfaceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LogicalSurfaceType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.surfaceproperty is not None and 'surfaceproperty' not in already_processed:
            already_processed.add('surfaceproperty')
            outfile.write(' surfaceproperty=%s' % (quote_attrib(self.surfaceproperty), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LogicalSurfaceType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='LogicalSurfaceType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.surfaceproperty is not None:
            element.set('surfaceproperty', self.surfaceproperty)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='LogicalSurfaceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.surfaceproperty is not None and 'surfaceproperty' not in already_processed:
            already_processed.add('surfaceproperty')
            showIndent(outfile, level)
            outfile.write('surfaceproperty=%s,\n' % (self.surfaceproperty,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('surfaceproperty', node)
        if value is not None and 'surfaceproperty' not in already_processed:
            already_processed.add('surfaceproperty')
            self.surfaceproperty = value
            self.validate_ExpressionOrIDREFType(self.surfaceproperty)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LogicalSurfaceType


class bordersurface(LogicalSurfaceType):
    """Surface between two physical volumes"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = LogicalSurfaceType
    def __init__(self, name=None, surfaceproperty=None, physvolref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(bordersurface, self).__init__(name, surfaceproperty,  **kwargs_)
        self.physvolref = physvolref
        self.physvolref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bordersurface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bordersurface.subclass:
            return bordersurface.subclass(*args_, **kwargs_)
        else:
            return bordersurface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_physvolref(self):
        return self.physvolref
    def set_physvolref(self, physvolref):
        self.physvolref = physvolref
    physvolrefProp = property(get_physvolref, set_physvolref)
    def hasContent_(self):
        if (
            self.physvolref is not None or
            super(bordersurface, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bordersurface', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bordersurface')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'bordersurface':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bordersurface')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='bordersurface', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='bordersurface'):
        super(bordersurface, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bordersurface')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bordersurface', fromsubclass_=False, pretty_print=True):
        super(bordersurface, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.physvolref is not None:
            namespaceprefix_ = self.physvolref_nsprefix_ + ':' if (UseCapturedNS_ and self.physvolref_nsprefix_) else ''
            self.physvolref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='physvolref', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='bordersurface', mapping_=None, nsmap_=None):
        element = super(bordersurface, self).to_etree(parent_element, name_, mapping_)
        if self.physvolref is not None:
            physvolref_ = self.physvolref
            physvolref_.to_etree(element, name_='physvolref', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='bordersurface'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(bordersurface, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(bordersurface, self).exportLiteralChildren(outfile, level, name_)
        if self.physvolref is not None:
            showIndent(outfile, level)
            outfile.write('physvolref=model_.ReferenceType(\n')
            self.physvolref.exportLiteral(outfile, level, name_='physvolref')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(bordersurface, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'physvolref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.physvolref = obj_
            obj_.original_tagname_ = 'physvolref'
        super(bordersurface, self).buildChildren(child_, node, nodeName_, True)
# end class bordersurface


class skinsurface(LogicalSurfaceType):
    """Surface between two physical volumes"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = LogicalSurfaceType
    def __init__(self, name=None, surfaceproperty=None, volumeref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(skinsurface, self).__init__(name, surfaceproperty,  **kwargs_)
        self.volumeref = volumeref
        self.volumeref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, skinsurface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if skinsurface.subclass:
            return skinsurface.subclass(*args_, **kwargs_)
        else:
            return skinsurface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_volumeref(self):
        return self.volumeref
    def set_volumeref(self, volumeref):
        self.volumeref = volumeref
    volumerefProp = property(get_volumeref, set_volumeref)
    def hasContent_(self):
        if (
            self.volumeref is not None or
            super(skinsurface, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='skinsurface', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('skinsurface')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'skinsurface':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='skinsurface')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='skinsurface', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='skinsurface'):
        super(skinsurface, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='skinsurface')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='skinsurface', fromsubclass_=False, pretty_print=True):
        super(skinsurface, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.volumeref is not None:
            namespaceprefix_ = self.volumeref_nsprefix_ + ':' if (UseCapturedNS_ and self.volumeref_nsprefix_) else ''
            self.volumeref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='volumeref', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='skinsurface', mapping_=None, nsmap_=None):
        element = super(skinsurface, self).to_etree(parent_element, name_, mapping_)
        if self.volumeref is not None:
            volumeref_ = self.volumeref
            volumeref_.to_etree(element, name_='volumeref', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='skinsurface'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(skinsurface, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(skinsurface, self).exportLiteralChildren(outfile, level, name_)
        if self.volumeref is not None:
            showIndent(outfile, level)
            outfile.write('volumeref=model_.ReferenceType(\n')
            self.volumeref.exportLiteral(outfile, level, name_='volumeref')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(skinsurface, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'volumeref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.volumeref = obj_
            obj_.original_tagname_ = 'volumeref'
        super(skinsurface, self).buildChildren(child_, node, nodeName_, True)
# end class skinsurface


class structure(GeneratedsSuper):
    """Definitions of a geometrical hierarchy of a set of volumes"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, volume=None, assembly=None, loop=None, ParameterisationAlgorithm=None, Surface=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if volume is None:
            self.volume = []
        else:
            self.volume = volume
        self.volume_nsprefix_ = None
        if assembly is None:
            self.assembly = []
        else:
            self.assembly = assembly
        self.assembly_nsprefix_ = None
        if loop is None:
            self.loop = []
        else:
            self.loop = loop
        self.loop_nsprefix_ = None
        if ParameterisationAlgorithm is None:
            self.ParameterisationAlgorithm = []
        else:
            self.ParameterisationAlgorithm = ParameterisationAlgorithm
        self.ParameterisationAlgorithm_nsprefix_ = None
        if Surface is None:
            self.Surface = []
        else:
            self.Surface = Surface
        self.Surface_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, structure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if structure.subclass:
            return structure.subclass(*args_, **kwargs_)
        else:
            return structure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_volume(self):
        return self.volume
    def set_volume(self, volume):
        self.volume = volume
    def add_volume(self, value):
        self.volume.append(value)
    def insert_volume_at(self, index, value):
        self.volume.insert(index, value)
    def replace_volume_at(self, index, value):
        self.volume[index] = value
    volumeProp = property(get_volume, set_volume)
    def get_assembly(self):
        return self.assembly
    def set_assembly(self, assembly):
        self.assembly = assembly
    def add_assembly(self, value):
        self.assembly.append(value)
    def insert_assembly_at(self, index, value):
        self.assembly.insert(index, value)
    def replace_assembly_at(self, index, value):
        self.assembly[index] = value
    assemblyProp = property(get_assembly, set_assembly)
    def get_loop(self):
        return self.loop
    def set_loop(self, loop):
        self.loop = loop
    def add_loop(self, value):
        self.loop.append(value)
    def insert_loop_at(self, index, value):
        self.loop.insert(index, value)
    def replace_loop_at(self, index, value):
        self.loop[index] = value
    loopProp = property(get_loop, set_loop)
    def get_ParameterisationAlgorithm(self):
        return self.ParameterisationAlgorithm
    def set_ParameterisationAlgorithm(self, ParameterisationAlgorithm):
        self.ParameterisationAlgorithm = ParameterisationAlgorithm
    def add_ParameterisationAlgorithm(self, value):
        self.ParameterisationAlgorithm.append(value)
    def insert_ParameterisationAlgorithm_at(self, index, value):
        self.ParameterisationAlgorithm.insert(index, value)
    def replace_ParameterisationAlgorithm_at(self, index, value):
        self.ParameterisationAlgorithm[index] = value
    ParameterisationAlgorithmProp = property(get_ParameterisationAlgorithm, set_ParameterisationAlgorithm)
    def get_Surface(self):
        return self.Surface
    def set_Surface(self, Surface):
        self.Surface = Surface
    def add_Surface(self, value):
        self.Surface.append(value)
    def insert_Surface_at(self, index, value):
        self.Surface.insert(index, value)
    def replace_Surface_at(self, index, value):
        self.Surface[index] = value
    SurfaceProp = property(get_Surface, set_Surface)
    def hasContent_(self):
        if (
            self.volume or
            self.assembly or
            self.loop or
            self.ParameterisationAlgorithm or
            self.Surface
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='structure', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('structure')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'structure':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='structure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='structure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='structure'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='structure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for volume_ in self.volume:
            namespaceprefix_ = self.volume_nsprefix_ + ':' if (UseCapturedNS_ and self.volume_nsprefix_) else ''
            volume_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='volume', pretty_print=pretty_print)
        for assembly_ in self.assembly:
            namespaceprefix_ = self.assembly_nsprefix_ + ':' if (UseCapturedNS_ and self.assembly_nsprefix_) else ''
            assembly_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assembly', pretty_print=pretty_print)
        for loop_ in self.loop:
            namespaceprefix_ = self.loop_nsprefix_ + ':' if (UseCapturedNS_ and self.loop_nsprefix_) else ''
            loop_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='loop', pretty_print=pretty_print)
        for ParameterisationAlgorithm_ in self.ParameterisationAlgorithm:
            ParameterisationAlgorithm_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        for Surface_ in self.Surface:
            Surface_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='structure', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        for volume_ in self.volume:
            volume_.to_etree(element, name_='volume', mapping_=mapping_, nsmap_=nsmap_)
        for assembly_ in self.assembly:
            assembly_.to_etree(element, name_='assembly', mapping_=mapping_, nsmap_=nsmap_)
        for loop_ in self.loop:
            loop_.to_etree(element, name_='loop', mapping_=mapping_, nsmap_=nsmap_)
        for ParameterisationAlgorithm_ in self.ParameterisationAlgorithm:
            ParameterisationAlgorithm_.to_etree(element, name_='ParameterisationAlgorithm', mapping_=mapping_, nsmap_=nsmap_)
        for Surface_ in self.Surface:
            Surface_.to_etree(element, name_='Surface', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='structure'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('volume=[\n')
        level += 1
        for volume_ in self.volume:
            showIndent(outfile, level)
            outfile.write('model_.VolumeType(\n')
            volume_.exportLiteral(outfile, level, name_='VolumeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('assembly=[\n')
        level += 1
        for assembly_ in self.assembly:
            showIndent(outfile, level)
            outfile.write('model_.AssemblyVolumeType(\n')
            assembly_.exportLiteral(outfile, level, name_='AssemblyVolumeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('loop=[\n')
        level += 1
        for loop_ in self.loop:
            showIndent(outfile, level)
            outfile.write('model_.loop(\n')
            loop_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ParameterisationAlgorithm=[\n')
        level += 1
        for ParameterisationAlgorithm_ in self.ParameterisationAlgorithm:
            showIndent(outfile, level)
            outfile.write('model_.ParameterisationAlgorithm(\n')
            ParameterisationAlgorithm_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Surface=[\n')
        level += 1
        for Surface_ in self.Surface:
            showIndent(outfile, level)
            outfile.write('model_.Surface(\n')
            Surface_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'volume':
            obj_ = VolumeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.volume.append(obj_)
            obj_.original_tagname_ = 'volume'
        elif nodeName_ == 'assembly':
            obj_ = AssemblyVolumeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assembly.append(obj_)
            obj_.original_tagname_ = 'assembly'
        elif nodeName_ == 'loop':
            obj_ = loop.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.loop.append(obj_)
            obj_.original_tagname_ = 'loop'
        elif nodeName_ == 'ParameterisationAlgorithm':
            class_obj_ = self.get_class_obj_(child_, ParameterisationAlgorithmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterisationAlgorithm.append(obj_)
            obj_.original_tagname_ = 'ParameterisationAlgorithm'
        elif nodeName_ == 'parameterised_position_size':
            obj_ = PositionSizeParameterisationAlgorithmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterisationAlgorithm.append(obj_)
            obj_.original_tagname_ = 'parameterised_position_size'
        elif nodeName_ == 'Surface':
            class_obj_ = self.get_class_obj_(child_, LogicalSurfaceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Surface.append(obj_)
            obj_.original_tagname_ = 'Surface'
        elif nodeName_ == 'bordersurface':
            obj_ = bordersurface.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Surface.append(obj_)
            obj_.original_tagname_ = 'bordersurface'
        elif nodeName_ == 'skinsurface':
            obj_ = skinsurface.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Surface.append(obj_)
            obj_.original_tagname_ = 'skinsurface'
# end class structure


class gdml(GeneratedsSuper):
    """The GDML Schema version consists of 3 digits X.Y.Z
    where these mean:
    X - major number, increased when major new
    features or backward incompatible bug fixes
    are added and means the GDML Processor is
    allowed to refuse processing of such a
    document if this is using the more recent
    version of the GDML Schema then GDML Processor
    understands
    Y - minor number, increased when incremental and
    backward compatible changes or improvements
    are made into the GDML Schema. GDML Processor
    should be able to process such a document
    using higher minor version number then that of
    the GDML Processor
    Z - bugfix revision number, increased when fully
    backward compatible changes which resolve a
    problem in GDML Schema are applied"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, version='3.1.6', define=None, materials=None, solids=None, structure=None, userinfo=None, setup=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.define = define
        self.define_nsprefix_ = None
        self.materials = materials
        self.materials_nsprefix_ = None
        self.solids = solids
        self.solids_nsprefix_ = None
        self.structure = structure
        self.structure_nsprefix_ = None
        self.userinfo = userinfo
        self.userinfo_nsprefix_ = None
        if setup is None:
            self.setup = []
        else:
            self.setup = setup
        self.setup_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, gdml)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if gdml.subclass:
            return gdml.subclass(*args_, **kwargs_)
        else:
            return gdml(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_define(self):
        return self.define
    def set_define(self, define):
        self.define = define
    defineProp = property(get_define, set_define)
    def get_materials(self):
        return self.materials
    def set_materials(self, materials):
        self.materials = materials
    materialsProp = property(get_materials, set_materials)
    def get_solids(self):
        return self.solids
    def set_solids(self, solids):
        self.solids = solids
    solidsProp = property(get_solids, set_solids)
    def get_structure(self):
        return self.structure
    def set_structure(self, structure):
        self.structure = structure
    structureProp = property(get_structure, set_structure)
    def get_userinfo(self):
        return self.userinfo
    def set_userinfo(self, userinfo):
        self.userinfo = userinfo
    userinfoProp = property(get_userinfo, set_userinfo)
    def get_setup(self):
        return self.setup
    def set_setup(self, setup):
        self.setup = setup
    def add_setup(self, value):
        self.setup.append(value)
    def insert_setup_at(self, index, value):
        self.setup.insert(index, value)
    def replace_setup_at(self, index, value):
        self.setup[index] = value
    setupProp = property(get_setup, set_setup)
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    versionProp = property(get_version, set_version)
    def hasContent_(self):
        if (
            self.define is not None or
            self.materials is not None or
            self.solids is not None or
            self.structure is not None or
            self.userinfo is not None or
            self.setup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='gdml', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gdml')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'gdml':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gdml')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='gdml', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='gdml'):
        if self.version != "3.1.6" and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='gdml', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.define is not None:
            namespaceprefix_ = self.define_nsprefix_ + ':' if (UseCapturedNS_ and self.define_nsprefix_) else ''
            self.define.export(outfile, level, namespaceprefix_, namespacedef_='', name_='define', pretty_print=pretty_print)
        if self.materials is not None:
            namespaceprefix_ = self.materials_nsprefix_ + ':' if (UseCapturedNS_ and self.materials_nsprefix_) else ''
            self.materials.export(outfile, level, namespaceprefix_, namespacedef_='', name_='materials', pretty_print=pretty_print)
        if self.solids is not None:
            namespaceprefix_ = self.solids_nsprefix_ + ':' if (UseCapturedNS_ and self.solids_nsprefix_) else ''
            self.solids.export(outfile, level, namespaceprefix_, namespacedef_='', name_='solids', pretty_print=pretty_print)
        if self.structure is not None:
            namespaceprefix_ = self.structure_nsprefix_ + ':' if (UseCapturedNS_ and self.structure_nsprefix_) else ''
            self.structure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='structure', pretty_print=pretty_print)
        if self.userinfo is not None:
            namespaceprefix_ = self.userinfo_nsprefix_ + ':' if (UseCapturedNS_ and self.userinfo_nsprefix_) else ''
            self.userinfo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='userinfo', pretty_print=pretty_print)
        for setup_ in self.setup:
            namespaceprefix_ = self.setup_nsprefix_ + ':' if (UseCapturedNS_ and self.setup_nsprefix_) else ''
            setup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setup', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='gdml', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.version is not None:
            element.set('version', self.gds_format_string(self.version))
        if self.define is not None:
            define_ = self.define
            define_.to_etree(element, name_='define', mapping_=mapping_, nsmap_=nsmap_)
        if self.materials is not None:
            materials_ = self.materials
            materials_.to_etree(element, name_='materials', mapping_=mapping_, nsmap_=nsmap_)
        if self.solids is not None:
            solids_ = self.solids
            solids_.to_etree(element, name_='solids', mapping_=mapping_, nsmap_=nsmap_)
        if self.structure is not None:
            structure_ = self.structure
            structure_.to_etree(element, name_='structure', mapping_=mapping_, nsmap_=nsmap_)
        if self.userinfo is not None:
            userinfo_ = self.userinfo
            userinfo_.to_etree(element, name_='userinfo', mapping_=mapping_, nsmap_=nsmap_)
        for setup_ in self.setup:
            setup_.to_etree(element, name_='setup', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='gdml'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.define is not None:
            showIndent(outfile, level)
            outfile.write('define=model_.define(\n')
            self.define.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.materials is not None:
            showIndent(outfile, level)
            outfile.write('materials=model_.materials(\n')
            self.materials.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.solids is not None:
            showIndent(outfile, level)
            outfile.write('solids=model_.solids(\n')
            self.solids.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.structure is not None:
            showIndent(outfile, level)
            outfile.write('structure=model_.structure(\n')
            self.structure.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.userinfo is not None:
            showIndent(outfile, level)
            outfile.write('userinfo=model_.userinfoType(\n')
            self.userinfo.exportLiteral(outfile, level, name_='userinfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('setup=[\n')
        level += 1
        for setup_ in self.setup:
            showIndent(outfile, level)
            outfile.write('model_.setupType(\n')
            setup_.exportLiteral(outfile, level, name_='setupType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'define':
            obj_ = defineType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.define = obj_
            obj_.original_tagname_ = 'define'
        elif nodeName_ == 'materials':
            obj_ = materials.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.materials = obj_
            obj_.original_tagname_ = 'materials'
        elif nodeName_ == 'solids':
            obj_ = solids.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.solids = obj_
            obj_.original_tagname_ = 'solids'
        elif nodeName_ == 'structure':
            obj_ = structure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.structure = obj_
            obj_.original_tagname_ = 'structure'
        elif nodeName_ == 'userinfo':
            obj_ = userinfoType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.userinfo = obj_
            obj_.original_tagname_ = 'userinfo'
        elif nodeName_ == 'setup':
            obj_ = setupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setup.append(obj_)
            obj_.original_tagname_ = 'setup'
# end class gdml


class IdentifiableExpressionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiableExpressionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiableExpressionType.subclass:
            return IdentifiableExpressionType.subclass(*args_, **kwargs_)
        else:
            return IdentifiableExpressionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentifiableExpressionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentifiableExpressionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IdentifiableExpressionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifiableExpressionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IdentifiableExpressionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IdentifiableExpressionType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentifiableExpressionType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='IdentifiableExpressionType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='IdentifiableExpressionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class IdentifiableExpressionType


class ConstantType(GeneratedsSuper):
    """An anonymous, local scope, value"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, value=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConstantType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConstantType.subclass:
            return ConstantType.subclass(*args_, **kwargs_)
        else:
            return ConstantType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    valueProp = property(get_value, set_value)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConstantType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConstantType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConstantType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConstantType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConstantType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConstantType'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConstantType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='ConstantType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.value is not None:
            element.set('value', self.value)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ConstantType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_ExpressionOrIDREFType(self.value)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ConstantType


class VariableType(GeneratedsSuper):
    """An anonymous, local scope, value"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, value=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableType.subclass:
            return VariableType.subclass(*args_, **kwargs_)
        else:
            return VariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    valueProp = property(get_value, set_value)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VariableType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VariableType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VariableType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VariableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VariableType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VariableType'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VariableType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='VariableType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.value is not None:
            element.set('value', self.value)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='VariableType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_ExpressionOrIDREFType(self.value)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class VariableType


class IdentifiableConstantType(ConstantType):
    """Named (referenced), global scope, constant value"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ConstantType
    def __init__(self, value=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IdentifiableConstantType, self).__init__(value,  **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiableConstantType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiableConstantType.subclass:
            return IdentifiableConstantType.subclass(*args_, **kwargs_)
        else:
            return IdentifiableConstantType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def hasContent_(self):
        if (
            super(IdentifiableConstantType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentifiableConstantType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentifiableConstantType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IdentifiableConstantType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifiableConstantType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IdentifiableConstantType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IdentifiableConstantType'):
        super(IdentifiableConstantType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifiableConstantType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentifiableConstantType', fromsubclass_=False, pretty_print=True):
        super(IdentifiableConstantType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='IdentifiableConstantType', mapping_=None, nsmap_=None):
        element = super(IdentifiableConstantType, self).to_etree(parent_element, name_, mapping_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='IdentifiableConstantType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(IdentifiableConstantType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IdentifiableConstantType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(IdentifiableConstantType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IdentifiableConstantType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IdentifiableConstantType


class IdentifiableVariableType(VariableType):
    """Named (referenced), local scope, variable value"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = VariableType
    def __init__(self, value=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IdentifiableVariableType, self).__init__(value,  **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiableVariableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiableVariableType.subclass:
            return IdentifiableVariableType.subclass(*args_, **kwargs_)
        else:
            return IdentifiableVariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def hasContent_(self):
        if (
            super(IdentifiableVariableType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentifiableVariableType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentifiableVariableType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IdentifiableVariableType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifiableVariableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IdentifiableVariableType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IdentifiableVariableType'):
        super(IdentifiableVariableType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifiableVariableType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentifiableVariableType', fromsubclass_=False, pretty_print=True):
        super(IdentifiableVariableType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='IdentifiableVariableType', mapping_=None, nsmap_=None):
        element = super(IdentifiableVariableType, self).to_etree(parent_element, name_, mapping_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='IdentifiableVariableType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(IdentifiableVariableType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IdentifiableVariableType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(IdentifiableVariableType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IdentifiableVariableType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IdentifiableVariableType


class QuantityType(ConstantType):
    """An anonymous quantity, local scope, with a unit,
    (possibly of a given type) quantity"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ConstantType
    def __init__(self, value=None, unit=None, type_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(QuantityType, self).__init__(value, extensiontype_,  **kwargs_)
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuantityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuantityType.subclass:
            return QuantityType.subclass(*args_, **kwargs_)
        else:
            return QuantityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(QuantityType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='QuantityType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QuantityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QuantityType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuantityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QuantityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QuantityType'):
        super(QuantityType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuantityType')
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='QuantityType', fromsubclass_=False, pretty_print=True):
        super(QuantityType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='QuantityType', mapping_=None, nsmap_=None):
        element = super(QuantityType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QuantityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(QuantityType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QuantityType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QuantityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QuantityType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QuantityType


class IdentifiableQuantityType(QuantityType):
    """Named (referenced), global scope,(possibly of a given type) quantity"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuantityType
    def __init__(self, value=None, unit=None, type_=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IdentifiableQuantityType, self).__init__(value, unit, type_,  **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiableQuantityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiableQuantityType.subclass:
            return IdentifiableQuantityType.subclass(*args_, **kwargs_)
        else:
            return IdentifiableQuantityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def hasContent_(self):
        if (
            super(IdentifiableQuantityType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentifiableQuantityType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentifiableQuantityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IdentifiableQuantityType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifiableQuantityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IdentifiableQuantityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IdentifiableQuantityType'):
        super(IdentifiableQuantityType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifiableQuantityType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentifiableQuantityType', fromsubclass_=False, pretty_print=True):
        super(IdentifiableQuantityType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='IdentifiableQuantityType', mapping_=None, nsmap_=None):
        element = super(IdentifiableQuantityType, self).to_etree(parent_element, name_, mapping_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='IdentifiableQuantityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(IdentifiableQuantityType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IdentifiableQuantityType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(IdentifiableQuantityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IdentifiableQuantityType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IdentifiableQuantityType


class ThreeVectorType(GeneratedsSuper):
    """An anonymous, 3 dimensional, local scope, vector of doubles"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, x='0.0', y='0.0', z='0.0', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.x = _cast(None, x)
        self.x_nsprefix_ = None
        self.y = _cast(None, y)
        self.y_nsprefix_ = None
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ThreeVectorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ThreeVectorType.subclass:
            return ThreeVectorType.subclass(*args_, **kwargs_)
        else:
            return ThreeVectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    xProp = property(get_x, set_x)
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    yProp = property(get_y, set_y)
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ThreeVectorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ThreeVectorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ThreeVectorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ThreeVectorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ThreeVectorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ThreeVectorType'):
        if self.x != "0.0" and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x=%s' % (quote_attrib(self.x), ))
        if self.y != "0.0" and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y=%s' % (quote_attrib(self.y), ))
        if self.z != "0.0" and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ThreeVectorType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='ThreeVectorType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.x is not None:
            element.set('x', self.x)
        if self.y is not None:
            element.set('y', self.y)
        if self.z is not None:
            element.set('z', self.z)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ThreeVectorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%s,\n' % (self.x,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%s,\n' % (self.y,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            self.x = value
            self.validate_ExpressionOrIDREFType(self.x)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            self.y = value
            self.validate_ExpressionOrIDREFType(self.y)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ThreeVectorType


class MatrixType(GeneratedsSuper):
    """A bi-dimensional matrix of doubles"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, coldim=None, values=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.coldim = _cast(int, coldim)
        self.coldim_nsprefix_ = None
        self.values = _cast(None, values)
        self.values_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MatrixType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MatrixType.subclass:
            return MatrixType.subclass(*args_, **kwargs_)
        else:
            return MatrixType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_coldim(self):
        return self.coldim
    def set_coldim(self, coldim):
        self.coldim = coldim
    coldimProp = property(get_coldim, set_coldim)
    def get_values(self):
        return self.values
    def set_values(self, values):
        self.values = values
    valuesProp = property(get_values, set_values)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MatrixType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MatrixType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MatrixType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MatrixType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MatrixType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MatrixType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.coldim is not None and 'coldim' not in already_processed:
            already_processed.add('coldim')
            outfile.write(' coldim="%s"' % self.gds_format_integer(self.coldim, input_name='coldim'))
        if self.values is not None and 'values' not in already_processed:
            already_processed.add('values')
            outfile.write(' values=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.values), input_name='values')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MatrixType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='MatrixType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.coldim is not None:
            element.set('coldim', self.gds_format_integer(self.coldim))
        if self.values is not None:
            element.set('values', self.gds_format_string(self.values))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='MatrixType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.coldim is not None and 'coldim' not in already_processed:
            already_processed.add('coldim')
            showIndent(outfile, level)
            outfile.write('coldim=%d,\n' % (self.coldim,))
        if self.values is not None and 'values' not in already_processed:
            already_processed.add('values')
            showIndent(outfile, level)
            outfile.write('values="%s",\n' % (self.values,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('coldim', node)
        if value is not None and 'coldim' not in already_processed:
            already_processed.add('coldim')
            self.coldim = self.gds_parse_integer(value, node, 'coldim')
            if self.coldim < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('values', node)
        if value is not None and 'values' not in already_processed:
            already_processed.add('values')
            self.values = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class MatrixType


class IdentifiableThreeVectorType(ThreeVectorType):
    """Named (referenced), 3 dimensional, global scope, vector of doubles"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ThreeVectorType
    def __init__(self, x='0.0', y='0.0', z='0.0', name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IdentifiableThreeVectorType, self).__init__(x, y, z,  **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiableThreeVectorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiableThreeVectorType.subclass:
            return IdentifiableThreeVectorType.subclass(*args_, **kwargs_)
        else:
            return IdentifiableThreeVectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def hasContent_(self):
        if (
            super(IdentifiableThreeVectorType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentifiableThreeVectorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentifiableThreeVectorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IdentifiableThreeVectorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifiableThreeVectorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IdentifiableThreeVectorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IdentifiableThreeVectorType'):
        super(IdentifiableThreeVectorType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifiableThreeVectorType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentifiableThreeVectorType', fromsubclass_=False, pretty_print=True):
        super(IdentifiableThreeVectorType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='IdentifiableThreeVectorType', mapping_=None, nsmap_=None):
        element = super(IdentifiableThreeVectorType, self).to_etree(parent_element, name_, mapping_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='IdentifiableThreeVectorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(IdentifiableThreeVectorType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IdentifiableThreeVectorType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(IdentifiableThreeVectorType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IdentifiableThreeVectorType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IdentifiableThreeVectorType


class QuantityVectorType(ThreeVectorType):
    """An anonymous, 3 dimensional, local scope, with a unit,
    (possibly of a given type) quantity vector"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ThreeVectorType
    def __init__(self, x='0.0', y='0.0', z='0.0', unit=None, type_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(QuantityVectorType, self).__init__(x, y, z, extensiontype_,  **kwargs_)
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuantityVectorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuantityVectorType.subclass:
            return QuantityVectorType.subclass(*args_, **kwargs_)
        else:
            return QuantityVectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(QuantityVectorType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='QuantityVectorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QuantityVectorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QuantityVectorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuantityVectorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QuantityVectorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QuantityVectorType'):
        super(QuantityVectorType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuantityVectorType')
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='QuantityVectorType', fromsubclass_=False, pretty_print=True):
        super(QuantityVectorType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='QuantityVectorType', mapping_=None, nsmap_=None):
        element = super(QuantityVectorType, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='QuantityVectorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(QuantityVectorType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QuantityVectorType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(QuantityVectorType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(QuantityVectorType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QuantityVectorType


class IdentifiableQuantityVectorType(QuantityVectorType):
    """Named (referenced), 3 dimensional, global scope, with a unit,
    (possibly of a given type) quantity vector"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuantityVectorType
    def __init__(self, x='0.0', y='0.0', z='0.0', unit=None, type_=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(IdentifiableQuantityVectorType, self).__init__(x, y, z, unit, type_,  **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiableQuantityVectorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiableQuantityVectorType.subclass:
            return IdentifiableQuantityVectorType.subclass(*args_, **kwargs_)
        else:
            return IdentifiableQuantityVectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def hasContent_(self):
        if (
            super(IdentifiableQuantityVectorType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentifiableQuantityVectorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentifiableQuantityVectorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IdentifiableQuantityVectorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifiableQuantityVectorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IdentifiableQuantityVectorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IdentifiableQuantityVectorType'):
        super(IdentifiableQuantityVectorType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifiableQuantityVectorType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentifiableQuantityVectorType', fromsubclass_=False, pretty_print=True):
        super(IdentifiableQuantityVectorType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='IdentifiableQuantityVectorType', mapping_=None, nsmap_=None):
        element = super(IdentifiableQuantityVectorType, self).to_etree(parent_element, name_, mapping_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='IdentifiableQuantityVectorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(IdentifiableQuantityVectorType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IdentifiableQuantityVectorType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(IdentifiableQuantityVectorType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IdentifiableQuantityVectorType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IdentifiableQuantityVectorType


class ReferenceType(GeneratedsSuper):
    """Local reference to an element of a named type"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ref=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ref = _cast(None, ref)
        self.ref_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    refProp = property(get_ref, set_ref)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReferenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReferenceType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref), input_name='ref')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='ReferenceType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.ref is not None:
            element.set('ref', self.gds_format_string(self.ref))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            showIndent(outfile, level)
            outfile.write('ref="%s",\n' % (self.ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ReferenceType


class FileReferenceType(GeneratedsSuper):
    """Reference to an external file containing sub-volume information"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, volname=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.volname = _cast(None, volname)
        self.volname_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FileReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FileReferenceType.subclass:
            return FileReferenceType.subclass(*args_, **kwargs_)
        else:
            return FileReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_volname(self):
        return self.volname
    def set_volname(self, volname):
        self.volname = volname
    volnameProp = property(get_volname, set_volname)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FileReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FileReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FileReferenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FileReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FileReferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FileReferenceType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.volname is not None and 'volname' not in already_processed:
            already_processed.add('volname')
            outfile.write(' volname=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.volname), input_name='volname')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FileReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='FileReferenceType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.volname is not None:
            element.set('volname', self.gds_format_string(self.volname))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='FileReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.volname is not None and 'volname' not in already_processed:
            already_processed.add('volname')
            showIndent(outfile, level)
            outfile.write('volname="%s",\n' % (self.volname,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('volname', node)
        if value is not None and 'volname' not in already_processed:
            already_processed.add('volname')
            self.volname = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class FileReferenceType


class ReferenceListType(GeneratedsSuper):
    """List of local references to a set of element of a named type"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refs=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refs = _cast(None, refs)
        self.refs_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceListType.subclass:
            return ReferenceListType.subclass(*args_, **kwargs_)
        else:
            return ReferenceListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_refs(self):
        return self.refs
    def set_refs(self, refs):
        self.refs = refs
    refsProp = property(get_refs, set_refs)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReferenceListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReferenceListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferenceListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferenceListType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReferenceListType'):
        if self.refs is not None and 'refs' not in already_processed:
            already_processed.add('refs')
            outfile.write(' refs=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refs), input_name='refs')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReferenceListType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='ReferenceListType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.refs is not None:
            element.set('refs', self.gds_format_string(self.refs))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ReferenceListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.refs is not None and 'refs' not in already_processed:
            already_processed.add('refs')
            showIndent(outfile, level)
            outfile.write('refs="%s",\n' % (self.refs,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refs', node)
        if value is not None and 'refs' not in already_processed:
            already_processed.add('refs')
            self.refs = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ReferenceListType


class AuxiliaryType(GeneratedsSuper):
    """Auxiliary information like sensitive detector declaration, etc."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, auxtype=None, auxvalue=None, auxunit=None, auxiliary=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.auxtype = _cast(None, auxtype)
        self.auxtype_nsprefix_ = None
        self.auxvalue = _cast(None, auxvalue)
        self.auxvalue_nsprefix_ = None
        self.auxunit = _cast(None, auxunit)
        self.auxunit_nsprefix_ = None
        if auxiliary is None:
            self.auxiliary = []
        else:
            self.auxiliary = auxiliary
        self.auxiliary_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AuxiliaryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AuxiliaryType.subclass:
            return AuxiliaryType.subclass(*args_, **kwargs_)
        else:
            return AuxiliaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_auxiliary(self):
        return self.auxiliary
    def set_auxiliary(self, auxiliary):
        self.auxiliary = auxiliary
    def add_auxiliary(self, value):
        self.auxiliary.append(value)
    def insert_auxiliary_at(self, index, value):
        self.auxiliary.insert(index, value)
    def replace_auxiliary_at(self, index, value):
        self.auxiliary[index] = value
    auxiliaryProp = property(get_auxiliary, set_auxiliary)
    def get_auxtype(self):
        return self.auxtype
    def set_auxtype(self, auxtype):
        self.auxtype = auxtype
    auxtypeProp = property(get_auxtype, set_auxtype)
    def get_auxvalue(self):
        return self.auxvalue
    def set_auxvalue(self, auxvalue):
        self.auxvalue = auxvalue
    auxvalueProp = property(get_auxvalue, set_auxvalue)
    def get_auxunit(self):
        return self.auxunit
    def set_auxunit(self, auxunit):
        self.auxunit = auxunit
    auxunitProp = property(get_auxunit, set_auxunit)
    def hasContent_(self):
        if (
            self.auxiliary
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AuxiliaryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AuxiliaryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AuxiliaryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AuxiliaryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AuxiliaryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AuxiliaryType'):
        if self.auxtype is not None and 'auxtype' not in already_processed:
            already_processed.add('auxtype')
            outfile.write(' auxtype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.auxtype), input_name='auxtype')), ))
        if self.auxvalue is not None and 'auxvalue' not in already_processed:
            already_processed.add('auxvalue')
            outfile.write(' auxvalue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.auxvalue), input_name='auxvalue')), ))
        if self.auxunit is not None and 'auxunit' not in already_processed:
            already_processed.add('auxunit')
            outfile.write(' auxunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.auxunit), input_name='auxunit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AuxiliaryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for auxiliary_ in self.auxiliary:
            namespaceprefix_ = self.auxiliary_nsprefix_ + ':' if (UseCapturedNS_ and self.auxiliary_nsprefix_) else ''
            auxiliary_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='auxiliary', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AuxiliaryType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.auxtype is not None:
            element.set('auxtype', self.gds_format_string(self.auxtype))
        if self.auxvalue is not None:
            element.set('auxvalue', self.gds_format_string(self.auxvalue))
        if self.auxunit is not None:
            element.set('auxunit', self.gds_format_string(self.auxunit))
        for auxiliary_ in self.auxiliary:
            auxiliary_.to_etree(element, name_='auxiliary', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='AuxiliaryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.auxtype is not None and 'auxtype' not in already_processed:
            already_processed.add('auxtype')
            showIndent(outfile, level)
            outfile.write('auxtype="%s",\n' % (self.auxtype,))
        if self.auxvalue is not None and 'auxvalue' not in already_processed:
            already_processed.add('auxvalue')
            showIndent(outfile, level)
            outfile.write('auxvalue="%s",\n' % (self.auxvalue,))
        if self.auxunit is not None and 'auxunit' not in already_processed:
            already_processed.add('auxunit')
            showIndent(outfile, level)
            outfile.write('auxunit="%s",\n' % (self.auxunit,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('auxiliary=[\n')
        level += 1
        for auxiliary_ in self.auxiliary:
            showIndent(outfile, level)
            outfile.write('model_.AuxiliaryType(\n')
            auxiliary_.exportLiteral(outfile, level, name_='AuxiliaryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('auxtype', node)
        if value is not None and 'auxtype' not in already_processed:
            already_processed.add('auxtype')
            self.auxtype = value
        value = find_attr_value_('auxvalue', node)
        if value is not None and 'auxvalue' not in already_processed:
            already_processed.add('auxvalue')
            self.auxvalue = value
        value = find_attr_value_('auxunit', node)
        if value is not None and 'auxunit' not in already_processed:
            already_processed.add('auxunit')
            self.auxunit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'auxiliary':
            obj_ = AuxiliaryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.auxiliary.append(obj_)
            obj_.original_tagname_ = 'auxiliary'
# end class AuxiliaryType


class defineType(GeneratedsSuper):
    """The global complex type is defined in order to reuse this defintion
    in derived schemas"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, loop=None, constant=None, variable=None, matrix=None, quantity=None, expression=None, position=None, rotation=None, scale=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if loop is None:
            self.loop = []
        else:
            self.loop = loop
        self.loop_nsprefix_ = None
        if constant is None:
            self.constant = []
        else:
            self.constant = constant
        self.constant_nsprefix_ = None
        if variable is None:
            self.variable = []
        else:
            self.variable = variable
        self.variable_nsprefix_ = None
        if matrix is None:
            self.matrix = []
        else:
            self.matrix = matrix
        self.matrix_nsprefix_ = None
        if quantity is None:
            self.quantity = []
        else:
            self.quantity = quantity
        self.quantity_nsprefix_ = None
        if expression is None:
            self.expression = []
        else:
            self.expression = expression
        self.expression_nsprefix_ = None
        if position is None:
            self.position = []
        else:
            self.position = position
        self.position_nsprefix_ = None
        if rotation is None:
            self.rotation = []
        else:
            self.rotation = rotation
        self.rotation_nsprefix_ = None
        if scale is None:
            self.scale = []
        else:
            self.scale = scale
        self.scale_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, defineType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if defineType.subclass:
            return defineType.subclass(*args_, **kwargs_)
        else:
            return defineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_loop(self):
        return self.loop
    def set_loop(self, loop):
        self.loop = loop
    def add_loop(self, value):
        self.loop.append(value)
    def insert_loop_at(self, index, value):
        self.loop.insert(index, value)
    def replace_loop_at(self, index, value):
        self.loop[index] = value
    loopProp = property(get_loop, set_loop)
    def get_constant(self):
        return self.constant
    def set_constant(self, constant):
        self.constant = constant
    def add_constant(self, value):
        self.constant.append(value)
    def insert_constant_at(self, index, value):
        self.constant.insert(index, value)
    def replace_constant_at(self, index, value):
        self.constant[index] = value
    constantProp = property(get_constant, set_constant)
    def get_variable(self):
        return self.variable
    def set_variable(self, variable):
        self.variable = variable
    def add_variable(self, value):
        self.variable.append(value)
    def insert_variable_at(self, index, value):
        self.variable.insert(index, value)
    def replace_variable_at(self, index, value):
        self.variable[index] = value
    variableProp = property(get_variable, set_variable)
    def get_matrix(self):
        return self.matrix
    def set_matrix(self, matrix):
        self.matrix = matrix
    def add_matrix(self, value):
        self.matrix.append(value)
    def insert_matrix_at(self, index, value):
        self.matrix.insert(index, value)
    def replace_matrix_at(self, index, value):
        self.matrix[index] = value
    matrixProp = property(get_matrix, set_matrix)
    def get_quantity(self):
        return self.quantity
    def set_quantity(self, quantity):
        self.quantity = quantity
    def add_quantity(self, value):
        self.quantity.append(value)
    def insert_quantity_at(self, index, value):
        self.quantity.insert(index, value)
    def replace_quantity_at(self, index, value):
        self.quantity[index] = value
    quantityProp = property(get_quantity, set_quantity)
    def get_expression(self):
        return self.expression
    def set_expression(self, expression):
        self.expression = expression
    def add_expression(self, value):
        self.expression.append(value)
    def insert_expression_at(self, index, value):
        self.expression.insert(index, value)
    def replace_expression_at(self, index, value):
        self.expression[index] = value
    expressionProp = property(get_expression, set_expression)
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    def add_position(self, value):
        self.position.append(value)
    def insert_position_at(self, index, value):
        self.position.insert(index, value)
    def replace_position_at(self, index, value):
        self.position[index] = value
    positionProp = property(get_position, set_position)
    def get_rotation(self):
        return self.rotation
    def set_rotation(self, rotation):
        self.rotation = rotation
    def add_rotation(self, value):
        self.rotation.append(value)
    def insert_rotation_at(self, index, value):
        self.rotation.insert(index, value)
    def replace_rotation_at(self, index, value):
        self.rotation[index] = value
    rotationProp = property(get_rotation, set_rotation)
    def get_scale(self):
        return self.scale
    def set_scale(self, scale):
        self.scale = scale
    def add_scale(self, value):
        self.scale.append(value)
    def insert_scale_at(self, index, value):
        self.scale.insert(index, value)
    def replace_scale_at(self, index, value):
        self.scale[index] = value
    scaleProp = property(get_scale, set_scale)
    def hasContent_(self):
        if (
            self.loop or
            self.constant or
            self.variable or
            self.matrix or
            self.quantity or
            self.expression or
            self.position or
            self.rotation or
            self.scale
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='defineType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('defineType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'defineType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='defineType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='defineType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='defineType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='defineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for loop_ in self.loop:
            namespaceprefix_ = self.loop_nsprefix_ + ':' if (UseCapturedNS_ and self.loop_nsprefix_) else ''
            loop_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='loop', pretty_print=pretty_print)
        for constant_ in self.constant:
            namespaceprefix_ = self.constant_nsprefix_ + ':' if (UseCapturedNS_ and self.constant_nsprefix_) else ''
            constant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='constant', pretty_print=pretty_print)
        for variable_ in self.variable:
            namespaceprefix_ = self.variable_nsprefix_ + ':' if (UseCapturedNS_ and self.variable_nsprefix_) else ''
            variable_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variable', pretty_print=pretty_print)
        for matrix_ in self.matrix:
            namespaceprefix_ = self.matrix_nsprefix_ + ':' if (UseCapturedNS_ and self.matrix_nsprefix_) else ''
            matrix_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='matrix', pretty_print=pretty_print)
        for quantity_ in self.quantity:
            namespaceprefix_ = self.quantity_nsprefix_ + ':' if (UseCapturedNS_ and self.quantity_nsprefix_) else ''
            quantity_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='quantity', pretty_print=pretty_print)
        for expression_ in self.expression:
            namespaceprefix_ = self.expression_nsprefix_ + ':' if (UseCapturedNS_ and self.expression_nsprefix_) else ''
            expression_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='expression', pretty_print=pretty_print)
        for position_ in self.position:
            namespaceprefix_ = self.position_nsprefix_ + ':' if (UseCapturedNS_ and self.position_nsprefix_) else ''
            position_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='position', pretty_print=pretty_print)
        for rotation_ in self.rotation:
            namespaceprefix_ = self.rotation_nsprefix_ + ':' if (UseCapturedNS_ and self.rotation_nsprefix_) else ''
            rotation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rotation', pretty_print=pretty_print)
        for scale_ in self.scale:
            namespaceprefix_ = self.scale_nsprefix_ + ':' if (UseCapturedNS_ and self.scale_nsprefix_) else ''
            scale_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scale', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='defineType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        for loop_ in self.loop:
            loop_.to_etree(element, name_='loop', mapping_=mapping_, nsmap_=nsmap_)
        for constant_ in self.constant:
            constant_.to_etree(element, name_='constant', mapping_=mapping_, nsmap_=nsmap_)
        for variable_ in self.variable:
            variable_.to_etree(element, name_='variable', mapping_=mapping_, nsmap_=nsmap_)
        for matrix_ in self.matrix:
            matrix_.to_etree(element, name_='matrix', mapping_=mapping_, nsmap_=nsmap_)
        for quantity_ in self.quantity:
            quantity_.to_etree(element, name_='quantity', mapping_=mapping_, nsmap_=nsmap_)
        for expression_ in self.expression:
            expression_.to_etree(element, name_='expression', mapping_=mapping_, nsmap_=nsmap_)
        for position_ in self.position:
            position_.to_etree(element, name_='position', mapping_=mapping_, nsmap_=nsmap_)
        for rotation_ in self.rotation:
            rotation_.to_etree(element, name_='rotation', mapping_=mapping_, nsmap_=nsmap_)
        for scale_ in self.scale:
            scale_.to_etree(element, name_='scale', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='defineType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('loop=[\n')
        level += 1
        for loop_ in self.loop:
            showIndent(outfile, level)
            outfile.write('model_.loop(\n')
            loop_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('constant=[\n')
        level += 1
        for constant_ in self.constant:
            showIndent(outfile, level)
            outfile.write('model_.IdentifiableConstantType(\n')
            constant_.exportLiteral(outfile, level, name_='IdentifiableConstantType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('variable=[\n')
        level += 1
        for variable_ in self.variable:
            showIndent(outfile, level)
            outfile.write('model_.IdentifiableVariableType(\n')
            variable_.exportLiteral(outfile, level, name_='IdentifiableVariableType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('matrix=[\n')
        level += 1
        for matrix_ in self.matrix:
            showIndent(outfile, level)
            outfile.write('model_.MatrixType(\n')
            matrix_.exportLiteral(outfile, level, name_='MatrixType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('quantity=[\n')
        level += 1
        for quantity_ in self.quantity:
            showIndent(outfile, level)
            outfile.write('model_.IdentifiableQuantityType(\n')
            quantity_.exportLiteral(outfile, level, name_='IdentifiableQuantityType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('expression=[\n')
        level += 1
        for expression_ in self.expression:
            showIndent(outfile, level)
            outfile.write('model_.IdentifiableExpressionType(\n')
            expression_.exportLiteral(outfile, level, name_='IdentifiableExpressionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('position=[\n')
        level += 1
        for position_ in self.position:
            showIndent(outfile, level)
            outfile.write('model_.positionType(\n')
            position_.exportLiteral(outfile, level, name_='positionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('rotation=[\n')
        level += 1
        for rotation_ in self.rotation:
            showIndent(outfile, level)
            outfile.write('model_.rotationType(\n')
            rotation_.exportLiteral(outfile, level, name_='rotationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('scale=[\n')
        level += 1
        for scale_ in self.scale:
            showIndent(outfile, level)
            outfile.write('model_.scaleType(\n')
            scale_.exportLiteral(outfile, level, name_='scaleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'loop':
            obj_ = loop.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.loop.append(obj_)
            obj_.original_tagname_ = 'loop'
        elif nodeName_ == 'constant':
            obj_ = IdentifiableConstantType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.constant.append(obj_)
            obj_.original_tagname_ = 'constant'
        elif nodeName_ == 'variable':
            obj_ = IdentifiableVariableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.variable.append(obj_)
            obj_.original_tagname_ = 'variable'
        elif nodeName_ == 'matrix':
            obj_ = MatrixType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.matrix.append(obj_)
            obj_.original_tagname_ = 'matrix'
        elif nodeName_ == 'quantity':
            obj_ = IdentifiableQuantityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.quantity.append(obj_)
            obj_.original_tagname_ = 'quantity'
        elif nodeName_ == 'expression':
            obj_ = IdentifiableExpressionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.expression.append(obj_)
            obj_.original_tagname_ = 'expression'
        elif nodeName_ == 'position':
            obj_ = positionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.position.append(obj_)
            obj_.original_tagname_ = 'position'
        elif nodeName_ == 'rotation':
            obj_ = rotationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rotation.append(obj_)
            obj_.original_tagname_ = 'rotation'
        elif nodeName_ == 'scale':
            obj_ = scaleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scale.append(obj_)
            obj_.original_tagname_ = 'scale'
# end class defineType


class positionType(IdentifiableQuantityVectorType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiableQuantityVectorType
    def __init__(self, x='0.0', y='0.0', z='0.0', unit=None, type_=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(positionType, self).__init__(x, y, z, unit, type_, name,  **kwargs_)
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, positionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if positionType.subclass:
            return positionType.subclass(*args_, **kwargs_)
        else:
            return positionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            super(positionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='positionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('positionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'positionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='positionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='positionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='positionType'):
        super(positionType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='positionType')
        if self.unit != "mm" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.type_ != "cartesian" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='positionType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='positionType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='positionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(positionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(positionType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(positionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class positionType


class rotationType(IdentifiableQuantityVectorType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiableQuantityVectorType
    def __init__(self, x='0.0', y='0.0', z='0.0', unit=None, type_=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(rotationType, self).__init__(x, y, z, unit, type_, name,  **kwargs_)
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rotationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rotationType.subclass:
            return rotationType.subclass(*args_, **kwargs_)
        else:
            return rotationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            super(rotationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='rotationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rotationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'rotationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rotationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='rotationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='rotationType'):
        super(rotationType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rotationType')
        if self.unit != "radian" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.type_ != "cartesian" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='rotationType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='rotationType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='rotationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(rotationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(rotationType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(rotationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class rotationType


class scaleType(IdentifiableQuantityVectorType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiableQuantityVectorType
    def __init__(self, x='0.0', y='0.0', z='0.0', unit=None, type_=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(scaleType, self).__init__(x, y, z, unit, type_, name,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, scaleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if scaleType.subclass:
            return scaleType.subclass(*args_, **kwargs_)
        else:
            return scaleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (
            super(scaleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='scaleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scaleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'scaleType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scaleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='scaleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='scaleType'):
        super(scaleType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scaleType')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='scaleType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='scaleType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='scaleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(scaleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(scaleType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(scaleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class scaleType


class loop(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, for_=None, from_=None, to=None, step=None, Solid=None, volume=None, physvol=None, loop_member=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.for_ = _cast(None, for_)
        self.for__nsprefix_ = None
        self.from_ = _cast(int, from_)
        self.from__nsprefix_ = None
        self.to = _cast(None, to)
        self.to_nsprefix_ = None
        self.step = _cast(int, step)
        self.step_nsprefix_ = None
        if Solid is None:
            self.Solid = []
        else:
            self.Solid = Solid
        self.Solid_nsprefix_ = None
        if volume is None:
            self.volume = []
        else:
            self.volume = volume
        self.volume_nsprefix_ = None
        if physvol is None:
            self.physvol = []
        else:
            self.physvol = physvol
        self.physvol_nsprefix_ = None
        if loop_member is None:
            self.loop = []
        else:
            self.loop = loop_member
        self.loop_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, loop)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if loop.subclass:
            return loop.subclass(*args_, **kwargs_)
        else:
            return loop(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Solid(self):
        return self.Solid
    def set_Solid(self, Solid):
        self.Solid = Solid
    def add_Solid(self, value):
        self.Solid.append(value)
    def insert_Solid_at(self, index, value):
        self.Solid.insert(index, value)
    def replace_Solid_at(self, index, value):
        self.Solid[index] = value
    SolidProp = property(get_Solid, set_Solid)
    def get_volume(self):
        return self.volume
    def set_volume(self, volume):
        self.volume = volume
    def add_volume(self, value):
        self.volume.append(value)
    def insert_volume_at(self, index, value):
        self.volume.insert(index, value)
    def replace_volume_at(self, index, value):
        self.volume[index] = value
    volumeProp = property(get_volume, set_volume)
    def get_physvol(self):
        return self.physvol
    def set_physvol(self, physvol):
        self.physvol = physvol
    def add_physvol(self, value):
        self.physvol.append(value)
    def insert_physvol_at(self, index, value):
        self.physvol.insert(index, value)
    def replace_physvol_at(self, index, value):
        self.physvol[index] = value
    physvolProp = property(get_physvol, set_physvol)
    def get_loop(self):
        return self.loop
    def set_loop(self, loop):
        self.loop = loop
    def add_loop(self, value):
        self.loop.append(value)
    def insert_loop_at(self, index, value):
        self.loop.insert(index, value)
    def replace_loop_at(self, index, value):
        self.loop[index] = value
    loopProp = property(get_loop, set_loop)
    def get_for(self):
        return self.for_
    def set_for(self, for_):
        self.for_ = for_
    forProp = property(get_for, set_for)
    def get_from(self):
        return self.from_
    def set_from(self, from_):
        self.from_ = from_
    fromProp = property(get_from, set_from)
    def get_to(self):
        return self.to
    def set_to(self, to):
        self.to = to
    toProp = property(get_to, set_to)
    def get_step(self):
        return self.step
    def set_step(self, step):
        self.step = step
    stepProp = property(get_step, set_step)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Solid or
            self.volume or
            self.physvol or
            self.loop
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='loop', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('loop')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'loop':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='loop')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='loop', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='loop'):
        if self.for_ is not None and 'for_' not in already_processed:
            already_processed.add('for_')
            outfile.write(' for=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.for_), input_name='for')), ))
        if self.from_ is not None and 'from_' not in already_processed:
            already_processed.add('from_')
            outfile.write(' from="%s"' % self.gds_format_integer(self.from_, input_name='from'))
        if self.to is not None and 'to' not in already_processed:
            already_processed.add('to')
            outfile.write(' to=%s' % (quote_attrib(self.to), ))
        if self.step is not None and 'step' not in already_processed:
            already_processed.add('step')
            outfile.write(' step="%s"' % self.gds_format_integer(self.step, input_name='step'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='loop', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Solid_ in self.Solid:
            Solid_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        for volume_ in self.volume:
            namespaceprefix_ = self.volume_nsprefix_ + ':' if (UseCapturedNS_ and self.volume_nsprefix_) else ''
            volume_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='volume', pretty_print=pretty_print)
        for physvol_ in self.physvol:
            namespaceprefix_ = self.physvol_nsprefix_ + ':' if (UseCapturedNS_ and self.physvol_nsprefix_) else ''
            physvol_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='physvol', pretty_print=pretty_print)
        for loop_ in self.loop:
            namespaceprefix_ = self.loop_nsprefix_ + ':' if (UseCapturedNS_ and self.loop_nsprefix_) else ''
            loop_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='loop', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='loop', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.for_ is not None:
            element.set('for', self.gds_format_string(self.for_))
        if self.from_ is not None:
            element.set('from', self.gds_format_integer(self.from_))
        if self.to is not None:
            element.set('to', self.to)
        if self.step is not None:
            element.set('step', self.gds_format_integer(self.step))
        for Solid_ in self.Solid:
            Solid_.to_etree(element, name_='Solid', mapping_=mapping_, nsmap_=nsmap_)
        for volume_ in self.volume:
            volume_.to_etree(element, name_='volume', mapping_=mapping_, nsmap_=nsmap_)
        for physvol_ in self.physvol:
            physvol_.to_etree(element, name_='physvol', mapping_=mapping_, nsmap_=nsmap_)
        for loop_ in self.loop:
            loop_.to_etree(element, name_='loop', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='loop'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.for_ is not None and 'for_' not in already_processed:
            already_processed.add('for_')
            showIndent(outfile, level)
            outfile.write('for_="%s",\n' % (self.for_,))
        if self.from_ is not None and 'from_' not in already_processed:
            already_processed.add('from_')
            showIndent(outfile, level)
            outfile.write('from_=%d,\n' % (self.from_,))
        if self.to is not None and 'to' not in already_processed:
            already_processed.add('to')
            showIndent(outfile, level)
            outfile.write('to=%s,\n' % (self.to,))
        if self.step is not None and 'step' not in already_processed:
            already_processed.add('step')
            showIndent(outfile, level)
            outfile.write('step=%d,\n' % (self.step,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Solid=[\n')
        level += 1
        for Solid_ in self.Solid:
            showIndent(outfile, level)
            outfile.write('model_.Solid(\n')
            Solid_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('volume=[\n')
        level += 1
        for volume_ in self.volume:
            showIndent(outfile, level)
            outfile.write('model_.VolumeType(\n')
            volume_.exportLiteral(outfile, level, name_='VolumeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('physvol=[\n')
        level += 1
        for physvol_ in self.physvol:
            showIndent(outfile, level)
            outfile.write('model_.SinglePlacementType(\n')
            physvol_.exportLiteral(outfile, level, name_='SinglePlacementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('loop=[\n')
        level += 1
        for loop_ in self.loop:
            showIndent(outfile, level)
            outfile.write('model_.loop(\n')
            loop_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('for', node)
        if value is not None and 'for' not in already_processed:
            already_processed.add('for')
            self.for_ = value
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.add('from')
            self.from_ = self.gds_parse_integer(value, node, 'from')
            if self.from_ < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.add('to')
            self.to = value
            self.validate_ExpressionOrIDREFType(self.to)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('step', node)
        if value is not None and 'step' not in already_processed:
            already_processed.add('step')
            self.step = self.gds_parse_integer(value, node, 'step')
            if self.step <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Solid':
            class_obj_ = self.get_class_obj_(child_, SolidType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'Solid'
        elif nodeName_ == 'multiUnion':
            obj_ = multiUnion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'multiUnion'
        elif nodeName_ == 'reflectedSolid':
            obj_ = reflectedSolid.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'reflectedSolid'
        elif nodeName_ == 'scaledSolid':
            obj_ = scaledSolid.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'scaledSolid'
        elif nodeName_ == 'union':
            obj_ = BooleanSolidType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'union'
        elif nodeName_ == 'subtraction':
            obj_ = BooleanSolidType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'subtraction'
        elif nodeName_ == 'intersection':
            obj_ = BooleanSolidType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'intersection'
        elif nodeName_ == 'box':
            obj_ = box.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'box'
        elif nodeName_ == 'twistedbox':
            obj_ = twistedbox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'twistedbox'
        elif nodeName_ == 'twistedtrap':
            obj_ = twistedtrap.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'twistedtrap'
        elif nodeName_ == 'twistedtrd':
            obj_ = twistedtrd.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'twistedtrd'
        elif nodeName_ == 'paraboloid':
            obj_ = paraboloid.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'paraboloid'
        elif nodeName_ == 'sphere':
            obj_ = sphere.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'sphere'
        elif nodeName_ == 'ellipsoid':
            obj_ = ellipsoid.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'ellipsoid'
        elif nodeName_ == 'tube':
            obj_ = tube.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'tube'
        elif nodeName_ == 'twistedtubs':
            obj_ = twistedtubs.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'twistedtubs'
        elif nodeName_ == 'cutTube':
            obj_ = cutTube.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'cutTube'
        elif nodeName_ == 'cone':
            obj_ = cone.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'cone'
        elif nodeName_ == 'elcone':
            obj_ = elcone.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'elcone'
        elif nodeName_ == 'polycone':
            obj_ = polycone.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'polycone'
        elif nodeName_ == 'genericPolycone':
            obj_ = genericPolycone.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'genericPolycone'
        elif nodeName_ == 'para':
            obj_ = para.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'para'
        elif nodeName_ == 'trd':
            obj_ = trd.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'trd'
        elif nodeName_ == 'trap':
            obj_ = trap.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'trap'
        elif nodeName_ == 'torus':
            obj_ = torus.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'torus'
        elif nodeName_ == 'orb':
            obj_ = orb.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'orb'
        elif nodeName_ == 'polyhedra':
            obj_ = polyhedra.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'polyhedra'
        elif nodeName_ == 'genericPolyhedra':
            obj_ = genericPolyhedra.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'genericPolyhedra'
        elif nodeName_ == 'xtru':
            obj_ = xtru.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'xtru'
        elif nodeName_ == 'hype':
            obj_ = hype.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'hype'
        elif nodeName_ == 'eltube':
            obj_ = eltube.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'eltube'
        elif nodeName_ == 'tet':
            obj_ = tet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'tet'
        elif nodeName_ == 'arb8':
            obj_ = arb8.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'arb8'
        elif nodeName_ == 'tessellated':
            obj_ = tessellated.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'tessellated'
        elif nodeName_ == 'volume':
            obj_ = VolumeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.volume.append(obj_)
            obj_.original_tagname_ = 'volume'
        elif nodeName_ == 'physvol':
            obj_ = SinglePlacementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.physvol.append(obj_)
            obj_.original_tagname_ = 'physvol'
        elif nodeName_ == 'loop':
            obj_ = loop.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.loop.append(obj_)
            obj_.original_tagname_ = 'loop'
# end class loop


class AtomType(QuantityType):
    """Atomic mass, quantity type A, default unit g/mole"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuantityType
    def __init__(self, value=None, unit=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AtomType, self).__init__(value, unit, type_,  **kwargs_)
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AtomType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AtomType.subclass:
            return AtomType.subclass(*args_, **kwargs_)
        else:
            return AtomType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            super(AtomType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AtomType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AtomType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AtomType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AtomType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AtomType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AtomType'):
        super(AtomType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AtomType')
        if self.unit != "g/mole" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.type_ != "A" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AtomType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='AtomType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='AtomType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(AtomType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AtomType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(AtomType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AtomType


class DensityType(QuantityType):
    """Density"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuantityType
    def __init__(self, value=None, unit=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(DensityType, self).__init__(value, unit, type_,  **kwargs_)
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DensityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DensityType.subclass:
            return DensityType.subclass(*args_, **kwargs_)
        else:
            return DensityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            super(DensityType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DensityType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DensityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DensityType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DensityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DensityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DensityType'):
        super(DensityType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DensityType')
        if self.unit != "g/cm3" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.type_ != "density" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DensityType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='DensityType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DensityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(DensityType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DensityType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(DensityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DensityType


class MaterialType(GeneratedsSuper):
    """Base type for materials"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, formula=None, state='unknown', property=None, RL=None, RLref=None, AL=None, ALref=None, T=None, Tref=None, P=None, Pref=None, MEE=None, MEEref=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.formula = _cast(None, formula)
        self.formula_nsprefix_ = None
        self.state = _cast(None, state)
        self.state_nsprefix_ = None
        if property is None:
            self.property = []
        else:
            self.property = property
        self.property_nsprefix_ = None
        self.RL = RL
        self.RL_nsprefix_ = None
        self.RLref = RLref
        self.RLref_nsprefix_ = None
        self.AL = AL
        self.AL_nsprefix_ = None
        self.ALref = ALref
        self.ALref_nsprefix_ = None
        self.T = T
        self.T_nsprefix_ = None
        self.Tref = Tref
        self.Tref_nsprefix_ = None
        self.P = P
        self.P_nsprefix_ = None
        self.Pref = Pref
        self.Pref_nsprefix_ = None
        self.MEE = MEE
        self.MEE_nsprefix_ = None
        self.MEEref = MEEref
        self.MEEref_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MaterialType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MaterialType.subclass:
            return MaterialType.subclass(*args_, **kwargs_)
        else:
            return MaterialType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_property(self):
        return self.property
    def set_property(self, property):
        self.property = property
    def add_property(self, value):
        self.property.append(value)
    def insert_property_at(self, index, value):
        self.property.insert(index, value)
    def replace_property_at(self, index, value):
        self.property[index] = value
    propertyProp = property(get_property, set_property)
    def get_RL(self):
        return self.RL
    def set_RL(self, RL):
        self.RL = RL
    RLProp = property(get_RL, set_RL)
    def get_RLref(self):
        return self.RLref
    def set_RLref(self, RLref):
        self.RLref = RLref
    RLrefProp = property(get_RLref, set_RLref)
    def get_AL(self):
        return self.AL
    def set_AL(self, AL):
        self.AL = AL
    ALProp = property(get_AL, set_AL)
    def get_ALref(self):
        return self.ALref
    def set_ALref(self, ALref):
        self.ALref = ALref
    ALrefProp = property(get_ALref, set_ALref)
    def get_T(self):
        return self.T
    def set_T(self, T):
        self.T = T
    TProp = property(get_T, set_T)
    def get_Tref(self):
        return self.Tref
    def set_Tref(self, Tref):
        self.Tref = Tref
    TrefProp = property(get_Tref, set_Tref)
    def get_P(self):
        return self.P
    def set_P(self, P):
        self.P = P
    PProp = property(get_P, set_P)
    def get_Pref(self):
        return self.Pref
    def set_Pref(self, Pref):
        self.Pref = Pref
    PrefProp = property(get_Pref, set_Pref)
    def get_MEE(self):
        return self.MEE
    def set_MEE(self, MEE):
        self.MEE = MEE
    MEEProp = property(get_MEE, set_MEE)
    def get_MEEref(self):
        return self.MEEref
    def set_MEEref(self, MEEref):
        self.MEEref = MEEref
    MEErefProp = property(get_MEEref, set_MEEref)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_formula(self):
        return self.formula
    def set_formula(self, formula):
        self.formula = formula
    formulaProp = property(get_formula, set_formula)
    def get_state(self):
        return self.state
    def set_state(self, state):
        self.state = state
    stateProp = property(get_state, set_state)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_stateType(self, value):
        # Validate type stateType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['gas', 'liquid', 'solid', 'unknown']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on stateType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.property or
            self.RL is not None or
            self.RLref is not None or
            self.AL is not None or
            self.ALref is not None or
            self.T is not None or
            self.Tref is not None or
            self.P is not None or
            self.Pref is not None or
            self.MEE is not None or
            self.MEEref is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MaterialType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MaterialType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MaterialType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MaterialType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MaterialType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MaterialType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.formula is not None and 'formula' not in already_processed:
            already_processed.add('formula')
            outfile.write(' formula=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.formula), input_name='formula')), ))
        if self.state != "unknown" and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.state), input_name='state')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MaterialType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for property_ in self.property:
            namespaceprefix_ = self.property_nsprefix_ + ':' if (UseCapturedNS_ and self.property_nsprefix_) else ''
            property_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='property', pretty_print=pretty_print)
        if self.RL is not None:
            namespaceprefix_ = self.RL_nsprefix_ + ':' if (UseCapturedNS_ and self.RL_nsprefix_) else ''
            self.RL.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RL', pretty_print=pretty_print)
        if self.RLref is not None:
            namespaceprefix_ = self.RLref_nsprefix_ + ':' if (UseCapturedNS_ and self.RLref_nsprefix_) else ''
            self.RLref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RLref', pretty_print=pretty_print)
        if self.AL is not None:
            namespaceprefix_ = self.AL_nsprefix_ + ':' if (UseCapturedNS_ and self.AL_nsprefix_) else ''
            self.AL.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AL', pretty_print=pretty_print)
        if self.ALref is not None:
            namespaceprefix_ = self.ALref_nsprefix_ + ':' if (UseCapturedNS_ and self.ALref_nsprefix_) else ''
            self.ALref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ALref', pretty_print=pretty_print)
        if self.T is not None:
            namespaceprefix_ = self.T_nsprefix_ + ':' if (UseCapturedNS_ and self.T_nsprefix_) else ''
            self.T.export(outfile, level, namespaceprefix_, namespacedef_='', name_='T', pretty_print=pretty_print)
        if self.Tref is not None:
            namespaceprefix_ = self.Tref_nsprefix_ + ':' if (UseCapturedNS_ and self.Tref_nsprefix_) else ''
            self.Tref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Tref', pretty_print=pretty_print)
        if self.P is not None:
            namespaceprefix_ = self.P_nsprefix_ + ':' if (UseCapturedNS_ and self.P_nsprefix_) else ''
            self.P.export(outfile, level, namespaceprefix_, namespacedef_='', name_='P', pretty_print=pretty_print)
        if self.Pref is not None:
            namespaceprefix_ = self.Pref_nsprefix_ + ':' if (UseCapturedNS_ and self.Pref_nsprefix_) else ''
            self.Pref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Pref', pretty_print=pretty_print)
        if self.MEE is not None:
            namespaceprefix_ = self.MEE_nsprefix_ + ':' if (UseCapturedNS_ and self.MEE_nsprefix_) else ''
            self.MEE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MEE', pretty_print=pretty_print)
        if self.MEEref is not None:
            namespaceprefix_ = self.MEEref_nsprefix_ + ':' if (UseCapturedNS_ and self.MEEref_nsprefix_) else ''
            self.MEEref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MEEref', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MaterialType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.formula is not None:
            element.set('formula', self.gds_format_string(self.formula))
        if self.state is not None:
            element.set('state', self.gds_format_string(self.state))
        for property_ in self.property:
            property_.to_etree(element, name_='property', mapping_=mapping_, nsmap_=nsmap_)
        if self.RL is not None:
            RL_ = self.RL
            RL_.to_etree(element, name_='RL', mapping_=mapping_, nsmap_=nsmap_)
        if self.RLref is not None:
            RLref_ = self.RLref
            RLref_.to_etree(element, name_='RLref', mapping_=mapping_, nsmap_=nsmap_)
        if self.AL is not None:
            AL_ = self.AL
            AL_.to_etree(element, name_='AL', mapping_=mapping_, nsmap_=nsmap_)
        if self.ALref is not None:
            ALref_ = self.ALref
            ALref_.to_etree(element, name_='ALref', mapping_=mapping_, nsmap_=nsmap_)
        if self.T is not None:
            T_ = self.T
            T_.to_etree(element, name_='T', mapping_=mapping_, nsmap_=nsmap_)
        if self.Tref is not None:
            Tref_ = self.Tref
            Tref_.to_etree(element, name_='Tref', mapping_=mapping_, nsmap_=nsmap_)
        if self.P is not None:
            P_ = self.P
            P_.to_etree(element, name_='P', mapping_=mapping_, nsmap_=nsmap_)
        if self.Pref is not None:
            Pref_ = self.Pref
            Pref_.to_etree(element, name_='Pref', mapping_=mapping_, nsmap_=nsmap_)
        if self.MEE is not None:
            MEE_ = self.MEE
            MEE_.to_etree(element, name_='MEE', mapping_=mapping_, nsmap_=nsmap_)
        if self.MEEref is not None:
            MEEref_ = self.MEEref
            MEEref_.to_etree(element, name_='MEEref', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='MaterialType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.formula is not None and 'formula' not in already_processed:
            already_processed.add('formula')
            showIndent(outfile, level)
            outfile.write('formula="%s",\n' % (self.formula,))
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            showIndent(outfile, level)
            outfile.write('state="%s",\n' % (self.state,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('property=[\n')
        level += 1
        for property_ in self.property:
            showIndent(outfile, level)
            outfile.write('model_.propertyType1(\n')
            property_.exportLiteral(outfile, level, name_='propertyType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.RL is not None:
            showIndent(outfile, level)
            outfile.write('RL=model_.RLType2(\n')
            self.RL.exportLiteral(outfile, level, name_='RL')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RLref is not None:
            showIndent(outfile, level)
            outfile.write('RLref=model_.ReferenceType(\n')
            self.RLref.exportLiteral(outfile, level, name_='RLref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AL is not None:
            showIndent(outfile, level)
            outfile.write('AL=model_.ALType3(\n')
            self.AL.exportLiteral(outfile, level, name_='AL')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ALref is not None:
            showIndent(outfile, level)
            outfile.write('ALref=model_.ReferenceType(\n')
            self.ALref.exportLiteral(outfile, level, name_='ALref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.T is not None:
            showIndent(outfile, level)
            outfile.write('T=model_.TType4(\n')
            self.T.exportLiteral(outfile, level, name_='T')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Tref is not None:
            showIndent(outfile, level)
            outfile.write('Tref=model_.ReferenceType(\n')
            self.Tref.exportLiteral(outfile, level, name_='Tref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.P is not None:
            showIndent(outfile, level)
            outfile.write('P=model_.PType5(\n')
            self.P.exportLiteral(outfile, level, name_='P')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Pref is not None:
            showIndent(outfile, level)
            outfile.write('Pref=model_.ReferenceType(\n')
            self.Pref.exportLiteral(outfile, level, name_='Pref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MEE is not None:
            showIndent(outfile, level)
            outfile.write('MEE=model_.MEEType6(\n')
            self.MEE.exportLiteral(outfile, level, name_='MEE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MEEref is not None:
            showIndent(outfile, level)
            outfile.write('MEEref=model_.ReferenceType(\n')
            self.MEEref.exportLiteral(outfile, level, name_='MEEref')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('formula', node)
        if value is not None and 'formula' not in already_processed:
            already_processed.add('formula')
            self.formula = value
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            self.state = value
            self.validate_stateType(self.state)    # validate type stateType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'property':
            obj_ = propertyType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.property.append(obj_)
            obj_.original_tagname_ = 'property'
        elif nodeName_ == 'RL':
            obj_ = RLType2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RL = obj_
            obj_.original_tagname_ = 'RL'
        elif nodeName_ == 'RLref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RLref = obj_
            obj_.original_tagname_ = 'RLref'
        elif nodeName_ == 'AL':
            obj_ = ALType3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AL = obj_
            obj_.original_tagname_ = 'AL'
        elif nodeName_ == 'ALref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ALref = obj_
            obj_.original_tagname_ = 'ALref'
        elif nodeName_ == 'T':
            obj_ = TType4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.T = obj_
            obj_.original_tagname_ = 'T'
        elif nodeName_ == 'Tref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Tref = obj_
            obj_.original_tagname_ = 'Tref'
        elif nodeName_ == 'P':
            obj_ = PType5.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.P = obj_
            obj_.original_tagname_ = 'P'
        elif nodeName_ == 'Pref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Pref = obj_
            obj_.original_tagname_ = 'Pref'
        elif nodeName_ == 'MEE':
            obj_ = MEEType6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MEE = obj_
            obj_.original_tagname_ = 'MEE'
        elif nodeName_ == 'MEEref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MEEref = obj_
            obj_.original_tagname_ = 'MEEref'
# end class MaterialType


class materials(GeneratedsSuper):
    """Materials description"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, loop=None, define=None, isotope=None, element=None, material=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if loop is None:
            self.loop = []
        else:
            self.loop = loop
        self.loop_nsprefix_ = None
        if define is None:
            self.define = []
        else:
            self.define = define
        self.define_nsprefix_ = None
        if isotope is None:
            self.isotope = []
        else:
            self.isotope = isotope
        self.isotope_nsprefix_ = None
        if element is None:
            self.element = []
        else:
            self.element = element
        self.element_nsprefix_ = None
        if material is None:
            self.material = []
        else:
            self.material = material
        self.material_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, materials)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if materials.subclass:
            return materials.subclass(*args_, **kwargs_)
        else:
            return materials(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_loop(self):
        return self.loop
    def set_loop(self, loop):
        self.loop = loop
    def add_loop(self, value):
        self.loop.append(value)
    def insert_loop_at(self, index, value):
        self.loop.insert(index, value)
    def replace_loop_at(self, index, value):
        self.loop[index] = value
    loopProp = property(get_loop, set_loop)
    def get_define(self):
        return self.define
    def set_define(self, define):
        self.define = define
    def add_define(self, value):
        self.define.append(value)
    def insert_define_at(self, index, value):
        self.define.insert(index, value)
    def replace_define_at(self, index, value):
        self.define[index] = value
    defineProp = property(get_define, set_define)
    def get_isotope(self):
        return self.isotope
    def set_isotope(self, isotope):
        self.isotope = isotope
    def add_isotope(self, value):
        self.isotope.append(value)
    def insert_isotope_at(self, index, value):
        self.isotope.insert(index, value)
    def replace_isotope_at(self, index, value):
        self.isotope[index] = value
    isotopeProp = property(get_isotope, set_isotope)
    def get_element(self):
        return self.element
    def set_element(self, element):
        self.element = element
    def add_element(self, value):
        self.element.append(value)
    def insert_element_at(self, index, value):
        self.element.insert(index, value)
    def replace_element_at(self, index, value):
        self.element[index] = value
    elementProp = property(get_element, set_element)
    def get_material(self):
        return self.material
    def set_material(self, material):
        self.material = material
    def add_material(self, value):
        self.material.append(value)
    def insert_material_at(self, index, value):
        self.material.insert(index, value)
    def replace_material_at(self, index, value):
        self.material[index] = value
    materialProp = property(get_material, set_material)
    def hasContent_(self):
        if (
            self.loop or
            self.define or
            self.isotope or
            self.element or
            self.material
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='materials', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('materials')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'materials':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='materials')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='materials', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='materials'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='materials', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for loop_ in self.loop:
            namespaceprefix_ = self.loop_nsprefix_ + ':' if (UseCapturedNS_ and self.loop_nsprefix_) else ''
            loop_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='loop', pretty_print=pretty_print)
        for define_ in self.define:
            namespaceprefix_ = self.define_nsprefix_ + ':' if (UseCapturedNS_ and self.define_nsprefix_) else ''
            define_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='define', pretty_print=pretty_print)
        for isotope_ in self.isotope:
            namespaceprefix_ = self.isotope_nsprefix_ + ':' if (UseCapturedNS_ and self.isotope_nsprefix_) else ''
            isotope_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='isotope', pretty_print=pretty_print)
        for element_ in self.element:
            namespaceprefix_ = self.element_nsprefix_ + ':' if (UseCapturedNS_ and self.element_nsprefix_) else ''
            element_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='element', pretty_print=pretty_print)
        for material_ in self.material:
            namespaceprefix_ = self.material_nsprefix_ + ':' if (UseCapturedNS_ and self.material_nsprefix_) else ''
            material_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='material', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='materials', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        for loop_ in self.loop:
            loop_.to_etree(element, name_='loop', mapping_=mapping_, nsmap_=nsmap_)
        for define_ in self.define:
            define_.to_etree(element, name_='define', mapping_=mapping_, nsmap_=nsmap_)
        for isotope_ in self.isotope:
            isotope_.to_etree(element, name_='isotope', mapping_=mapping_, nsmap_=nsmap_)
        for element_ in self.element:
            element_.to_etree(element, name_='element', mapping_=mapping_, nsmap_=nsmap_)
        for material_ in self.material:
            material_.to_etree(element, name_='material', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='materials'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('loop=[\n')
        level += 1
        for loop_ in self.loop:
            showIndent(outfile, level)
            outfile.write('model_.loop(\n')
            loop_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('define=[\n')
        level += 1
        for define_ in self.define:
            showIndent(outfile, level)
            outfile.write('model_.defineType(\n')
            define_.exportLiteral(outfile, level, name_='defineType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('isotope=[\n')
        level += 1
        for isotope_ in self.isotope:
            showIndent(outfile, level)
            outfile.write('model_.MaterialIsotopeType(\n')
            isotope_.exportLiteral(outfile, level, name_='MaterialIsotopeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('element=[\n')
        level += 1
        for element_ in self.element:
            showIndent(outfile, level)
            outfile.write('model_.MaterialElementType(\n')
            element_.exportLiteral(outfile, level, name_='MaterialElementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('material=[\n')
        level += 1
        for material_ in self.material:
            showIndent(outfile, level)
            outfile.write('model_.MaterialMixtureType(\n')
            material_.exportLiteral(outfile, level, name_='MaterialMixtureType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'loop':
            obj_ = loop.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.loop.append(obj_)
            obj_.original_tagname_ = 'loop'
        elif nodeName_ == 'define':
            obj_ = defineType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.define.append(obj_)
            obj_.original_tagname_ = 'define'
        elif nodeName_ == 'isotope':
            obj_ = MaterialIsotopeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isotope.append(obj_)
            obj_.original_tagname_ = 'isotope'
        elif nodeName_ == 'element':
            obj_ = MaterialElementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.element.append(obj_)
            obj_.original_tagname_ = 'element'
        elif nodeName_ == 'material':
            obj_ = MaterialMixtureType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.material.append(obj_)
            obj_.original_tagname_ = 'material'
# end class materials


class MaterialIsotopeType(MaterialType):
    """Exported isotope typeNumber of nucleonsAtomic number"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MaterialType
    def __init__(self, name=None, formula=None, state='unknown', property=None, RL=None, RLref=None, AL=None, ALref=None, T=None, Tref=None, P=None, Pref=None, MEE=None, MEEref=None, N=None, Z=None, D=None, Dref=None, atom=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(MaterialIsotopeType, self).__init__(name, formula, state, property, RL, RLref, AL, ALref, T, Tref, P, Pref, MEE, MEEref,  **kwargs_)
        self.N = _cast(int, N)
        self.N_nsprefix_ = None
        self.Z = _cast(float, Z)
        self.Z_nsprefix_ = None
        self.D = D
        self.D_nsprefix_ = None
        self.Dref = Dref
        self.Dref_nsprefix_ = None
        self.atom = atom
        self.atom_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MaterialIsotopeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MaterialIsotopeType.subclass:
            return MaterialIsotopeType.subclass(*args_, **kwargs_)
        else:
            return MaterialIsotopeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_D(self):
        return self.D
    def set_D(self, D):
        self.D = D
    DProp = property(get_D, set_D)
    def get_Dref(self):
        return self.Dref
    def set_Dref(self, Dref):
        self.Dref = Dref
    DrefProp = property(get_Dref, set_Dref)
    def get_atom(self):
        return self.atom
    def set_atom(self, atom):
        self.atom = atom
    atomProp = property(get_atom, set_atom)
    def get_N(self):
        return self.N
    def set_N(self, N):
        self.N = N
    NProp = property(get_N, set_N)
    def get_Z(self):
        return self.Z
    def set_Z(self, Z):
        self.Z = Z
    ZProp = property(get_Z, set_Z)
    def hasContent_(self):
        if (
            self.D is not None or
            self.Dref is not None or
            self.atom is not None or
            super(MaterialIsotopeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MaterialIsotopeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MaterialIsotopeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MaterialIsotopeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MaterialIsotopeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MaterialIsotopeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MaterialIsotopeType'):
        super(MaterialIsotopeType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MaterialIsotopeType')
        if self.N is not None and 'N' not in already_processed:
            already_processed.add('N')
            outfile.write(' N="%s"' % self.gds_format_integer(self.N, input_name='N'))
        if self.Z is not None and 'Z' not in already_processed:
            already_processed.add('Z')
            outfile.write(' Z="%s"' % self.gds_format_double(self.Z, input_name='Z'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MaterialIsotopeType', fromsubclass_=False, pretty_print=True):
        super(MaterialIsotopeType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.D is not None:
            namespaceprefix_ = self.D_nsprefix_ + ':' if (UseCapturedNS_ and self.D_nsprefix_) else ''
            self.D.export(outfile, level, namespaceprefix_, namespacedef_='', name_='D', pretty_print=pretty_print)
        if self.Dref is not None:
            namespaceprefix_ = self.Dref_nsprefix_ + ':' if (UseCapturedNS_ and self.Dref_nsprefix_) else ''
            self.Dref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Dref', pretty_print=pretty_print)
        if self.atom is not None:
            namespaceprefix_ = self.atom_nsprefix_ + ':' if (UseCapturedNS_ and self.atom_nsprefix_) else ''
            self.atom.export(outfile, level, namespaceprefix_, namespacedef_='', name_='atom', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MaterialIsotopeType', mapping_=None, nsmap_=None):
        element = super(MaterialIsotopeType, self).to_etree(parent_element, name_, mapping_)
        if self.N is not None:
            element.set('N', self.gds_format_integer(self.N))
        if self.Z is not None:
            element.set('Z', self.gds_format_double(self.Z))
        if self.D is not None:
            D_ = self.D
            D_.to_etree(element, name_='D', mapping_=mapping_, nsmap_=nsmap_)
        if self.Dref is not None:
            Dref_ = self.Dref
            Dref_.to_etree(element, name_='Dref', mapping_=mapping_, nsmap_=nsmap_)
        if self.atom is not None:
            atom_ = self.atom
            atom_.to_etree(element, name_='atom', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='MaterialIsotopeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.N is not None and 'N' not in already_processed:
            already_processed.add('N')
            showIndent(outfile, level)
            outfile.write('N=%d,\n' % (self.N,))
        if self.Z is not None and 'Z' not in already_processed:
            already_processed.add('Z')
            showIndent(outfile, level)
            outfile.write('Z=%e,\n' % (self.Z,))
        super(MaterialIsotopeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MaterialIsotopeType, self).exportLiteralChildren(outfile, level, name_)
        if self.D is not None:
            showIndent(outfile, level)
            outfile.write('D=model_.DensityType(\n')
            self.D.exportLiteral(outfile, level, name_='D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Dref is not None:
            showIndent(outfile, level)
            outfile.write('Dref=model_.ReferenceType(\n')
            self.Dref.exportLiteral(outfile, level, name_='Dref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.atom is not None:
            showIndent(outfile, level)
            outfile.write('atom=model_.AtomType(\n')
            self.atom.exportLiteral(outfile, level, name_='atom')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('N', node)
        if value is not None and 'N' not in already_processed:
            already_processed.add('N')
            self.N = self.gds_parse_integer(value, node, 'N')
            if self.N <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('Z', node)
        if value is not None and 'Z' not in already_processed:
            already_processed.add('Z')
            value = self.gds_parse_double(value, node, 'Z')
            self.Z = value
        super(MaterialIsotopeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'D':
            obj_ = DensityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.D = obj_
            obj_.original_tagname_ = 'D'
        elif nodeName_ == 'Dref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dref = obj_
            obj_.original_tagname_ = 'Dref'
        elif nodeName_ == 'atom':
            obj_ = AtomType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.atom = obj_
            obj_.original_tagname_ = 'atom'
        super(MaterialIsotopeType, self).buildChildren(child_, node, nodeName_, True)
# end class MaterialIsotopeType


class MaterialElementType(MaterialType):
    """Exported material element typeAn element can be defined either as a
    simple element or by a set
    of isotopes fractionsNumber of nucleonsAtomic number"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MaterialType
    def __init__(self, name=None, formula=None, state='unknown', property=None, RL=None, RLref=None, AL=None, ALref=None, T=None, Tref=None, P=None, Pref=None, MEE=None, MEEref=None, N=None, Z=None, D=None, Dref=None, atom=None, fraction=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(MaterialElementType, self).__init__(name, formula, state, property, RL, RLref, AL, ALref, T, Tref, P, Pref, MEE, MEEref,  **kwargs_)
        self.N = _cast(int, N)
        self.N_nsprefix_ = None
        self.Z = _cast(float, Z)
        self.Z_nsprefix_ = None
        self.D = D
        self.D_nsprefix_ = None
        self.Dref = Dref
        self.Dref_nsprefix_ = None
        self.atom = atom
        self.atom_nsprefix_ = None
        if fraction is None:
            self.fraction = []
        else:
            self.fraction = fraction
        self.fraction_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MaterialElementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MaterialElementType.subclass:
            return MaterialElementType.subclass(*args_, **kwargs_)
        else:
            return MaterialElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_D(self):
        return self.D
    def set_D(self, D):
        self.D = D
    DProp = property(get_D, set_D)
    def get_Dref(self):
        return self.Dref
    def set_Dref(self, Dref):
        self.Dref = Dref
    DrefProp = property(get_Dref, set_Dref)
    def get_atom(self):
        return self.atom
    def set_atom(self, atom):
        self.atom = atom
    atomProp = property(get_atom, set_atom)
    def get_fraction(self):
        return self.fraction
    def set_fraction(self, fraction):
        self.fraction = fraction
    def add_fraction(self, value):
        self.fraction.append(value)
    def insert_fraction_at(self, index, value):
        self.fraction.insert(index, value)
    def replace_fraction_at(self, index, value):
        self.fraction[index] = value
    fractionProp = property(get_fraction, set_fraction)
    def get_N(self):
        return self.N
    def set_N(self, N):
        self.N = N
    NProp = property(get_N, set_N)
    def get_Z(self):
        return self.Z
    def set_Z(self, Z):
        self.Z = Z
    ZProp = property(get_Z, set_Z)
    def hasContent_(self):
        if (
            self.D is not None or
            self.Dref is not None or
            self.atom is not None or
            self.fraction or
            super(MaterialElementType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MaterialElementType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MaterialElementType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MaterialElementType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MaterialElementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MaterialElementType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MaterialElementType'):
        super(MaterialElementType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MaterialElementType')
        if self.N is not None and 'N' not in already_processed:
            already_processed.add('N')
            outfile.write(' N="%s"' % self.gds_format_integer(self.N, input_name='N'))
        if self.Z is not None and 'Z' not in already_processed:
            already_processed.add('Z')
            outfile.write(' Z="%s"' % self.gds_format_double(self.Z, input_name='Z'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MaterialElementType', fromsubclass_=False, pretty_print=True):
        super(MaterialElementType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.D is not None:
            namespaceprefix_ = self.D_nsprefix_ + ':' if (UseCapturedNS_ and self.D_nsprefix_) else ''
            self.D.export(outfile, level, namespaceprefix_, namespacedef_='', name_='D', pretty_print=pretty_print)
        if self.Dref is not None:
            namespaceprefix_ = self.Dref_nsprefix_ + ':' if (UseCapturedNS_ and self.Dref_nsprefix_) else ''
            self.Dref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Dref', pretty_print=pretty_print)
        if self.atom is not None:
            namespaceprefix_ = self.atom_nsprefix_ + ':' if (UseCapturedNS_ and self.atom_nsprefix_) else ''
            self.atom.export(outfile, level, namespaceprefix_, namespacedef_='', name_='atom', pretty_print=pretty_print)
        for fraction_ in self.fraction:
            namespaceprefix_ = self.fraction_nsprefix_ + ':' if (UseCapturedNS_ and self.fraction_nsprefix_) else ''
            fraction_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fraction', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MaterialElementType', mapping_=None, nsmap_=None):
        element = super(MaterialElementType, self).to_etree(parent_element, name_, mapping_)
        if self.N is not None:
            element.set('N', self.gds_format_integer(self.N))
        if self.Z is not None:
            element.set('Z', self.gds_format_double(self.Z))
        if self.D is not None:
            D_ = self.D
            D_.to_etree(element, name_='D', mapping_=mapping_, nsmap_=nsmap_)
        if self.Dref is not None:
            Dref_ = self.Dref
            Dref_.to_etree(element, name_='Dref', mapping_=mapping_, nsmap_=nsmap_)
        if self.atom is not None:
            atom_ = self.atom
            atom_.to_etree(element, name_='atom', mapping_=mapping_, nsmap_=nsmap_)
        for fraction_ in self.fraction:
            fraction_.to_etree(element, name_='fraction', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='MaterialElementType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.N is not None and 'N' not in already_processed:
            already_processed.add('N')
            showIndent(outfile, level)
            outfile.write('N=%d,\n' % (self.N,))
        if self.Z is not None and 'Z' not in already_processed:
            already_processed.add('Z')
            showIndent(outfile, level)
            outfile.write('Z=%e,\n' % (self.Z,))
        super(MaterialElementType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MaterialElementType, self).exportLiteralChildren(outfile, level, name_)
        if self.D is not None:
            showIndent(outfile, level)
            outfile.write('D=model_.DensityType(\n')
            self.D.exportLiteral(outfile, level, name_='D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Dref is not None:
            showIndent(outfile, level)
            outfile.write('Dref=model_.ReferenceType(\n')
            self.Dref.exportLiteral(outfile, level, name_='Dref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.atom is not None:
            showIndent(outfile, level)
            outfile.write('atom=model_.AtomType(\n')
            self.atom.exportLiteral(outfile, level, name_='atom')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('fraction=[\n')
        level += 1
        for fraction_ in self.fraction:
            showIndent(outfile, level)
            outfile.write('model_.fractionType(\n')
            fraction_.exportLiteral(outfile, level, name_='fractionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('N', node)
        if value is not None and 'N' not in already_processed:
            already_processed.add('N')
            self.N = self.gds_parse_integer(value, node, 'N')
            if self.N <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('Z', node)
        if value is not None and 'Z' not in already_processed:
            already_processed.add('Z')
            value = self.gds_parse_double(value, node, 'Z')
            self.Z = value
        super(MaterialElementType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'D':
            obj_ = DensityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.D = obj_
            obj_.original_tagname_ = 'D'
        elif nodeName_ == 'Dref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dref = obj_
            obj_.original_tagname_ = 'Dref'
        elif nodeName_ == 'atom':
            obj_ = AtomType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.atom = obj_
            obj_.original_tagname_ = 'atom'
        elif nodeName_ == 'fraction':
            obj_ = fractionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fraction.append(obj_)
            obj_.original_tagname_ = 'fraction'
        super(MaterialElementType, self).buildChildren(child_, node, nodeName_, True)
# end class MaterialElementType


class MaterialMixtureType(MaterialType):
    """Exported material composite or mixture typeA complex material can be
    defined as a simple mixture when
    its material properties are known or as a composite material
    or a mixture. A composite material is defined by a set of elements
    by specifying the number of atoms.
    The second way is by a set of material fractions where the fractions
    can be either simple elements or other complex materials.
    The restriction is that one can't mix composition by atoms and fractions
    at the same time.Atomic number"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MaterialType
    def __init__(self, name=None, formula=None, state='unknown', property=None, RL=None, RLref=None, AL=None, ALref=None, T=None, Tref=None, P=None, Pref=None, MEE=None, MEEref=None, Z=None, D=None, Dref=None, atom=None, composite=None, fraction=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(MaterialMixtureType, self).__init__(name, formula, state, property, RL, RLref, AL, ALref, T, Tref, P, Pref, MEE, MEEref,  **kwargs_)
        self.Z = _cast(float, Z)
        self.Z_nsprefix_ = None
        self.D = D
        self.D_nsprefix_ = None
        self.Dref = Dref
        self.Dref_nsprefix_ = None
        self.atom = atom
        self.atom_nsprefix_ = None
        if composite is None:
            self.composite = []
        else:
            self.composite = composite
        self.composite_nsprefix_ = None
        if fraction is None:
            self.fraction = []
        else:
            self.fraction = fraction
        self.fraction_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MaterialMixtureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MaterialMixtureType.subclass:
            return MaterialMixtureType.subclass(*args_, **kwargs_)
        else:
            return MaterialMixtureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_D(self):
        return self.D
    def set_D(self, D):
        self.D = D
    DProp = property(get_D, set_D)
    def get_Dref(self):
        return self.Dref
    def set_Dref(self, Dref):
        self.Dref = Dref
    DrefProp = property(get_Dref, set_Dref)
    def get_atom(self):
        return self.atom
    def set_atom(self, atom):
        self.atom = atom
    atomProp = property(get_atom, set_atom)
    def get_composite(self):
        return self.composite
    def set_composite(self, composite):
        self.composite = composite
    def add_composite(self, value):
        self.composite.append(value)
    def insert_composite_at(self, index, value):
        self.composite.insert(index, value)
    def replace_composite_at(self, index, value):
        self.composite[index] = value
    compositeProp = property(get_composite, set_composite)
    def get_fraction(self):
        return self.fraction
    def set_fraction(self, fraction):
        self.fraction = fraction
    def add_fraction(self, value):
        self.fraction.append(value)
    def insert_fraction_at(self, index, value):
        self.fraction.insert(index, value)
    def replace_fraction_at(self, index, value):
        self.fraction[index] = value
    fractionProp = property(get_fraction, set_fraction)
    def get_Z(self):
        return self.Z
    def set_Z(self, Z):
        self.Z = Z
    ZProp = property(get_Z, set_Z)
    def hasContent_(self):
        if (
            self.D is not None or
            self.Dref is not None or
            self.atom is not None or
            self.composite or
            self.fraction or
            super(MaterialMixtureType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MaterialMixtureType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MaterialMixtureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MaterialMixtureType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MaterialMixtureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MaterialMixtureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MaterialMixtureType'):
        super(MaterialMixtureType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MaterialMixtureType')
        if self.Z is not None and 'Z' not in already_processed:
            already_processed.add('Z')
            outfile.write(' Z="%s"' % self.gds_format_double(self.Z, input_name='Z'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MaterialMixtureType', fromsubclass_=False, pretty_print=True):
        super(MaterialMixtureType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.D is not None:
            namespaceprefix_ = self.D_nsprefix_ + ':' if (UseCapturedNS_ and self.D_nsprefix_) else ''
            self.D.export(outfile, level, namespaceprefix_, namespacedef_='', name_='D', pretty_print=pretty_print)
        if self.Dref is not None:
            namespaceprefix_ = self.Dref_nsprefix_ + ':' if (UseCapturedNS_ and self.Dref_nsprefix_) else ''
            self.Dref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Dref', pretty_print=pretty_print)
        if self.atom is not None:
            namespaceprefix_ = self.atom_nsprefix_ + ':' if (UseCapturedNS_ and self.atom_nsprefix_) else ''
            self.atom.export(outfile, level, namespaceprefix_, namespacedef_='', name_='atom', pretty_print=pretty_print)
        for composite_ in self.composite:
            namespaceprefix_ = self.composite_nsprefix_ + ':' if (UseCapturedNS_ and self.composite_nsprefix_) else ''
            composite_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='composite', pretty_print=pretty_print)
        for fraction_ in self.fraction:
            namespaceprefix_ = self.fraction_nsprefix_ + ':' if (UseCapturedNS_ and self.fraction_nsprefix_) else ''
            fraction_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fraction', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MaterialMixtureType', mapping_=None, nsmap_=None):
        element = super(MaterialMixtureType, self).to_etree(parent_element, name_, mapping_)
        if self.Z is not None:
            element.set('Z', self.gds_format_double(self.Z))
        if self.D is not None:
            D_ = self.D
            D_.to_etree(element, name_='D', mapping_=mapping_, nsmap_=nsmap_)
        if self.Dref is not None:
            Dref_ = self.Dref
            Dref_.to_etree(element, name_='Dref', mapping_=mapping_, nsmap_=nsmap_)
        if self.atom is not None:
            atom_ = self.atom
            atom_.to_etree(element, name_='atom', mapping_=mapping_, nsmap_=nsmap_)
        for composite_ in self.composite:
            composite_.to_etree(element, name_='composite', mapping_=mapping_, nsmap_=nsmap_)
        for fraction_ in self.fraction:
            fraction_.to_etree(element, name_='fraction', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='MaterialMixtureType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Z is not None and 'Z' not in already_processed:
            already_processed.add('Z')
            showIndent(outfile, level)
            outfile.write('Z=%e,\n' % (self.Z,))
        super(MaterialMixtureType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MaterialMixtureType, self).exportLiteralChildren(outfile, level, name_)
        if self.D is not None:
            showIndent(outfile, level)
            outfile.write('D=model_.DensityType(\n')
            self.D.exportLiteral(outfile, level, name_='D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Dref is not None:
            showIndent(outfile, level)
            outfile.write('Dref=model_.ReferenceType(\n')
            self.Dref.exportLiteral(outfile, level, name_='Dref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.atom is not None:
            showIndent(outfile, level)
            outfile.write('atom=model_.AtomType(\n')
            self.atom.exportLiteral(outfile, level, name_='atom')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('composite=[\n')
        level += 1
        for composite_ in self.composite:
            showIndent(outfile, level)
            outfile.write('model_.compositeType(\n')
            composite_.exportLiteral(outfile, level, name_='compositeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('fraction=[\n')
        level += 1
        for fraction_ in self.fraction:
            showIndent(outfile, level)
            outfile.write('model_.fractionType7(\n')
            fraction_.exportLiteral(outfile, level, name_='fractionType7')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Z', node)
        if value is not None and 'Z' not in already_processed:
            already_processed.add('Z')
            value = self.gds_parse_double(value, node, 'Z')
            self.Z = value
        super(MaterialMixtureType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'D':
            obj_ = DensityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.D = obj_
            obj_.original_tagname_ = 'D'
        elif nodeName_ == 'Dref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dref = obj_
            obj_.original_tagname_ = 'Dref'
        elif nodeName_ == 'atom':
            obj_ = AtomType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.atom = obj_
            obj_.original_tagname_ = 'atom'
        elif nodeName_ == 'composite':
            obj_ = compositeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.composite.append(obj_)
            obj_.original_tagname_ = 'composite'
        elif nodeName_ == 'fraction':
            obj_ = fractionType7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fraction.append(obj_)
            obj_.original_tagname_ = 'fraction'
        super(MaterialMixtureType, self).buildChildren(child_, node, nodeName_, True)
# end class MaterialMixtureType


class SolidType(GeneratedsSuper):
    """Base solid typeLength unit of all dimensions used for this instance of
    solidAngle unit of angles used in definition of this solid"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lunit='mm', aunit='radian', name=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lunit = _cast(None, lunit)
        self.lunit_nsprefix_ = None
        self.aunit = _cast(None, aunit)
        self.aunit_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SolidType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SolidType.subclass:
            return SolidType.subclass(*args_, **kwargs_)
        else:
            return SolidType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lunit(self):
        return self.lunit
    def set_lunit(self, lunit):
        self.lunit = lunit
    lunitProp = property(get_lunit, set_lunit)
    def get_aunit(self):
        return self.aunit
    def set_aunit(self, aunit):
        self.aunit = aunit
    aunitProp = property(get_aunit, set_aunit)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SolidType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SolidType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SolidType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SolidType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SolidType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SolidType'):
        if self.lunit != "mm" and 'lunit' not in already_processed:
            already_processed.add('lunit')
            outfile.write(' lunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lunit), input_name='lunit')), ))
        if self.aunit != "radian" and 'aunit' not in already_processed:
            already_processed.add('aunit')
            outfile.write(' aunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aunit), input_name='aunit')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SolidType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='SolidType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.lunit is not None:
            element.set('lunit', self.gds_format_string(self.lunit))
        if self.aunit is not None:
            element.set('aunit', self.gds_format_string(self.aunit))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='SolidType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lunit is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            showIndent(outfile, level)
            outfile.write('lunit="%s",\n' % (self.lunit,))
        if self.aunit is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            showIndent(outfile, level)
            outfile.write('aunit="%s",\n' % (self.aunit,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lunit', node)
        if value is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            self.lunit = value
        value = find_attr_value_('aunit', node)
        if value is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            self.aunit = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SolidType


class BooleanSolidType(SolidType):
    """Base type for boolean solids"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, first=None, second=None, position=None, positionref=None, rotation=None, rotationref=None, firstposition=None, firstpositionref=None, firstrotation=None, firstrotationref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BooleanSolidType, self).__init__(lunit, aunit, name,  **kwargs_)
        self.first = first
        self.first_nsprefix_ = None
        self.second = second
        self.second_nsprefix_ = None
        self.position = position
        self.position_nsprefix_ = None
        self.positionref = positionref
        self.positionref_nsprefix_ = None
        self.rotation = rotation
        self.rotation_nsprefix_ = None
        self.rotationref = rotationref
        self.rotationref_nsprefix_ = None
        self.firstposition = firstposition
        self.firstposition_nsprefix_ = None
        self.firstpositionref = firstpositionref
        self.firstpositionref_nsprefix_ = None
        self.firstrotation = firstrotation
        self.firstrotation_nsprefix_ = None
        self.firstrotationref = firstrotationref
        self.firstrotationref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BooleanSolidType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BooleanSolidType.subclass:
            return BooleanSolidType.subclass(*args_, **kwargs_)
        else:
            return BooleanSolidType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_first(self):
        return self.first
    def set_first(self, first):
        self.first = first
    firstProp = property(get_first, set_first)
    def get_second(self):
        return self.second
    def set_second(self, second):
        self.second = second
    secondProp = property(get_second, set_second)
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    positionProp = property(get_position, set_position)
    def get_positionref(self):
        return self.positionref
    def set_positionref(self, positionref):
        self.positionref = positionref
    positionrefProp = property(get_positionref, set_positionref)
    def get_rotation(self):
        return self.rotation
    def set_rotation(self, rotation):
        self.rotation = rotation
    rotationProp = property(get_rotation, set_rotation)
    def get_rotationref(self):
        return self.rotationref
    def set_rotationref(self, rotationref):
        self.rotationref = rotationref
    rotationrefProp = property(get_rotationref, set_rotationref)
    def get_firstposition(self):
        return self.firstposition
    def set_firstposition(self, firstposition):
        self.firstposition = firstposition
    firstpositionProp = property(get_firstposition, set_firstposition)
    def get_firstpositionref(self):
        return self.firstpositionref
    def set_firstpositionref(self, firstpositionref):
        self.firstpositionref = firstpositionref
    firstpositionrefProp = property(get_firstpositionref, set_firstpositionref)
    def get_firstrotation(self):
        return self.firstrotation
    def set_firstrotation(self, firstrotation):
        self.firstrotation = firstrotation
    firstrotationProp = property(get_firstrotation, set_firstrotation)
    def get_firstrotationref(self):
        return self.firstrotationref
    def set_firstrotationref(self, firstrotationref):
        self.firstrotationref = firstrotationref
    firstrotationrefProp = property(get_firstrotationref, set_firstrotationref)
    def hasContent_(self):
        if (
            self.first is not None or
            self.second is not None or
            self.position is not None or
            self.positionref is not None or
            self.rotation is not None or
            self.rotationref is not None or
            self.firstposition is not None or
            self.firstpositionref is not None or
            self.firstrotation is not None or
            self.firstrotationref is not None or
            super(BooleanSolidType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BooleanSolidType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BooleanSolidType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BooleanSolidType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BooleanSolidType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BooleanSolidType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BooleanSolidType'):
        super(BooleanSolidType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BooleanSolidType')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BooleanSolidType', fromsubclass_=False, pretty_print=True):
        super(BooleanSolidType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.first is not None:
            namespaceprefix_ = self.first_nsprefix_ + ':' if (UseCapturedNS_ and self.first_nsprefix_) else ''
            self.first.export(outfile, level, namespaceprefix_, namespacedef_='', name_='first', pretty_print=pretty_print)
        if self.second is not None:
            namespaceprefix_ = self.second_nsprefix_ + ':' if (UseCapturedNS_ and self.second_nsprefix_) else ''
            self.second.export(outfile, level, namespaceprefix_, namespacedef_='', name_='second', pretty_print=pretty_print)
        if self.position is not None:
            namespaceprefix_ = self.position_nsprefix_ + ':' if (UseCapturedNS_ and self.position_nsprefix_) else ''
            self.position.export(outfile, level, namespaceprefix_, namespacedef_='', name_='position', pretty_print=pretty_print)
        if self.positionref is not None:
            namespaceprefix_ = self.positionref_nsprefix_ + ':' if (UseCapturedNS_ and self.positionref_nsprefix_) else ''
            self.positionref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='positionref', pretty_print=pretty_print)
        if self.rotation is not None:
            namespaceprefix_ = self.rotation_nsprefix_ + ':' if (UseCapturedNS_ and self.rotation_nsprefix_) else ''
            self.rotation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rotation', pretty_print=pretty_print)
        if self.rotationref is not None:
            namespaceprefix_ = self.rotationref_nsprefix_ + ':' if (UseCapturedNS_ and self.rotationref_nsprefix_) else ''
            self.rotationref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rotationref', pretty_print=pretty_print)
        if self.firstposition is not None:
            namespaceprefix_ = self.firstposition_nsprefix_ + ':' if (UseCapturedNS_ and self.firstposition_nsprefix_) else ''
            self.firstposition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='firstposition', pretty_print=pretty_print)
        if self.firstpositionref is not None:
            namespaceprefix_ = self.firstpositionref_nsprefix_ + ':' if (UseCapturedNS_ and self.firstpositionref_nsprefix_) else ''
            self.firstpositionref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='firstpositionref', pretty_print=pretty_print)
        if self.firstrotation is not None:
            namespaceprefix_ = self.firstrotation_nsprefix_ + ':' if (UseCapturedNS_ and self.firstrotation_nsprefix_) else ''
            self.firstrotation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='firstrotation', pretty_print=pretty_print)
        if self.firstrotationref is not None:
            namespaceprefix_ = self.firstrotationref_nsprefix_ + ':' if (UseCapturedNS_ and self.firstrotationref_nsprefix_) else ''
            self.firstrotationref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='firstrotationref', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BooleanSolidType', mapping_=None, nsmap_=None):
        element = super(BooleanSolidType, self).to_etree(parent_element, name_, mapping_)
        if self.first is not None:
            first_ = self.first
            first_.to_etree(element, name_='first', mapping_=mapping_, nsmap_=nsmap_)
        if self.second is not None:
            second_ = self.second
            second_.to_etree(element, name_='second', mapping_=mapping_, nsmap_=nsmap_)
        if self.position is not None:
            position_ = self.position
            position_.to_etree(element, name_='position', mapping_=mapping_, nsmap_=nsmap_)
        if self.positionref is not None:
            positionref_ = self.positionref
            positionref_.to_etree(element, name_='positionref', mapping_=mapping_, nsmap_=nsmap_)
        if self.rotation is not None:
            rotation_ = self.rotation
            rotation_.to_etree(element, name_='rotation', mapping_=mapping_, nsmap_=nsmap_)
        if self.rotationref is not None:
            rotationref_ = self.rotationref
            rotationref_.to_etree(element, name_='rotationref', mapping_=mapping_, nsmap_=nsmap_)
        if self.firstposition is not None:
            firstposition_ = self.firstposition
            firstposition_.to_etree(element, name_='firstposition', mapping_=mapping_, nsmap_=nsmap_)
        if self.firstpositionref is not None:
            firstpositionref_ = self.firstpositionref
            firstpositionref_.to_etree(element, name_='firstpositionref', mapping_=mapping_, nsmap_=nsmap_)
        if self.firstrotation is not None:
            firstrotation_ = self.firstrotation
            firstrotation_.to_etree(element, name_='firstrotation', mapping_=mapping_, nsmap_=nsmap_)
        if self.firstrotationref is not None:
            firstrotationref_ = self.firstrotationref
            firstrotationref_.to_etree(element, name_='firstrotationref', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='BooleanSolidType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BooleanSolidType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BooleanSolidType, self).exportLiteralChildren(outfile, level, name_)
        if self.first is not None:
            showIndent(outfile, level)
            outfile.write('first=model_.ReferenceType(\n')
            self.first.exportLiteral(outfile, level, name_='first')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.second is not None:
            showIndent(outfile, level)
            outfile.write('second=model_.ReferenceType(\n')
            self.second.exportLiteral(outfile, level, name_='second')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.position is not None:
            showIndent(outfile, level)
            outfile.write('position=model_.positionType(\n')
            self.position.exportLiteral(outfile, level, name_='position')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.positionref is not None:
            showIndent(outfile, level)
            outfile.write('positionref=model_.ReferenceType(\n')
            self.positionref.exportLiteral(outfile, level, name_='positionref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rotation is not None:
            showIndent(outfile, level)
            outfile.write('rotation=model_.rotationType(\n')
            self.rotation.exportLiteral(outfile, level, name_='rotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rotationref is not None:
            showIndent(outfile, level)
            outfile.write('rotationref=model_.ReferenceType(\n')
            self.rotationref.exportLiteral(outfile, level, name_='rotationref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.firstposition is not None:
            showIndent(outfile, level)
            outfile.write('firstposition=model_.positionType(\n')
            self.firstposition.exportLiteral(outfile, level, name_='firstposition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.firstpositionref is not None:
            showIndent(outfile, level)
            outfile.write('firstpositionref=model_.ReferenceType(\n')
            self.firstpositionref.exportLiteral(outfile, level, name_='firstpositionref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.firstrotation is not None:
            showIndent(outfile, level)
            outfile.write('firstrotation=model_.rotationType(\n')
            self.firstrotation.exportLiteral(outfile, level, name_='firstrotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.firstrotationref is not None:
            showIndent(outfile, level)
            outfile.write('firstrotationref=model_.ReferenceType(\n')
            self.firstrotationref.exportLiteral(outfile, level, name_='firstrotationref')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BooleanSolidType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'first':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.first = obj_
            obj_.original_tagname_ = 'first'
        elif nodeName_ == 'second':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.second = obj_
            obj_.original_tagname_ = 'second'
        elif nodeName_ == 'position':
            obj_ = positionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.position = obj_
            obj_.original_tagname_ = 'position'
        elif nodeName_ == 'positionref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.positionref = obj_
            obj_.original_tagname_ = 'positionref'
        elif nodeName_ == 'rotation':
            obj_ = rotationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rotation = obj_
            obj_.original_tagname_ = 'rotation'
        elif nodeName_ == 'rotationref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rotationref = obj_
            obj_.original_tagname_ = 'rotationref'
        elif nodeName_ == 'firstposition':
            obj_ = positionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.firstposition = obj_
            obj_.original_tagname_ = 'firstposition'
        elif nodeName_ == 'firstpositionref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.firstpositionref = obj_
            obj_.original_tagname_ = 'firstpositionref'
        elif nodeName_ == 'firstrotation':
            obj_ = rotationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.firstrotation = obj_
            obj_.original_tagname_ = 'firstrotation'
        elif nodeName_ == 'firstrotationref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.firstrotationref = obj_
            obj_.original_tagname_ = 'firstrotationref'
        super(BooleanSolidType, self).buildChildren(child_, node, nodeName_, True)
# end class BooleanSolidType


class multiUnionNode(SolidType):
    """Base node for Multi-Union structure"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, solid=None, position=None, positionref=None, rotation=None, rotationref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(multiUnionNode, self).__init__(lunit, aunit, name,  **kwargs_)
        self.solid = solid
        self.solid_nsprefix_ = None
        self.position = position
        self.position_nsprefix_ = None
        self.positionref = positionref
        self.positionref_nsprefix_ = None
        self.rotation = rotation
        self.rotation_nsprefix_ = None
        self.rotationref = rotationref
        self.rotationref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, multiUnionNode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if multiUnionNode.subclass:
            return multiUnionNode.subclass(*args_, **kwargs_)
        else:
            return multiUnionNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_solid(self):
        return self.solid
    def set_solid(self, solid):
        self.solid = solid
    solidProp = property(get_solid, set_solid)
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    positionProp = property(get_position, set_position)
    def get_positionref(self):
        return self.positionref
    def set_positionref(self, positionref):
        self.positionref = positionref
    positionrefProp = property(get_positionref, set_positionref)
    def get_rotation(self):
        return self.rotation
    def set_rotation(self, rotation):
        self.rotation = rotation
    rotationProp = property(get_rotation, set_rotation)
    def get_rotationref(self):
        return self.rotationref
    def set_rotationref(self, rotationref):
        self.rotationref = rotationref
    rotationrefProp = property(get_rotationref, set_rotationref)
    def hasContent_(self):
        if (
            self.solid is not None or
            self.position is not None or
            self.positionref is not None or
            self.rotation is not None or
            self.rotationref is not None or
            super(multiUnionNode, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='multiUnionNode', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('multiUnionNode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'multiUnionNode':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='multiUnionNode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='multiUnionNode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='multiUnionNode'):
        super(multiUnionNode, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='multiUnionNode')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='multiUnionNode', fromsubclass_=False, pretty_print=True):
        super(multiUnionNode, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.solid is not None:
            namespaceprefix_ = self.solid_nsprefix_ + ':' if (UseCapturedNS_ and self.solid_nsprefix_) else ''
            self.solid.export(outfile, level, namespaceprefix_, namespacedef_='', name_='solid', pretty_print=pretty_print)
        if self.position is not None:
            namespaceprefix_ = self.position_nsprefix_ + ':' if (UseCapturedNS_ and self.position_nsprefix_) else ''
            self.position.export(outfile, level, namespaceprefix_, namespacedef_='', name_='position', pretty_print=pretty_print)
        if self.positionref is not None:
            namespaceprefix_ = self.positionref_nsprefix_ + ':' if (UseCapturedNS_ and self.positionref_nsprefix_) else ''
            self.positionref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='positionref', pretty_print=pretty_print)
        if self.rotation is not None:
            namespaceprefix_ = self.rotation_nsprefix_ + ':' if (UseCapturedNS_ and self.rotation_nsprefix_) else ''
            self.rotation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rotation', pretty_print=pretty_print)
        if self.rotationref is not None:
            namespaceprefix_ = self.rotationref_nsprefix_ + ':' if (UseCapturedNS_ and self.rotationref_nsprefix_) else ''
            self.rotationref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rotationref', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='multiUnionNode', mapping_=None, nsmap_=None):
        element = super(multiUnionNode, self).to_etree(parent_element, name_, mapping_)
        if self.solid is not None:
            solid_ = self.solid
            solid_.to_etree(element, name_='solid', mapping_=mapping_, nsmap_=nsmap_)
        if self.position is not None:
            position_ = self.position
            position_.to_etree(element, name_='position', mapping_=mapping_, nsmap_=nsmap_)
        if self.positionref is not None:
            positionref_ = self.positionref
            positionref_.to_etree(element, name_='positionref', mapping_=mapping_, nsmap_=nsmap_)
        if self.rotation is not None:
            rotation_ = self.rotation
            rotation_.to_etree(element, name_='rotation', mapping_=mapping_, nsmap_=nsmap_)
        if self.rotationref is not None:
            rotationref_ = self.rotationref
            rotationref_.to_etree(element, name_='rotationref', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='multiUnionNode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(multiUnionNode, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(multiUnionNode, self).exportLiteralChildren(outfile, level, name_)
        if self.solid is not None:
            showIndent(outfile, level)
            outfile.write('solid=model_.ReferenceType(\n')
            self.solid.exportLiteral(outfile, level, name_='solid')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.position is not None:
            showIndent(outfile, level)
            outfile.write('position=model_.positionType(\n')
            self.position.exportLiteral(outfile, level, name_='position')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.positionref is not None:
            showIndent(outfile, level)
            outfile.write('positionref=model_.ReferenceType(\n')
            self.positionref.exportLiteral(outfile, level, name_='positionref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rotation is not None:
            showIndent(outfile, level)
            outfile.write('rotation=model_.rotationType(\n')
            self.rotation.exportLiteral(outfile, level, name_='rotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rotationref is not None:
            showIndent(outfile, level)
            outfile.write('rotationref=model_.ReferenceType(\n')
            self.rotationref.exportLiteral(outfile, level, name_='rotationref')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(multiUnionNode, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'solid':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.solid = obj_
            obj_.original_tagname_ = 'solid'
        elif nodeName_ == 'position':
            obj_ = positionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.position = obj_
            obj_.original_tagname_ = 'position'
        elif nodeName_ == 'positionref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.positionref = obj_
            obj_.original_tagname_ = 'positionref'
        elif nodeName_ == 'rotation':
            obj_ = rotationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rotation = obj_
            obj_.original_tagname_ = 'rotation'
        elif nodeName_ == 'rotationref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rotationref = obj_
            obj_.original_tagname_ = 'rotationref'
        super(multiUnionNode, self).buildChildren(child_, node, nodeName_, True)
# end class multiUnionNode


class multiUnion(SolidType):
    """MultiUnion is a Solid created by Union of many Solids.
    This Solid is constructed by multiUnionNodes;
    each Node is described by solid with its position and rotation."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, multiUnionNode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(multiUnion, self).__init__(lunit, aunit, name,  **kwargs_)
        if multiUnionNode is None:
            self.multiUnionNode = []
        else:
            self.multiUnionNode = multiUnionNode
        self.multiUnionNode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, multiUnion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if multiUnion.subclass:
            return multiUnion.subclass(*args_, **kwargs_)
        else:
            return multiUnion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_multiUnionNode(self):
        return self.multiUnionNode
    def set_multiUnionNode(self, multiUnionNode):
        self.multiUnionNode = multiUnionNode
    def add_multiUnionNode(self, value):
        self.multiUnionNode.append(value)
    def insert_multiUnionNode_at(self, index, value):
        self.multiUnionNode.insert(index, value)
    def replace_multiUnionNode_at(self, index, value):
        self.multiUnionNode[index] = value
    multiUnionNodeProp = property(get_multiUnionNode, set_multiUnionNode)
    def hasContent_(self):
        if (
            self.multiUnionNode or
            super(multiUnion, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='multiUnion', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('multiUnion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'multiUnion':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='multiUnion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='multiUnion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='multiUnion'):
        super(multiUnion, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='multiUnion')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='multiUnion', fromsubclass_=False, pretty_print=True):
        super(multiUnion, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for multiUnionNode_ in self.multiUnionNode:
            namespaceprefix_ = self.multiUnionNode_nsprefix_ + ':' if (UseCapturedNS_ and self.multiUnionNode_nsprefix_) else ''
            multiUnionNode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiUnionNode', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='multiUnion', mapping_=None, nsmap_=None):
        element = super(multiUnion, self).to_etree(parent_element, name_, mapping_)
        for multiUnionNode_ in self.multiUnionNode:
            multiUnionNode_.to_etree(element, name_='multiUnionNode', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='multiUnion'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(multiUnion, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(multiUnion, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('multiUnionNode=[\n')
        level += 1
        for multiUnionNode_ in self.multiUnionNode:
            showIndent(outfile, level)
            outfile.write('model_.multiUnionNode(\n')
            multiUnionNode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(multiUnion, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'multiUnionNode':
            obj_ = multiUnionNode.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiUnionNode.append(obj_)
            obj_.original_tagname_ = 'multiUnionNode'
        super(multiUnion, self).buildChildren(child_, node, nodeName_, True)
# end class multiUnion


class reflectedSolid(SolidType):
    """Reflected solid:
    sx, sy, sz are scale components (containing reflection),
    rx, ry, rz are rotation angles around given axes and
    dx, dy, dz is the translation."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, solid=None, sx='1.0', sy='1.0', sz='1.0', rx='0.0', ry='0.0', rz='0.0', dx='0.0', dy='0.0', dz='0.0', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(reflectedSolid, self).__init__(lunit, aunit, name,  **kwargs_)
        self.solid = _cast(None, solid)
        self.solid_nsprefix_ = None
        self.sx = _cast(None, sx)
        self.sx_nsprefix_ = None
        self.sy = _cast(None, sy)
        self.sy_nsprefix_ = None
        self.sz = _cast(None, sz)
        self.sz_nsprefix_ = None
        self.rx = _cast(None, rx)
        self.rx_nsprefix_ = None
        self.ry = _cast(None, ry)
        self.ry_nsprefix_ = None
        self.rz = _cast(None, rz)
        self.rz_nsprefix_ = None
        self.dx = _cast(None, dx)
        self.dx_nsprefix_ = None
        self.dy = _cast(None, dy)
        self.dy_nsprefix_ = None
        self.dz = _cast(None, dz)
        self.dz_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, reflectedSolid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if reflectedSolid.subclass:
            return reflectedSolid.subclass(*args_, **kwargs_)
        else:
            return reflectedSolid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_solid(self):
        return self.solid
    def set_solid(self, solid):
        self.solid = solid
    solidProp = property(get_solid, set_solid)
    def get_sx(self):
        return self.sx
    def set_sx(self, sx):
        self.sx = sx
    sxProp = property(get_sx, set_sx)
    def get_sy(self):
        return self.sy
    def set_sy(self, sy):
        self.sy = sy
    syProp = property(get_sy, set_sy)
    def get_sz(self):
        return self.sz
    def set_sz(self, sz):
        self.sz = sz
    szProp = property(get_sz, set_sz)
    def get_rx(self):
        return self.rx
    def set_rx(self, rx):
        self.rx = rx
    rxProp = property(get_rx, set_rx)
    def get_ry(self):
        return self.ry
    def set_ry(self, ry):
        self.ry = ry
    ryProp = property(get_ry, set_ry)
    def get_rz(self):
        return self.rz
    def set_rz(self, rz):
        self.rz = rz
    rzProp = property(get_rz, set_rz)
    def get_dx(self):
        return self.dx
    def set_dx(self, dx):
        self.dx = dx
    dxProp = property(get_dx, set_dx)
    def get_dy(self):
        return self.dy
    def set_dy(self, dy):
        self.dy = dy
    dyProp = property(get_dy, set_dy)
    def get_dz(self):
        return self.dz
    def set_dz(self, dz):
        self.dz = dz
    dzProp = property(get_dz, set_dz)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(reflectedSolid, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='reflectedSolid', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('reflectedSolid')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'reflectedSolid':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='reflectedSolid')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='reflectedSolid', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='reflectedSolid'):
        super(reflectedSolid, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='reflectedSolid')
        if self.solid is not None and 'solid' not in already_processed:
            already_processed.add('solid')
            outfile.write(' solid=%s' % (quote_attrib(self.solid), ))
        if self.sx != "1.0" and 'sx' not in already_processed:
            already_processed.add('sx')
            outfile.write(' sx=%s' % (quote_attrib(self.sx), ))
        if self.sy != "1.0" and 'sy' not in already_processed:
            already_processed.add('sy')
            outfile.write(' sy=%s' % (quote_attrib(self.sy), ))
        if self.sz != "1.0" and 'sz' not in already_processed:
            already_processed.add('sz')
            outfile.write(' sz=%s' % (quote_attrib(self.sz), ))
        if self.rx != "0.0" and 'rx' not in already_processed:
            already_processed.add('rx')
            outfile.write(' rx=%s' % (quote_attrib(self.rx), ))
        if self.ry != "0.0" and 'ry' not in already_processed:
            already_processed.add('ry')
            outfile.write(' ry=%s' % (quote_attrib(self.ry), ))
        if self.rz != "0.0" and 'rz' not in already_processed:
            already_processed.add('rz')
            outfile.write(' rz=%s' % (quote_attrib(self.rz), ))
        if self.dx != "0.0" and 'dx' not in already_processed:
            already_processed.add('dx')
            outfile.write(' dx=%s' % (quote_attrib(self.dx), ))
        if self.dy != "0.0" and 'dy' not in already_processed:
            already_processed.add('dy')
            outfile.write(' dy=%s' % (quote_attrib(self.dy), ))
        if self.dz != "0.0" and 'dz' not in already_processed:
            already_processed.add('dz')
            outfile.write(' dz=%s' % (quote_attrib(self.dz), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='reflectedSolid', fromsubclass_=False, pretty_print=True):
        super(reflectedSolid, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='reflectedSolid', mapping_=None, nsmap_=None):
        element = super(reflectedSolid, self).to_etree(parent_element, name_, mapping_)
        if self.solid is not None:
            element.set('solid', self.solid)
        if self.sx is not None:
            element.set('sx', self.sx)
        if self.sy is not None:
            element.set('sy', self.sy)
        if self.sz is not None:
            element.set('sz', self.sz)
        if self.rx is not None:
            element.set('rx', self.rx)
        if self.ry is not None:
            element.set('ry', self.ry)
        if self.rz is not None:
            element.set('rz', self.rz)
        if self.dx is not None:
            element.set('dx', self.dx)
        if self.dy is not None:
            element.set('dy', self.dy)
        if self.dz is not None:
            element.set('dz', self.dz)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='reflectedSolid'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.solid is not None and 'solid' not in already_processed:
            already_processed.add('solid')
            showIndent(outfile, level)
            outfile.write('solid=%s,\n' % (self.solid,))
        if self.sx is not None and 'sx' not in already_processed:
            already_processed.add('sx')
            showIndent(outfile, level)
            outfile.write('sx=%s,\n' % (self.sx,))
        if self.sy is not None and 'sy' not in already_processed:
            already_processed.add('sy')
            showIndent(outfile, level)
            outfile.write('sy=%s,\n' % (self.sy,))
        if self.sz is not None and 'sz' not in already_processed:
            already_processed.add('sz')
            showIndent(outfile, level)
            outfile.write('sz=%s,\n' % (self.sz,))
        if self.rx is not None and 'rx' not in already_processed:
            already_processed.add('rx')
            showIndent(outfile, level)
            outfile.write('rx=%s,\n' % (self.rx,))
        if self.ry is not None and 'ry' not in already_processed:
            already_processed.add('ry')
            showIndent(outfile, level)
            outfile.write('ry=%s,\n' % (self.ry,))
        if self.rz is not None and 'rz' not in already_processed:
            already_processed.add('rz')
            showIndent(outfile, level)
            outfile.write('rz=%s,\n' % (self.rz,))
        if self.dx is not None and 'dx' not in already_processed:
            already_processed.add('dx')
            showIndent(outfile, level)
            outfile.write('dx=%s,\n' % (self.dx,))
        if self.dy is not None and 'dy' not in already_processed:
            already_processed.add('dy')
            showIndent(outfile, level)
            outfile.write('dy=%s,\n' % (self.dy,))
        if self.dz is not None and 'dz' not in already_processed:
            already_processed.add('dz')
            showIndent(outfile, level)
            outfile.write('dz=%s,\n' % (self.dz,))
        super(reflectedSolid, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(reflectedSolid, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('solid', node)
        if value is not None and 'solid' not in already_processed:
            already_processed.add('solid')
            self.solid = value
            self.validate_ExpressionOrIDREFType(self.solid)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('sx', node)
        if value is not None and 'sx' not in already_processed:
            already_processed.add('sx')
            self.sx = value
            self.validate_ExpressionOrIDREFType(self.sx)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('sy', node)
        if value is not None and 'sy' not in already_processed:
            already_processed.add('sy')
            self.sy = value
            self.validate_ExpressionOrIDREFType(self.sy)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('sz', node)
        if value is not None and 'sz' not in already_processed:
            already_processed.add('sz')
            self.sz = value
            self.validate_ExpressionOrIDREFType(self.sz)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rx', node)
        if value is not None and 'rx' not in already_processed:
            already_processed.add('rx')
            self.rx = value
            self.validate_ExpressionOrIDREFType(self.rx)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('ry', node)
        if value is not None and 'ry' not in already_processed:
            already_processed.add('ry')
            self.ry = value
            self.validate_ExpressionOrIDREFType(self.ry)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rz', node)
        if value is not None and 'rz' not in already_processed:
            already_processed.add('rz')
            self.rz = value
            self.validate_ExpressionOrIDREFType(self.rz)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('dx', node)
        if value is not None and 'dx' not in already_processed:
            already_processed.add('dx')
            self.dx = value
            self.validate_ExpressionOrIDREFType(self.dx)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('dy', node)
        if value is not None and 'dy' not in already_processed:
            already_processed.add('dy')
            self.dy = value
            self.validate_ExpressionOrIDREFType(self.dy)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('dz', node)
        if value is not None and 'dz' not in already_processed:
            already_processed.add('dz')
            self.dz = value
            self.validate_ExpressionOrIDREFType(self.dz)    # validate type ExpressionOrIDREFType
        super(reflectedSolid, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(reflectedSolid, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class reflectedSolid


class scaledSolid(SolidType):
    """Scaled solid:
    For the scale component, values must be greater than zero."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, solidref=None, scale=None, scaleref=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(scaledSolid, self).__init__(lunit, aunit, name,  **kwargs_)
        self.solidref = solidref
        self.solidref_nsprefix_ = None
        self.scale = scale
        self.scale_nsprefix_ = None
        self.scaleref = scaleref
        self.scaleref_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, scaledSolid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if scaledSolid.subclass:
            return scaledSolid.subclass(*args_, **kwargs_)
        else:
            return scaledSolid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_solidref(self):
        return self.solidref
    def set_solidref(self, solidref):
        self.solidref = solidref
    solidrefProp = property(get_solidref, set_solidref)
    def get_scale(self):
        return self.scale
    def set_scale(self, scale):
        self.scale = scale
    scaleProp = property(get_scale, set_scale)
    def get_scaleref(self):
        return self.scaleref
    def set_scaleref(self, scaleref):
        self.scaleref = scaleref
    scalerefProp = property(get_scaleref, set_scaleref)
    def hasContent_(self):
        if (
            self.solidref is not None or
            self.scale is not None or
            self.scaleref is not None or
            super(scaledSolid, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='scaledSolid', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scaledSolid')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'scaledSolid':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scaledSolid')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='scaledSolid', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='scaledSolid'):
        super(scaledSolid, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scaledSolid')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='scaledSolid', fromsubclass_=False, pretty_print=True):
        super(scaledSolid, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.solidref is not None:
            namespaceprefix_ = self.solidref_nsprefix_ + ':' if (UseCapturedNS_ and self.solidref_nsprefix_) else ''
            self.solidref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='solidref', pretty_print=pretty_print)
        if self.scale is not None:
            namespaceprefix_ = self.scale_nsprefix_ + ':' if (UseCapturedNS_ and self.scale_nsprefix_) else ''
            self.scale.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scale', pretty_print=pretty_print)
        if self.scaleref is not None:
            namespaceprefix_ = self.scaleref_nsprefix_ + ':' if (UseCapturedNS_ and self.scaleref_nsprefix_) else ''
            self.scaleref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='scaleref', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='scaledSolid', mapping_=None, nsmap_=None):
        element = super(scaledSolid, self).to_etree(parent_element, name_, mapping_)
        if self.solidref is not None:
            solidref_ = self.solidref
            solidref_.to_etree(element, name_='solidref', mapping_=mapping_, nsmap_=nsmap_)
        if self.scale is not None:
            scale_ = self.scale
            scale_.to_etree(element, name_='scale', mapping_=mapping_, nsmap_=nsmap_)
        if self.scaleref is not None:
            scaleref_ = self.scaleref
            scaleref_.to_etree(element, name_='scaleref', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='scaledSolid'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(scaledSolid, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(scaledSolid, self).exportLiteralChildren(outfile, level, name_)
        if self.solidref is not None:
            showIndent(outfile, level)
            outfile.write('solidref=model_.ReferenceType(\n')
            self.solidref.exportLiteral(outfile, level, name_='solidref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scale is not None:
            showIndent(outfile, level)
            outfile.write('scale=model_.scaleType(\n')
            self.scale.exportLiteral(outfile, level, name_='scale')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scaleref is not None:
            showIndent(outfile, level)
            outfile.write('scaleref=model_.ReferenceType(\n')
            self.scaleref.exportLiteral(outfile, level, name_='scaleref')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(scaledSolid, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'solidref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.solidref = obj_
            obj_.original_tagname_ = 'solidref'
        elif nodeName_ == 'scale':
            obj_ = scaleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scale = obj_
            obj_.original_tagname_ = 'scale'
        elif nodeName_ == 'scaleref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.scaleref = obj_
            obj_.original_tagname_ = 'scaleref'
        super(scaledSolid, self).buildChildren(child_, node, nodeName_, True)
# end class scaledSolid


class SurfacePropertyType(GeneratedsSuper):
    """Base surface type"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, type_='dielectric_dielectric', property=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if property is None:
            self.property = []
        else:
            self.property = property
        self.property_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SurfacePropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SurfacePropertyType.subclass:
            return SurfacePropertyType.subclass(*args_, **kwargs_)
        else:
            return SurfacePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_property(self):
        return self.property
    def set_property(self, property):
        self.property = property
    def add_property(self, value):
        self.property.append(value)
    def insert_property_at(self, index, value):
        self.property.insert(index, value)
    def replace_property_at(self, index, value):
        self.property[index] = value
    propertyProp = property(get_property, set_property)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SurfacePropertyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SurfacePropertyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SurfacePropertyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SurfacePropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SurfacePropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SurfacePropertyType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.type_ != "dielectric_dielectric" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SurfacePropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for property_ in self.property:
            namespaceprefix_ = self.property_nsprefix_ + ':' if (UseCapturedNS_ and self.property_nsprefix_) else ''
            property_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='property', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SurfacePropertyType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        for property_ in self.property:
            property_.to_etree(element, name_='property', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='SurfacePropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('property=[\n')
        level += 1
        for property_ in self.property:
            showIndent(outfile, level)
            outfile.write('model_.propertyType9(\n')
            property_.exportLiteral(outfile, level, name_='propertyType9')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'property':
            obj_ = propertyType9.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.property.append(obj_)
            obj_.original_tagname_ = 'property'
# end class SurfacePropertyType


class solids(GeneratedsSuper):
    """Solids definitions block"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, define=None, Solid=None, SurfaceProperty=None, loop=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if define is None:
            self.define = []
        else:
            self.define = define
        self.define_nsprefix_ = None
        if Solid is None:
            self.Solid = []
        else:
            self.Solid = Solid
        self.Solid_nsprefix_ = None
        if SurfaceProperty is None:
            self.SurfaceProperty = []
        else:
            self.SurfaceProperty = SurfaceProperty
        self.SurfaceProperty_nsprefix_ = None
        if loop is None:
            self.loop = []
        else:
            self.loop = loop
        self.loop_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, solids)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if solids.subclass:
            return solids.subclass(*args_, **kwargs_)
        else:
            return solids(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_define(self):
        return self.define
    def set_define(self, define):
        self.define = define
    def add_define(self, value):
        self.define.append(value)
    def insert_define_at(self, index, value):
        self.define.insert(index, value)
    def replace_define_at(self, index, value):
        self.define[index] = value
    defineProp = property(get_define, set_define)
    def get_Solid(self):
        return self.Solid
    def set_Solid(self, Solid):
        self.Solid = Solid
    def add_Solid(self, value):
        self.Solid.append(value)
    def insert_Solid_at(self, index, value):
        self.Solid.insert(index, value)
    def replace_Solid_at(self, index, value):
        self.Solid[index] = value
    SolidProp = property(get_Solid, set_Solid)
    def get_SurfaceProperty(self):
        return self.SurfaceProperty
    def set_SurfaceProperty(self, SurfaceProperty):
        self.SurfaceProperty = SurfaceProperty
    def add_SurfaceProperty(self, value):
        self.SurfaceProperty.append(value)
    def insert_SurfaceProperty_at(self, index, value):
        self.SurfaceProperty.insert(index, value)
    def replace_SurfaceProperty_at(self, index, value):
        self.SurfaceProperty[index] = value
    SurfacePropertyProp = property(get_SurfaceProperty, set_SurfaceProperty)
    def get_loop(self):
        return self.loop
    def set_loop(self, loop):
        self.loop = loop
    def add_loop(self, value):
        self.loop.append(value)
    def insert_loop_at(self, index, value):
        self.loop.insert(index, value)
    def replace_loop_at(self, index, value):
        self.loop[index] = value
    loopProp = property(get_loop, set_loop)
    def hasContent_(self):
        if (
            self.define or
            self.Solid or
            self.SurfaceProperty or
            self.loop
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='solids', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('solids')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'solids':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='solids')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='solids', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='solids'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='solids', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for define_ in self.define:
            namespaceprefix_ = self.define_nsprefix_ + ':' if (UseCapturedNS_ and self.define_nsprefix_) else ''
            define_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='define', pretty_print=pretty_print)
        for Solid_ in self.Solid:
            Solid_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        for SurfaceProperty_ in self.SurfaceProperty:
            SurfaceProperty_.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
        for loop_ in self.loop:
            namespaceprefix_ = self.loop_nsprefix_ + ':' if (UseCapturedNS_ and self.loop_nsprefix_) else ''
            loop_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='loop', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='solids', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        for define_ in self.define:
            define_.to_etree(element, name_='define', mapping_=mapping_, nsmap_=nsmap_)
        for Solid_ in self.Solid:
            Solid_.to_etree(element, name_='Solid', mapping_=mapping_, nsmap_=nsmap_)
        for SurfaceProperty_ in self.SurfaceProperty:
            SurfaceProperty_.to_etree(element, name_='SurfaceProperty', mapping_=mapping_, nsmap_=nsmap_)
        for loop_ in self.loop:
            loop_.to_etree(element, name_='loop', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='solids'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('define=[\n')
        level += 1
        for define_ in self.define:
            showIndent(outfile, level)
            outfile.write('model_.defineType(\n')
            define_.exportLiteral(outfile, level, name_='defineType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Solid=[\n')
        level += 1
        for Solid_ in self.Solid:
            showIndent(outfile, level)
            outfile.write('model_.Solid(\n')
            Solid_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SurfaceProperty=[\n')
        level += 1
        for SurfaceProperty_ in self.SurfaceProperty:
            showIndent(outfile, level)
            outfile.write('model_.SurfaceProperty(\n')
            SurfaceProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('loop=[\n')
        level += 1
        for loop_ in self.loop:
            showIndent(outfile, level)
            outfile.write('model_.loop(\n')
            loop_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'define':
            obj_ = defineType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.define.append(obj_)
            obj_.original_tagname_ = 'define'
        elif nodeName_ == 'Solid':
            class_obj_ = self.get_class_obj_(child_, SolidType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'Solid'
        elif nodeName_ == 'multiUnion':
            obj_ = multiUnion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'multiUnion'
        elif nodeName_ == 'reflectedSolid':
            obj_ = reflectedSolid.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'reflectedSolid'
        elif nodeName_ == 'scaledSolid':
            obj_ = scaledSolid.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'scaledSolid'
        elif nodeName_ == 'union':
            obj_ = BooleanSolidType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'union'
        elif nodeName_ == 'subtraction':
            obj_ = BooleanSolidType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'subtraction'
        elif nodeName_ == 'intersection':
            obj_ = BooleanSolidType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'intersection'
        elif nodeName_ == 'box':
            obj_ = box.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'box'
        elif nodeName_ == 'twistedbox':
            obj_ = twistedbox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'twistedbox'
        elif nodeName_ == 'twistedtrap':
            obj_ = twistedtrap.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'twistedtrap'
        elif nodeName_ == 'twistedtrd':
            obj_ = twistedtrd.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'twistedtrd'
        elif nodeName_ == 'paraboloid':
            obj_ = paraboloid.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'paraboloid'
        elif nodeName_ == 'sphere':
            obj_ = sphere.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'sphere'
        elif nodeName_ == 'ellipsoid':
            obj_ = ellipsoid.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'ellipsoid'
        elif nodeName_ == 'tube':
            obj_ = tube.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'tube'
        elif nodeName_ == 'twistedtubs':
            obj_ = twistedtubs.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'twistedtubs'
        elif nodeName_ == 'cutTube':
            obj_ = cutTube.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'cutTube'
        elif nodeName_ == 'cone':
            obj_ = cone.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'cone'
        elif nodeName_ == 'elcone':
            obj_ = elcone.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'elcone'
        elif nodeName_ == 'polycone':
            obj_ = polycone.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'polycone'
        elif nodeName_ == 'genericPolycone':
            obj_ = genericPolycone.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'genericPolycone'
        elif nodeName_ == 'para':
            obj_ = para.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'para'
        elif nodeName_ == 'trd':
            obj_ = trd.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'trd'
        elif nodeName_ == 'trap':
            obj_ = trap.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'trap'
        elif nodeName_ == 'torus':
            obj_ = torus.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'torus'
        elif nodeName_ == 'orb':
            obj_ = orb.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'orb'
        elif nodeName_ == 'polyhedra':
            obj_ = polyhedra.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'polyhedra'
        elif nodeName_ == 'genericPolyhedra':
            obj_ = genericPolyhedra.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'genericPolyhedra'
        elif nodeName_ == 'xtru':
            obj_ = xtru.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'xtru'
        elif nodeName_ == 'hype':
            obj_ = hype.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'hype'
        elif nodeName_ == 'eltube':
            obj_ = eltube.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'eltube'
        elif nodeName_ == 'tet':
            obj_ = tet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'tet'
        elif nodeName_ == 'arb8':
            obj_ = arb8.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'arb8'
        elif nodeName_ == 'tessellated':
            obj_ = tessellated.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Solid.append(obj_)
            obj_.original_tagname_ = 'tessellated'
        elif nodeName_ == 'SurfaceProperty':
            class_obj_ = self.get_class_obj_(child_, SurfacePropertyType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SurfaceProperty.append(obj_)
            obj_.original_tagname_ = 'SurfaceProperty'
        elif nodeName_ == 'opticalsurface':
            obj_ = opticalsurface.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SurfaceProperty.append(obj_)
            obj_.original_tagname_ = 'opticalsurface'
        elif nodeName_ == 'loop':
            obj_ = loop.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.loop.append(obj_)
            obj_.original_tagname_ = 'loop'
# end class solids


class box(SolidType):
    """CSG box solid described by 3 dimensions of x, y, and z"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, x=None, y=None, z=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(box, self).__init__(lunit, aunit, name,  **kwargs_)
        self.x = _cast(None, x)
        self.x_nsprefix_ = None
        self.y = _cast(None, y)
        self.y_nsprefix_ = None
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, box)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if box.subclass:
            return box.subclass(*args_, **kwargs_)
        else:
            return box(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    xProp = property(get_x, set_x)
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    yProp = property(get_y, set_y)
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(box, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='box', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('box')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'box':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='box')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='box', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='box'):
        super(box, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='box')
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x=%s' % (quote_attrib(self.x), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y=%s' % (quote_attrib(self.y), ))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='box', fromsubclass_=False, pretty_print=True):
        super(box, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='box', mapping_=None, nsmap_=None):
        element = super(box, self).to_etree(parent_element, name_, mapping_)
        if self.x is not None:
            element.set('x', self.x)
        if self.y is not None:
            element.set('y', self.y)
        if self.z is not None:
            element.set('z', self.z)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='box'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%s,\n' % (self.x,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%s,\n' % (self.y,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        super(box, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(box, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            self.x = value
            self.validate_ExpressionOrIDREFType(self.x)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            self.y = value
            self.validate_ExpressionOrIDREFType(self.y)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        super(box, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(box, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class box


class twistedbox(SolidType):
    """CSG twisted box solid described by 4 dimensions of
    x length along x axis
    y length along y axis
    z length along z axis
    PhiTwist twist angle"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, x=None, y=None, z=None, PhiTwist=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(twistedbox, self).__init__(lunit, aunit, name,  **kwargs_)
        self.x = _cast(None, x)
        self.x_nsprefix_ = None
        self.y = _cast(None, y)
        self.y_nsprefix_ = None
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.PhiTwist = _cast(None, PhiTwist)
        self.PhiTwist_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, twistedbox)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if twistedbox.subclass:
            return twistedbox.subclass(*args_, **kwargs_)
        else:
            return twistedbox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    xProp = property(get_x, set_x)
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    yProp = property(get_y, set_y)
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_PhiTwist(self):
        return self.PhiTwist
    def set_PhiTwist(self, PhiTwist):
        self.PhiTwist = PhiTwist
    PhiTwistProp = property(get_PhiTwist, set_PhiTwist)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(twistedbox, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='twistedbox', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('twistedbox')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'twistedbox':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='twistedbox')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='twistedbox', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='twistedbox'):
        super(twistedbox, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='twistedbox')
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x=%s' % (quote_attrib(self.x), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y=%s' % (quote_attrib(self.y), ))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.PhiTwist is not None and 'PhiTwist' not in already_processed:
            already_processed.add('PhiTwist')
            outfile.write(' PhiTwist=%s' % (quote_attrib(self.PhiTwist), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='twistedbox', fromsubclass_=False, pretty_print=True):
        super(twistedbox, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='twistedbox', mapping_=None, nsmap_=None):
        element = super(twistedbox, self).to_etree(parent_element, name_, mapping_)
        if self.x is not None:
            element.set('x', self.x)
        if self.y is not None:
            element.set('y', self.y)
        if self.z is not None:
            element.set('z', self.z)
        if self.PhiTwist is not None:
            element.set('PhiTwist', self.PhiTwist)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='twistedbox'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%s,\n' % (self.x,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%s,\n' % (self.y,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        if self.PhiTwist is not None and 'PhiTwist' not in already_processed:
            already_processed.add('PhiTwist')
            showIndent(outfile, level)
            outfile.write('PhiTwist=%s,\n' % (self.PhiTwist,))
        super(twistedbox, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(twistedbox, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            self.x = value
            self.validate_ExpressionOrIDREFType(self.x)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            self.y = value
            self.validate_ExpressionOrIDREFType(self.y)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('PhiTwist', node)
        if value is not None and 'PhiTwist' not in already_processed:
            already_processed.add('PhiTwist')
            self.PhiTwist = value
            self.validate_ExpressionOrIDREFType(self.PhiTwist)    # validate type ExpressionOrIDREFType
        super(twistedbox, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(twistedbox, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class twistedbox


class twistedtrap(SolidType):
    """general twisted trapezoid. faces perpendicular to the z planes are
    trapezia, and their centres are
    not necessarily on a line paralell to the z axis.
    PhiTwist Twist Angle
    z length along the z-axis
    Theta Polar angle of the line joining the centres of the faces at -/+z
    Phi Azimuthal angle of the line joing the centre of the face at -z to the
    centre of the face at +z
    y1 length along y of the face at -z
    x1 length along x of the side at y=-y1 of the face at -z
    x2 length along x of the side at y=+y1 of the face at -z
    y2 length along y of the face at +z
    x3 length along x of the side at y=-y2 of the face at +z
    x4 length along x of the side at y=+y2 of the face at +z
    Alph Angle with respect to the y axis from the centre of the side"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, PhiTwist=None, z=None, Theta=None, Phi=None, y1=None, x1=None, y2=None, x2=None, x3=None, x4=None, Alph=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(twistedtrap, self).__init__(lunit, aunit, name,  **kwargs_)
        self.PhiTwist = _cast(None, PhiTwist)
        self.PhiTwist_nsprefix_ = None
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.Theta = _cast(None, Theta)
        self.Theta_nsprefix_ = None
        self.Phi = _cast(None, Phi)
        self.Phi_nsprefix_ = None
        self.y1 = _cast(None, y1)
        self.y1_nsprefix_ = None
        self.x1 = _cast(None, x1)
        self.x1_nsprefix_ = None
        self.y2 = _cast(None, y2)
        self.y2_nsprefix_ = None
        self.x2 = _cast(None, x2)
        self.x2_nsprefix_ = None
        self.x3 = _cast(None, x3)
        self.x3_nsprefix_ = None
        self.x4 = _cast(None, x4)
        self.x4_nsprefix_ = None
        self.Alph = _cast(None, Alph)
        self.Alph_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, twistedtrap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if twistedtrap.subclass:
            return twistedtrap.subclass(*args_, **kwargs_)
        else:
            return twistedtrap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PhiTwist(self):
        return self.PhiTwist
    def set_PhiTwist(self, PhiTwist):
        self.PhiTwist = PhiTwist
    PhiTwistProp = property(get_PhiTwist, set_PhiTwist)
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_Theta(self):
        return self.Theta
    def set_Theta(self, Theta):
        self.Theta = Theta
    ThetaProp = property(get_Theta, set_Theta)
    def get_Phi(self):
        return self.Phi
    def set_Phi(self, Phi):
        self.Phi = Phi
    PhiProp = property(get_Phi, set_Phi)
    def get_y1(self):
        return self.y1
    def set_y1(self, y1):
        self.y1 = y1
    y1Prop = property(get_y1, set_y1)
    def get_x1(self):
        return self.x1
    def set_x1(self, x1):
        self.x1 = x1
    x1Prop = property(get_x1, set_x1)
    def get_y2(self):
        return self.y2
    def set_y2(self, y2):
        self.y2 = y2
    y2Prop = property(get_y2, set_y2)
    def get_x2(self):
        return self.x2
    def set_x2(self, x2):
        self.x2 = x2
    x2Prop = property(get_x2, set_x2)
    def get_x3(self):
        return self.x3
    def set_x3(self, x3):
        self.x3 = x3
    x3Prop = property(get_x3, set_x3)
    def get_x4(self):
        return self.x4
    def set_x4(self, x4):
        self.x4 = x4
    x4Prop = property(get_x4, set_x4)
    def get_Alph(self):
        return self.Alph
    def set_Alph(self, Alph):
        self.Alph = Alph
    AlphProp = property(get_Alph, set_Alph)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(twistedtrap, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='twistedtrap', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('twistedtrap')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'twistedtrap':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='twistedtrap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='twistedtrap', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='twistedtrap'):
        super(twistedtrap, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='twistedtrap')
        if self.PhiTwist is not None and 'PhiTwist' not in already_processed:
            already_processed.add('PhiTwist')
            outfile.write(' PhiTwist=%s' % (quote_attrib(self.PhiTwist), ))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.Theta is not None and 'Theta' not in already_processed:
            already_processed.add('Theta')
            outfile.write(' Theta=%s' % (quote_attrib(self.Theta), ))
        if self.Phi is not None and 'Phi' not in already_processed:
            already_processed.add('Phi')
            outfile.write(' Phi=%s' % (quote_attrib(self.Phi), ))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.add('y1')
            outfile.write(' y1=%s' % (quote_attrib(self.y1), ))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.add('x1')
            outfile.write(' x1=%s' % (quote_attrib(self.x1), ))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.add('y2')
            outfile.write(' y2=%s' % (quote_attrib(self.y2), ))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.add('x2')
            outfile.write(' x2=%s' % (quote_attrib(self.x2), ))
        if self.x3 is not None and 'x3' not in already_processed:
            already_processed.add('x3')
            outfile.write(' x3=%s' % (quote_attrib(self.x3), ))
        if self.x4 is not None and 'x4' not in already_processed:
            already_processed.add('x4')
            outfile.write(' x4=%s' % (quote_attrib(self.x4), ))
        if self.Alph is not None and 'Alph' not in already_processed:
            already_processed.add('Alph')
            outfile.write(' Alph=%s' % (quote_attrib(self.Alph), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='twistedtrap', fromsubclass_=False, pretty_print=True):
        super(twistedtrap, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='twistedtrap', mapping_=None, nsmap_=None):
        element = super(twistedtrap, self).to_etree(parent_element, name_, mapping_)
        if self.PhiTwist is not None:
            element.set('PhiTwist', self.PhiTwist)
        if self.z is not None:
            element.set('z', self.z)
        if self.Theta is not None:
            element.set('Theta', self.Theta)
        if self.Phi is not None:
            element.set('Phi', self.Phi)
        if self.y1 is not None:
            element.set('y1', self.y1)
        if self.x1 is not None:
            element.set('x1', self.x1)
        if self.y2 is not None:
            element.set('y2', self.y2)
        if self.x2 is not None:
            element.set('x2', self.x2)
        if self.x3 is not None:
            element.set('x3', self.x3)
        if self.x4 is not None:
            element.set('x4', self.x4)
        if self.Alph is not None:
            element.set('Alph', self.Alph)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='twistedtrap'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.PhiTwist is not None and 'PhiTwist' not in already_processed:
            already_processed.add('PhiTwist')
            showIndent(outfile, level)
            outfile.write('PhiTwist=%s,\n' % (self.PhiTwist,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        if self.Theta is not None and 'Theta' not in already_processed:
            already_processed.add('Theta')
            showIndent(outfile, level)
            outfile.write('Theta=%s,\n' % (self.Theta,))
        if self.Phi is not None and 'Phi' not in already_processed:
            already_processed.add('Phi')
            showIndent(outfile, level)
            outfile.write('Phi=%s,\n' % (self.Phi,))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.add('y1')
            showIndent(outfile, level)
            outfile.write('y1=%s,\n' % (self.y1,))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.add('x1')
            showIndent(outfile, level)
            outfile.write('x1=%s,\n' % (self.x1,))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.add('y2')
            showIndent(outfile, level)
            outfile.write('y2=%s,\n' % (self.y2,))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.add('x2')
            showIndent(outfile, level)
            outfile.write('x2=%s,\n' % (self.x2,))
        if self.x3 is not None and 'x3' not in already_processed:
            already_processed.add('x3')
            showIndent(outfile, level)
            outfile.write('x3=%s,\n' % (self.x3,))
        if self.x4 is not None and 'x4' not in already_processed:
            already_processed.add('x4')
            showIndent(outfile, level)
            outfile.write('x4=%s,\n' % (self.x4,))
        if self.Alph is not None and 'Alph' not in already_processed:
            already_processed.add('Alph')
            showIndent(outfile, level)
            outfile.write('Alph=%s,\n' % (self.Alph,))
        super(twistedtrap, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(twistedtrap, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('PhiTwist', node)
        if value is not None and 'PhiTwist' not in already_processed:
            already_processed.add('PhiTwist')
            self.PhiTwist = value
            self.validate_ExpressionOrIDREFType(self.PhiTwist)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('Theta', node)
        if value is not None and 'Theta' not in already_processed:
            already_processed.add('Theta')
            self.Theta = value
            self.validate_ExpressionOrIDREFType(self.Theta)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('Phi', node)
        if value is not None and 'Phi' not in already_processed:
            already_processed.add('Phi')
            self.Phi = value
            self.validate_ExpressionOrIDREFType(self.Phi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y1', node)
        if value is not None and 'y1' not in already_processed:
            already_processed.add('y1')
            self.y1 = value
            self.validate_ExpressionOrIDREFType(self.y1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('x1', node)
        if value is not None and 'x1' not in already_processed:
            already_processed.add('x1')
            self.x1 = value
            self.validate_ExpressionOrIDREFType(self.x1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y2', node)
        if value is not None and 'y2' not in already_processed:
            already_processed.add('y2')
            self.y2 = value
            self.validate_ExpressionOrIDREFType(self.y2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('x2', node)
        if value is not None and 'x2' not in already_processed:
            already_processed.add('x2')
            self.x2 = value
            self.validate_ExpressionOrIDREFType(self.x2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('x3', node)
        if value is not None and 'x3' not in already_processed:
            already_processed.add('x3')
            self.x3 = value
            self.validate_ExpressionOrIDREFType(self.x3)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('x4', node)
        if value is not None and 'x4' not in already_processed:
            already_processed.add('x4')
            self.x4 = value
            self.validate_ExpressionOrIDREFType(self.x4)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('Alph', node)
        if value is not None and 'Alph' not in already_processed:
            already_processed.add('Alph')
            self.Alph = value
            self.validate_ExpressionOrIDREFType(self.Alph)    # validate type ExpressionOrIDREFType
        super(twistedtrap, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(twistedtrap, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class twistedtrap


class twistedtrd(SolidType):
    """different length axis twistable trapezoid. faces perpendicular to the z
    planes are trapezia, and their centres are
    not necessarily on a line paralell to the z axis.
    PhiTwist Twist Angle
    z length along the z-axis
    y1 length along y of the face at -z
    x1 length along x of the side at y=-y1 of the face at -z
    x2 length along x of the side at y=+y1 of the face at -z
    y2 length along y of the face at +z"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, PhiTwist=None, z=None, y1=None, x1=None, y2=None, x2=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(twistedtrd, self).__init__(lunit, aunit, name,  **kwargs_)
        self.PhiTwist = _cast(None, PhiTwist)
        self.PhiTwist_nsprefix_ = None
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.y1 = _cast(None, y1)
        self.y1_nsprefix_ = None
        self.x1 = _cast(None, x1)
        self.x1_nsprefix_ = None
        self.y2 = _cast(None, y2)
        self.y2_nsprefix_ = None
        self.x2 = _cast(None, x2)
        self.x2_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, twistedtrd)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if twistedtrd.subclass:
            return twistedtrd.subclass(*args_, **kwargs_)
        else:
            return twistedtrd(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PhiTwist(self):
        return self.PhiTwist
    def set_PhiTwist(self, PhiTwist):
        self.PhiTwist = PhiTwist
    PhiTwistProp = property(get_PhiTwist, set_PhiTwist)
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_y1(self):
        return self.y1
    def set_y1(self, y1):
        self.y1 = y1
    y1Prop = property(get_y1, set_y1)
    def get_x1(self):
        return self.x1
    def set_x1(self, x1):
        self.x1 = x1
    x1Prop = property(get_x1, set_x1)
    def get_y2(self):
        return self.y2
    def set_y2(self, y2):
        self.y2 = y2
    y2Prop = property(get_y2, set_y2)
    def get_x2(self):
        return self.x2
    def set_x2(self, x2):
        self.x2 = x2
    x2Prop = property(get_x2, set_x2)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(twistedtrd, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='twistedtrd', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('twistedtrd')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'twistedtrd':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='twistedtrd')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='twistedtrd', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='twistedtrd'):
        super(twistedtrd, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='twistedtrd')
        if self.PhiTwist is not None and 'PhiTwist' not in already_processed:
            already_processed.add('PhiTwist')
            outfile.write(' PhiTwist=%s' % (quote_attrib(self.PhiTwist), ))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.add('y1')
            outfile.write(' y1=%s' % (quote_attrib(self.y1), ))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.add('x1')
            outfile.write(' x1=%s' % (quote_attrib(self.x1), ))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.add('y2')
            outfile.write(' y2=%s' % (quote_attrib(self.y2), ))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.add('x2')
            outfile.write(' x2=%s' % (quote_attrib(self.x2), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='twistedtrd', fromsubclass_=False, pretty_print=True):
        super(twistedtrd, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='twistedtrd', mapping_=None, nsmap_=None):
        element = super(twistedtrd, self).to_etree(parent_element, name_, mapping_)
        if self.PhiTwist is not None:
            element.set('PhiTwist', self.PhiTwist)
        if self.z is not None:
            element.set('z', self.z)
        if self.y1 is not None:
            element.set('y1', self.y1)
        if self.x1 is not None:
            element.set('x1', self.x1)
        if self.y2 is not None:
            element.set('y2', self.y2)
        if self.x2 is not None:
            element.set('x2', self.x2)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='twistedtrd'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.PhiTwist is not None and 'PhiTwist' not in already_processed:
            already_processed.add('PhiTwist')
            showIndent(outfile, level)
            outfile.write('PhiTwist=%s,\n' % (self.PhiTwist,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.add('y1')
            showIndent(outfile, level)
            outfile.write('y1=%s,\n' % (self.y1,))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.add('x1')
            showIndent(outfile, level)
            outfile.write('x1=%s,\n' % (self.x1,))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.add('y2')
            showIndent(outfile, level)
            outfile.write('y2=%s,\n' % (self.y2,))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.add('x2')
            showIndent(outfile, level)
            outfile.write('x2=%s,\n' % (self.x2,))
        super(twistedtrd, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(twistedtrd, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('PhiTwist', node)
        if value is not None and 'PhiTwist' not in already_processed:
            already_processed.add('PhiTwist')
            self.PhiTwist = value
            self.validate_ExpressionOrIDREFType(self.PhiTwist)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y1', node)
        if value is not None and 'y1' not in already_processed:
            already_processed.add('y1')
            self.y1 = value
            self.validate_ExpressionOrIDREFType(self.y1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('x1', node)
        if value is not None and 'x1' not in already_processed:
            already_processed.add('x1')
            self.x1 = value
            self.validate_ExpressionOrIDREFType(self.x1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y2', node)
        if value is not None and 'y2' not in already_processed:
            already_processed.add('y2')
            self.y2 = value
            self.validate_ExpressionOrIDREFType(self.y2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('x2', node)
        if value is not None and 'x2' not in already_processed:
            already_processed.add('x2')
            self.x2 = value
            self.validate_ExpressionOrIDREFType(self.x2)    # validate type ExpressionOrIDREFType
        super(twistedtrd, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(twistedtrd, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class twistedtrd


class paraboloid(SolidType):
    """CSG paraboloid defined by
    rlo radius at -dz
    rhi radius at +dz
    dz half z length"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, rlo=None, rhi=None, dz=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(paraboloid, self).__init__(lunit, aunit, name,  **kwargs_)
        self.rlo = _cast(None, rlo)
        self.rlo_nsprefix_ = None
        self.rhi = _cast(None, rhi)
        self.rhi_nsprefix_ = None
        self.dz = _cast(None, dz)
        self.dz_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, paraboloid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if paraboloid.subclass:
            return paraboloid.subclass(*args_, **kwargs_)
        else:
            return paraboloid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_rlo(self):
        return self.rlo
    def set_rlo(self, rlo):
        self.rlo = rlo
    rloProp = property(get_rlo, set_rlo)
    def get_rhi(self):
        return self.rhi
    def set_rhi(self, rhi):
        self.rhi = rhi
    rhiProp = property(get_rhi, set_rhi)
    def get_dz(self):
        return self.dz
    def set_dz(self, dz):
        self.dz = dz
    dzProp = property(get_dz, set_dz)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(paraboloid, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='paraboloid', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('paraboloid')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'paraboloid':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='paraboloid')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='paraboloid', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='paraboloid'):
        super(paraboloid, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='paraboloid')
        if self.rlo is not None and 'rlo' not in already_processed:
            already_processed.add('rlo')
            outfile.write(' rlo=%s' % (quote_attrib(self.rlo), ))
        if self.rhi is not None and 'rhi' not in already_processed:
            already_processed.add('rhi')
            outfile.write(' rhi=%s' % (quote_attrib(self.rhi), ))
        if self.dz is not None and 'dz' not in already_processed:
            already_processed.add('dz')
            outfile.write(' dz=%s' % (quote_attrib(self.dz), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='paraboloid', fromsubclass_=False, pretty_print=True):
        super(paraboloid, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='paraboloid', mapping_=None, nsmap_=None):
        element = super(paraboloid, self).to_etree(parent_element, name_, mapping_)
        if self.rlo is not None:
            element.set('rlo', self.rlo)
        if self.rhi is not None:
            element.set('rhi', self.rhi)
        if self.dz is not None:
            element.set('dz', self.dz)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='paraboloid'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rlo is not None and 'rlo' not in already_processed:
            already_processed.add('rlo')
            showIndent(outfile, level)
            outfile.write('rlo=%s,\n' % (self.rlo,))
        if self.rhi is not None and 'rhi' not in already_processed:
            already_processed.add('rhi')
            showIndent(outfile, level)
            outfile.write('rhi=%s,\n' % (self.rhi,))
        if self.dz is not None and 'dz' not in already_processed:
            already_processed.add('dz')
            showIndent(outfile, level)
            outfile.write('dz=%s,\n' % (self.dz,))
        super(paraboloid, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(paraboloid, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rlo', node)
        if value is not None and 'rlo' not in already_processed:
            already_processed.add('rlo')
            self.rlo = value
            self.validate_ExpressionOrIDREFType(self.rlo)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rhi', node)
        if value is not None and 'rhi' not in already_processed:
            already_processed.add('rhi')
            self.rhi = value
            self.validate_ExpressionOrIDREFType(self.rhi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('dz', node)
        if value is not None and 'dz' not in already_processed:
            already_processed.add('dz')
            self.dz = value
            self.validate_ExpressionOrIDREFType(self.dz)    # validate type ExpressionOrIDREFType
        super(paraboloid, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(paraboloid, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class paraboloid


class sphere(SolidType):
    """CSG sphere or spherical shell segment solid described by
    rmin inner radius
    rmax outer radius
    startphi starting angle of the segment in radians(0 <= phi <= 2*PI)
    deltaphi delta angle of the segment in radians
    starttheta starting angle of the segment in radians(0 <= theta <= PI)
    deltatheta delta angle of the segment in radians"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, rmin='0.0', rmax=None, startphi='0.0', deltaphi=None, starttheta='0.0', deltatheta=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(sphere, self).__init__(lunit, aunit, name,  **kwargs_)
        self.rmin = _cast(None, rmin)
        self.rmin_nsprefix_ = None
        self.rmax = _cast(None, rmax)
        self.rmax_nsprefix_ = None
        self.startphi = _cast(None, startphi)
        self.startphi_nsprefix_ = None
        self.deltaphi = _cast(None, deltaphi)
        self.deltaphi_nsprefix_ = None
        self.starttheta = _cast(None, starttheta)
        self.starttheta_nsprefix_ = None
        self.deltatheta = _cast(None, deltatheta)
        self.deltatheta_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sphere)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sphere.subclass:
            return sphere.subclass(*args_, **kwargs_)
        else:
            return sphere(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_rmin(self):
        return self.rmin
    def set_rmin(self, rmin):
        self.rmin = rmin
    rminProp = property(get_rmin, set_rmin)
    def get_rmax(self):
        return self.rmax
    def set_rmax(self, rmax):
        self.rmax = rmax
    rmaxProp = property(get_rmax, set_rmax)
    def get_startphi(self):
        return self.startphi
    def set_startphi(self, startphi):
        self.startphi = startphi
    startphiProp = property(get_startphi, set_startphi)
    def get_deltaphi(self):
        return self.deltaphi
    def set_deltaphi(self, deltaphi):
        self.deltaphi = deltaphi
    deltaphiProp = property(get_deltaphi, set_deltaphi)
    def get_starttheta(self):
        return self.starttheta
    def set_starttheta(self, starttheta):
        self.starttheta = starttheta
    startthetaProp = property(get_starttheta, set_starttheta)
    def get_deltatheta(self):
        return self.deltatheta
    def set_deltatheta(self, deltatheta):
        self.deltatheta = deltatheta
    deltathetaProp = property(get_deltatheta, set_deltatheta)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(sphere, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='sphere', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sphere')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'sphere':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='sphere')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='sphere', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='sphere'):
        super(sphere, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='sphere')
        if self.rmin != "0.0" and 'rmin' not in already_processed:
            already_processed.add('rmin')
            outfile.write(' rmin=%s' % (quote_attrib(self.rmin), ))
        if self.rmax is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            outfile.write(' rmax=%s' % (quote_attrib(self.rmax), ))
        if self.startphi != "0.0" and 'startphi' not in already_processed:
            already_processed.add('startphi')
            outfile.write(' startphi=%s' % (quote_attrib(self.startphi), ))
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            outfile.write(' deltaphi=%s' % (quote_attrib(self.deltaphi), ))
        if self.starttheta != "0.0" and 'starttheta' not in already_processed:
            already_processed.add('starttheta')
            outfile.write(' starttheta=%s' % (quote_attrib(self.starttheta), ))
        if self.deltatheta is not None and 'deltatheta' not in already_processed:
            already_processed.add('deltatheta')
            outfile.write(' deltatheta=%s' % (quote_attrib(self.deltatheta), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='sphere', fromsubclass_=False, pretty_print=True):
        super(sphere, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='sphere', mapping_=None, nsmap_=None):
        element = super(sphere, self).to_etree(parent_element, name_, mapping_)
        if self.rmin is not None:
            element.set('rmin', self.rmin)
        if self.rmax is not None:
            element.set('rmax', self.rmax)
        if self.startphi is not None:
            element.set('startphi', self.startphi)
        if self.deltaphi is not None:
            element.set('deltaphi', self.deltaphi)
        if self.starttheta is not None:
            element.set('starttheta', self.starttheta)
        if self.deltatheta is not None:
            element.set('deltatheta', self.deltatheta)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='sphere'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rmin is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            showIndent(outfile, level)
            outfile.write('rmin=%s,\n' % (self.rmin,))
        if self.rmax is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            showIndent(outfile, level)
            outfile.write('rmax=%s,\n' % (self.rmax,))
        if self.startphi is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            showIndent(outfile, level)
            outfile.write('startphi=%s,\n' % (self.startphi,))
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            showIndent(outfile, level)
            outfile.write('deltaphi=%s,\n' % (self.deltaphi,))
        if self.starttheta is not None and 'starttheta' not in already_processed:
            already_processed.add('starttheta')
            showIndent(outfile, level)
            outfile.write('starttheta=%s,\n' % (self.starttheta,))
        if self.deltatheta is not None and 'deltatheta' not in already_processed:
            already_processed.add('deltatheta')
            showIndent(outfile, level)
            outfile.write('deltatheta=%s,\n' % (self.deltatheta,))
        super(sphere, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(sphere, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rmin', node)
        if value is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            self.rmin = value
            self.validate_ExpressionOrIDREFType(self.rmin)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmax', node)
        if value is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            self.rmax = value
            self.validate_ExpressionOrIDREFType(self.rmax)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('startphi', node)
        if value is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            self.startphi = value
            self.validate_ExpressionOrIDREFType(self.startphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('deltaphi', node)
        if value is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            self.deltaphi = value
            self.validate_ExpressionOrIDREFType(self.deltaphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('starttheta', node)
        if value is not None and 'starttheta' not in already_processed:
            already_processed.add('starttheta')
            self.starttheta = value
            self.validate_ExpressionOrIDREFType(self.starttheta)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('deltatheta', node)
        if value is not None and 'deltatheta' not in already_processed:
            already_processed.add('deltatheta')
            self.deltatheta = value
            self.validate_ExpressionOrIDREFType(self.deltatheta)    # validate type ExpressionOrIDREFType
        super(sphere, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(sphere, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class sphere


class ellipsoid(SolidType):
    """CSG ellispoid or ellipsoidal shell segment solid described by
    ax x semiaxis
    by y semiaxis
    cz z semiaxis
    zcut1 bottom plane cutting ellipsoid
    zcut2 top plane cutting ellispoid"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, ax=None, by=None, cz=None, zcut1='-1000000.0', zcut2='1000000.0', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ellipsoid, self).__init__(lunit, aunit, name,  **kwargs_)
        self.ax = _cast(None, ax)
        self.ax_nsprefix_ = None
        self.by = _cast(None, by)
        self.by_nsprefix_ = None
        self.cz = _cast(None, cz)
        self.cz_nsprefix_ = None
        self.zcut1 = _cast(None, zcut1)
        self.zcut1_nsprefix_ = None
        self.zcut2 = _cast(None, zcut2)
        self.zcut2_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ellipsoid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ellipsoid.subclass:
            return ellipsoid.subclass(*args_, **kwargs_)
        else:
            return ellipsoid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ax(self):
        return self.ax
    def set_ax(self, ax):
        self.ax = ax
    axProp = property(get_ax, set_ax)
    def get_by(self):
        return self.by
    def set_by(self, by):
        self.by = by
    byProp = property(get_by, set_by)
    def get_cz(self):
        return self.cz
    def set_cz(self, cz):
        self.cz = cz
    czProp = property(get_cz, set_cz)
    def get_zcut1(self):
        return self.zcut1
    def set_zcut1(self, zcut1):
        self.zcut1 = zcut1
    zcut1Prop = property(get_zcut1, set_zcut1)
    def get_zcut2(self):
        return self.zcut2
    def set_zcut2(self, zcut2):
        self.zcut2 = zcut2
    zcut2Prop = property(get_zcut2, set_zcut2)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(ellipsoid, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ellipsoid', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ellipsoid')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ellipsoid':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ellipsoid')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ellipsoid', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ellipsoid'):
        super(ellipsoid, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ellipsoid')
        if self.ax is not None and 'ax' not in already_processed:
            already_processed.add('ax')
            outfile.write(' ax=%s' % (quote_attrib(self.ax), ))
        if self.by is not None and 'by' not in already_processed:
            already_processed.add('by')
            outfile.write(' by=%s' % (quote_attrib(self.by), ))
        if self.cz is not None and 'cz' not in already_processed:
            already_processed.add('cz')
            outfile.write(' cz=%s' % (quote_attrib(self.cz), ))
        if self.zcut1 != "-1000000.0" and 'zcut1' not in already_processed:
            already_processed.add('zcut1')
            outfile.write(' zcut1=%s' % (quote_attrib(self.zcut1), ))
        if self.zcut2 != "1000000.0" and 'zcut2' not in already_processed:
            already_processed.add('zcut2')
            outfile.write(' zcut2=%s' % (quote_attrib(self.zcut2), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ellipsoid', fromsubclass_=False, pretty_print=True):
        super(ellipsoid, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='ellipsoid', mapping_=None, nsmap_=None):
        element = super(ellipsoid, self).to_etree(parent_element, name_, mapping_)
        if self.ax is not None:
            element.set('ax', self.ax)
        if self.by is not None:
            element.set('by', self.by)
        if self.cz is not None:
            element.set('cz', self.cz)
        if self.zcut1 is not None:
            element.set('zcut1', self.zcut1)
        if self.zcut2 is not None:
            element.set('zcut2', self.zcut2)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ellipsoid'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ax is not None and 'ax' not in already_processed:
            already_processed.add('ax')
            showIndent(outfile, level)
            outfile.write('ax=%s,\n' % (self.ax,))
        if self.by is not None and 'by' not in already_processed:
            already_processed.add('by')
            showIndent(outfile, level)
            outfile.write('by=%s,\n' % (self.by,))
        if self.cz is not None and 'cz' not in already_processed:
            already_processed.add('cz')
            showIndent(outfile, level)
            outfile.write('cz=%s,\n' % (self.cz,))
        if self.zcut1 is not None and 'zcut1' not in already_processed:
            already_processed.add('zcut1')
            showIndent(outfile, level)
            outfile.write('zcut1=%s,\n' % (self.zcut1,))
        if self.zcut2 is not None and 'zcut2' not in already_processed:
            already_processed.add('zcut2')
            showIndent(outfile, level)
            outfile.write('zcut2=%s,\n' % (self.zcut2,))
        super(ellipsoid, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ellipsoid, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ax', node)
        if value is not None and 'ax' not in already_processed:
            already_processed.add('ax')
            self.ax = value
            self.validate_ExpressionOrIDREFType(self.ax)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('by', node)
        if value is not None and 'by' not in already_processed:
            already_processed.add('by')
            self.by = value
            self.validate_ExpressionOrIDREFType(self.by)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('cz', node)
        if value is not None and 'cz' not in already_processed:
            already_processed.add('cz')
            self.cz = value
            self.validate_ExpressionOrIDREFType(self.cz)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('zcut1', node)
        if value is not None and 'zcut1' not in already_processed:
            already_processed.add('zcut1')
            self.zcut1 = value
            self.validate_ExpressionOrIDREFType(self.zcut1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('zcut2', node)
        if value is not None and 'zcut2' not in already_processed:
            already_processed.add('zcut2')
            self.zcut2 = value
            self.validate_ExpressionOrIDREFType(self.zcut2)    # validate type ExpressionOrIDREFType
        super(ellipsoid, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ellipsoid, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ellipsoid


class tube(SolidType):
    """CSG tube or tube segement solid described by
    rmin Inner radius
    rmax Outer radius
    z length in z
    startphi The starting phi angle in radians, adjusted such that
    (startphi+deltaphi <= 2PI, startphi > -2PI)
    deltaphi Delta angle of the segment in radians"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, z=None, rmin='0.0', rmax=None, startphi='0.0', deltaphi=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(tube, self).__init__(lunit, aunit, name,  **kwargs_)
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.rmin = _cast(None, rmin)
        self.rmin_nsprefix_ = None
        self.rmax = _cast(None, rmax)
        self.rmax_nsprefix_ = None
        self.startphi = _cast(None, startphi)
        self.startphi_nsprefix_ = None
        self.deltaphi = _cast(None, deltaphi)
        self.deltaphi_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tube)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tube.subclass:
            return tube.subclass(*args_, **kwargs_)
        else:
            return tube(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_rmin(self):
        return self.rmin
    def set_rmin(self, rmin):
        self.rmin = rmin
    rminProp = property(get_rmin, set_rmin)
    def get_rmax(self):
        return self.rmax
    def set_rmax(self, rmax):
        self.rmax = rmax
    rmaxProp = property(get_rmax, set_rmax)
    def get_startphi(self):
        return self.startphi
    def set_startphi(self, startphi):
        self.startphi = startphi
    startphiProp = property(get_startphi, set_startphi)
    def get_deltaphi(self):
        return self.deltaphi
    def set_deltaphi(self, deltaphi):
        self.deltaphi = deltaphi
    deltaphiProp = property(get_deltaphi, set_deltaphi)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(tube, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tube', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tube')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tube':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tube')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tube', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tube'):
        super(tube, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tube')
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.rmin != "0.0" and 'rmin' not in already_processed:
            already_processed.add('rmin')
            outfile.write(' rmin=%s' % (quote_attrib(self.rmin), ))
        if self.rmax is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            outfile.write(' rmax=%s' % (quote_attrib(self.rmax), ))
        if self.startphi != "0.0" and 'startphi' not in already_processed:
            already_processed.add('startphi')
            outfile.write(' startphi=%s' % (quote_attrib(self.startphi), ))
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            outfile.write(' deltaphi=%s' % (quote_attrib(self.deltaphi), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tube', fromsubclass_=False, pretty_print=True):
        super(tube, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='tube', mapping_=None, nsmap_=None):
        element = super(tube, self).to_etree(parent_element, name_, mapping_)
        if self.z is not None:
            element.set('z', self.z)
        if self.rmin is not None:
            element.set('rmin', self.rmin)
        if self.rmax is not None:
            element.set('rmax', self.rmax)
        if self.startphi is not None:
            element.set('startphi', self.startphi)
        if self.deltaphi is not None:
            element.set('deltaphi', self.deltaphi)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='tube'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        if self.rmin is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            showIndent(outfile, level)
            outfile.write('rmin=%s,\n' % (self.rmin,))
        if self.rmax is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            showIndent(outfile, level)
            outfile.write('rmax=%s,\n' % (self.rmax,))
        if self.startphi is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            showIndent(outfile, level)
            outfile.write('startphi=%s,\n' % (self.startphi,))
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            showIndent(outfile, level)
            outfile.write('deltaphi=%s,\n' % (self.deltaphi,))
        super(tube, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(tube, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmin', node)
        if value is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            self.rmin = value
            self.validate_ExpressionOrIDREFType(self.rmin)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmax', node)
        if value is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            self.rmax = value
            self.validate_ExpressionOrIDREFType(self.rmax)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('startphi', node)
        if value is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            self.startphi = value
            self.validate_ExpressionOrIDREFType(self.startphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('deltaphi', node)
        if value is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            self.deltaphi = value
            self.validate_ExpressionOrIDREFType(self.deltaphi)    # validate type ExpressionOrIDREFType
        super(tube, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(tube, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tube


class twistedtubs(SolidType):
    """CSG twisted tube segment solid described by
    twistedangle twist angle (constructors 1,2,3,4)
    endinnerrad inside radius at end of segment (constructors 1,2)
    endouterrad outside radius at end of segment (constructors 1,2)
    midinnerrad inner radius at z=0 (constructors 3,4)
    midouterrad outer radius at z=0 (constructors 3,4)
    negativeEndz -ve z endplate (constructors 3,4)
    positiveEndz +ve z endplate (constructors 3,4)
    zlen z length of segment (constructors 1,2)
    nseg number of segments in totalPhi (constructors 2,4)
    totphi total angle of all segments (constructors 2,4)
    phi phi angle of a segment (constructors 1,3)"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, twistedangle=None, endinnerrad='0.0', endouterrad='0.0', midinnerrad='0.0', midouterrad='0.0', negativeEndz='0.0', positiveEndz='0.0', zlen='0.0', nseg='0', totphi='0.0', phi='0.0', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(twistedtubs, self).__init__(lunit, aunit, name,  **kwargs_)
        self.twistedangle = _cast(None, twistedangle)
        self.twistedangle_nsprefix_ = None
        self.endinnerrad = _cast(None, endinnerrad)
        self.endinnerrad_nsprefix_ = None
        self.endouterrad = _cast(None, endouterrad)
        self.endouterrad_nsprefix_ = None
        self.midinnerrad = _cast(None, midinnerrad)
        self.midinnerrad_nsprefix_ = None
        self.midouterrad = _cast(None, midouterrad)
        self.midouterrad_nsprefix_ = None
        self.negativeEndz = _cast(None, negativeEndz)
        self.negativeEndz_nsprefix_ = None
        self.positiveEndz = _cast(None, positiveEndz)
        self.positiveEndz_nsprefix_ = None
        self.zlen = _cast(None, zlen)
        self.zlen_nsprefix_ = None
        self.nseg = _cast(None, nseg)
        self.nseg_nsprefix_ = None
        self.totphi = _cast(None, totphi)
        self.totphi_nsprefix_ = None
        self.phi = _cast(None, phi)
        self.phi_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, twistedtubs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if twistedtubs.subclass:
            return twistedtubs.subclass(*args_, **kwargs_)
        else:
            return twistedtubs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_twistedangle(self):
        return self.twistedangle
    def set_twistedangle(self, twistedangle):
        self.twistedangle = twistedangle
    twistedangleProp = property(get_twistedangle, set_twistedangle)
    def get_endinnerrad(self):
        return self.endinnerrad
    def set_endinnerrad(self, endinnerrad):
        self.endinnerrad = endinnerrad
    endinnerradProp = property(get_endinnerrad, set_endinnerrad)
    def get_endouterrad(self):
        return self.endouterrad
    def set_endouterrad(self, endouterrad):
        self.endouterrad = endouterrad
    endouterradProp = property(get_endouterrad, set_endouterrad)
    def get_midinnerrad(self):
        return self.midinnerrad
    def set_midinnerrad(self, midinnerrad):
        self.midinnerrad = midinnerrad
    midinnerradProp = property(get_midinnerrad, set_midinnerrad)
    def get_midouterrad(self):
        return self.midouterrad
    def set_midouterrad(self, midouterrad):
        self.midouterrad = midouterrad
    midouterradProp = property(get_midouterrad, set_midouterrad)
    def get_negativeEndz(self):
        return self.negativeEndz
    def set_negativeEndz(self, negativeEndz):
        self.negativeEndz = negativeEndz
    negativeEndzProp = property(get_negativeEndz, set_negativeEndz)
    def get_positiveEndz(self):
        return self.positiveEndz
    def set_positiveEndz(self, positiveEndz):
        self.positiveEndz = positiveEndz
    positiveEndzProp = property(get_positiveEndz, set_positiveEndz)
    def get_zlen(self):
        return self.zlen
    def set_zlen(self, zlen):
        self.zlen = zlen
    zlenProp = property(get_zlen, set_zlen)
    def get_nseg(self):
        return self.nseg
    def set_nseg(self, nseg):
        self.nseg = nseg
    nsegProp = property(get_nseg, set_nseg)
    def get_totphi(self):
        return self.totphi
    def set_totphi(self, totphi):
        self.totphi = totphi
    totphiProp = property(get_totphi, set_totphi)
    def get_phi(self):
        return self.phi
    def set_phi(self, phi):
        self.phi = phi
    phiProp = property(get_phi, set_phi)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(twistedtubs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='twistedtubs', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('twistedtubs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'twistedtubs':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='twistedtubs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='twistedtubs', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='twistedtubs'):
        super(twistedtubs, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='twistedtubs')
        if self.twistedangle is not None and 'twistedangle' not in already_processed:
            already_processed.add('twistedangle')
            outfile.write(' twistedangle=%s' % (quote_attrib(self.twistedangle), ))
        if self.endinnerrad != "0.0" and 'endinnerrad' not in already_processed:
            already_processed.add('endinnerrad')
            outfile.write(' endinnerrad=%s' % (quote_attrib(self.endinnerrad), ))
        if self.endouterrad != "0.0" and 'endouterrad' not in already_processed:
            already_processed.add('endouterrad')
            outfile.write(' endouterrad=%s' % (quote_attrib(self.endouterrad), ))
        if self.midinnerrad != "0.0" and 'midinnerrad' not in already_processed:
            already_processed.add('midinnerrad')
            outfile.write(' midinnerrad=%s' % (quote_attrib(self.midinnerrad), ))
        if self.midouterrad != "0.0" and 'midouterrad' not in already_processed:
            already_processed.add('midouterrad')
            outfile.write(' midouterrad=%s' % (quote_attrib(self.midouterrad), ))
        if self.negativeEndz != "0.0" and 'negativeEndz' not in already_processed:
            already_processed.add('negativeEndz')
            outfile.write(' negativeEndz=%s' % (quote_attrib(self.negativeEndz), ))
        if self.positiveEndz != "0.0" and 'positiveEndz' not in already_processed:
            already_processed.add('positiveEndz')
            outfile.write(' positiveEndz=%s' % (quote_attrib(self.positiveEndz), ))
        if self.zlen != "0.0" and 'zlen' not in already_processed:
            already_processed.add('zlen')
            outfile.write(' zlen=%s' % (quote_attrib(self.zlen), ))
        if self.nseg != "0" and 'nseg' not in already_processed:
            already_processed.add('nseg')
            outfile.write(' nseg=%s' % (quote_attrib(self.nseg), ))
        if self.totphi != "0.0" and 'totphi' not in already_processed:
            already_processed.add('totphi')
            outfile.write(' totphi=%s' % (quote_attrib(self.totphi), ))
        if self.phi != "0.0" and 'phi' not in already_processed:
            already_processed.add('phi')
            outfile.write(' phi=%s' % (quote_attrib(self.phi), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='twistedtubs', fromsubclass_=False, pretty_print=True):
        super(twistedtubs, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='twistedtubs', mapping_=None, nsmap_=None):
        element = super(twistedtubs, self).to_etree(parent_element, name_, mapping_)
        if self.twistedangle is not None:
            element.set('twistedangle', self.twistedangle)
        if self.endinnerrad is not None:
            element.set('endinnerrad', self.endinnerrad)
        if self.endouterrad is not None:
            element.set('endouterrad', self.endouterrad)
        if self.midinnerrad is not None:
            element.set('midinnerrad', self.midinnerrad)
        if self.midouterrad is not None:
            element.set('midouterrad', self.midouterrad)
        if self.negativeEndz is not None:
            element.set('negativeEndz', self.negativeEndz)
        if self.positiveEndz is not None:
            element.set('positiveEndz', self.positiveEndz)
        if self.zlen is not None:
            element.set('zlen', self.zlen)
        if self.nseg is not None:
            element.set('nseg', self.nseg)
        if self.totphi is not None:
            element.set('totphi', self.totphi)
        if self.phi is not None:
            element.set('phi', self.phi)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='twistedtubs'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.twistedangle is not None and 'twistedangle' not in already_processed:
            already_processed.add('twistedangle')
            showIndent(outfile, level)
            outfile.write('twistedangle=%s,\n' % (self.twistedangle,))
        if self.endinnerrad is not None and 'endinnerrad' not in already_processed:
            already_processed.add('endinnerrad')
            showIndent(outfile, level)
            outfile.write('endinnerrad=%s,\n' % (self.endinnerrad,))
        if self.endouterrad is not None and 'endouterrad' not in already_processed:
            already_processed.add('endouterrad')
            showIndent(outfile, level)
            outfile.write('endouterrad=%s,\n' % (self.endouterrad,))
        if self.midinnerrad is not None and 'midinnerrad' not in already_processed:
            already_processed.add('midinnerrad')
            showIndent(outfile, level)
            outfile.write('midinnerrad=%s,\n' % (self.midinnerrad,))
        if self.midouterrad is not None and 'midouterrad' not in already_processed:
            already_processed.add('midouterrad')
            showIndent(outfile, level)
            outfile.write('midouterrad=%s,\n' % (self.midouterrad,))
        if self.negativeEndz is not None and 'negativeEndz' not in already_processed:
            already_processed.add('negativeEndz')
            showIndent(outfile, level)
            outfile.write('negativeEndz=%s,\n' % (self.negativeEndz,))
        if self.positiveEndz is not None and 'positiveEndz' not in already_processed:
            already_processed.add('positiveEndz')
            showIndent(outfile, level)
            outfile.write('positiveEndz=%s,\n' % (self.positiveEndz,))
        if self.zlen is not None and 'zlen' not in already_processed:
            already_processed.add('zlen')
            showIndent(outfile, level)
            outfile.write('zlen=%s,\n' % (self.zlen,))
        if self.nseg is not None and 'nseg' not in already_processed:
            already_processed.add('nseg')
            showIndent(outfile, level)
            outfile.write('nseg=%s,\n' % (self.nseg,))
        if self.totphi is not None and 'totphi' not in already_processed:
            already_processed.add('totphi')
            showIndent(outfile, level)
            outfile.write('totphi=%s,\n' % (self.totphi,))
        if self.phi is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            showIndent(outfile, level)
            outfile.write('phi=%s,\n' % (self.phi,))
        super(twistedtubs, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(twistedtubs, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('twistedangle', node)
        if value is not None and 'twistedangle' not in already_processed:
            already_processed.add('twistedangle')
            self.twistedangle = value
            self.validate_ExpressionOrIDREFType(self.twistedangle)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('endinnerrad', node)
        if value is not None and 'endinnerrad' not in already_processed:
            already_processed.add('endinnerrad')
            self.endinnerrad = value
            self.validate_ExpressionOrIDREFType(self.endinnerrad)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('endouterrad', node)
        if value is not None and 'endouterrad' not in already_processed:
            already_processed.add('endouterrad')
            self.endouterrad = value
            self.validate_ExpressionOrIDREFType(self.endouterrad)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('midinnerrad', node)
        if value is not None and 'midinnerrad' not in already_processed:
            already_processed.add('midinnerrad')
            self.midinnerrad = value
            self.validate_ExpressionOrIDREFType(self.midinnerrad)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('midouterrad', node)
        if value is not None and 'midouterrad' not in already_processed:
            already_processed.add('midouterrad')
            self.midouterrad = value
            self.validate_ExpressionOrIDREFType(self.midouterrad)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('negativeEndz', node)
        if value is not None and 'negativeEndz' not in already_processed:
            already_processed.add('negativeEndz')
            self.negativeEndz = value
            self.validate_ExpressionOrIDREFType(self.negativeEndz)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('positiveEndz', node)
        if value is not None and 'positiveEndz' not in already_processed:
            already_processed.add('positiveEndz')
            self.positiveEndz = value
            self.validate_ExpressionOrIDREFType(self.positiveEndz)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('zlen', node)
        if value is not None and 'zlen' not in already_processed:
            already_processed.add('zlen')
            self.zlen = value
            self.validate_ExpressionOrIDREFType(self.zlen)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('nseg', node)
        if value is not None and 'nseg' not in already_processed:
            already_processed.add('nseg')
            self.nseg = value
            self.validate_ExpressionOrIDREFType(self.nseg)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('totphi', node)
        if value is not None and 'totphi' not in already_processed:
            already_processed.add('totphi')
            self.totphi = value
            self.validate_ExpressionOrIDREFType(self.totphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('phi', node)
        if value is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            self.phi = value
            self.validate_ExpressionOrIDREFType(self.phi)    # validate type ExpressionOrIDREFType
        super(twistedtubs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(twistedtubs, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class twistedtubs


class cutTube(SolidType):
    """CSG cut tube or cut tube segment solid described by
    rmin Inner radius
    rmax Outer radius
    z length in z
    startphi The starting phi angle in radians, adjusted such that
    (startphi+deltaphi <= 2PI, startphi > -2PI)
    deltaphi Delta angle of the segment in radians
    lowX, lowY, lowZ Normal at lower Z plane
    highX, highY, highZ Normal at higher Z plane"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, z=None, rmin='0.0', rmax=None, startphi='0.0', deltaphi=None, lowX=None, lowY=None, lowZ=None, highX=None, highY=None, highZ=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(cutTube, self).__init__(lunit, aunit, name,  **kwargs_)
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.rmin = _cast(None, rmin)
        self.rmin_nsprefix_ = None
        self.rmax = _cast(None, rmax)
        self.rmax_nsprefix_ = None
        self.startphi = _cast(None, startphi)
        self.startphi_nsprefix_ = None
        self.deltaphi = _cast(None, deltaphi)
        self.deltaphi_nsprefix_ = None
        self.lowX = _cast(None, lowX)
        self.lowX_nsprefix_ = None
        self.lowY = _cast(None, lowY)
        self.lowY_nsprefix_ = None
        self.lowZ = _cast(None, lowZ)
        self.lowZ_nsprefix_ = None
        self.highX = _cast(None, highX)
        self.highX_nsprefix_ = None
        self.highY = _cast(None, highY)
        self.highY_nsprefix_ = None
        self.highZ = _cast(None, highZ)
        self.highZ_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cutTube)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cutTube.subclass:
            return cutTube.subclass(*args_, **kwargs_)
        else:
            return cutTube(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_rmin(self):
        return self.rmin
    def set_rmin(self, rmin):
        self.rmin = rmin
    rminProp = property(get_rmin, set_rmin)
    def get_rmax(self):
        return self.rmax
    def set_rmax(self, rmax):
        self.rmax = rmax
    rmaxProp = property(get_rmax, set_rmax)
    def get_startphi(self):
        return self.startphi
    def set_startphi(self, startphi):
        self.startphi = startphi
    startphiProp = property(get_startphi, set_startphi)
    def get_deltaphi(self):
        return self.deltaphi
    def set_deltaphi(self, deltaphi):
        self.deltaphi = deltaphi
    deltaphiProp = property(get_deltaphi, set_deltaphi)
    def get_lowX(self):
        return self.lowX
    def set_lowX(self, lowX):
        self.lowX = lowX
    lowXProp = property(get_lowX, set_lowX)
    def get_lowY(self):
        return self.lowY
    def set_lowY(self, lowY):
        self.lowY = lowY
    lowYProp = property(get_lowY, set_lowY)
    def get_lowZ(self):
        return self.lowZ
    def set_lowZ(self, lowZ):
        self.lowZ = lowZ
    lowZProp = property(get_lowZ, set_lowZ)
    def get_highX(self):
        return self.highX
    def set_highX(self, highX):
        self.highX = highX
    highXProp = property(get_highX, set_highX)
    def get_highY(self):
        return self.highY
    def set_highY(self, highY):
        self.highY = highY
    highYProp = property(get_highY, set_highY)
    def get_highZ(self):
        return self.highZ
    def set_highZ(self, highZ):
        self.highZ = highZ
    highZProp = property(get_highZ, set_highZ)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(cutTube, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cutTube', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cutTube')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cutTube':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cutTube')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cutTube', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cutTube'):
        super(cutTube, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cutTube')
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.rmin != "0.0" and 'rmin' not in already_processed:
            already_processed.add('rmin')
            outfile.write(' rmin=%s' % (quote_attrib(self.rmin), ))
        if self.rmax is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            outfile.write(' rmax=%s' % (quote_attrib(self.rmax), ))
        if self.startphi != "0.0" and 'startphi' not in already_processed:
            already_processed.add('startphi')
            outfile.write(' startphi=%s' % (quote_attrib(self.startphi), ))
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            outfile.write(' deltaphi=%s' % (quote_attrib(self.deltaphi), ))
        if self.lowX is not None and 'lowX' not in already_processed:
            already_processed.add('lowX')
            outfile.write(' lowX=%s' % (quote_attrib(self.lowX), ))
        if self.lowY is not None and 'lowY' not in already_processed:
            already_processed.add('lowY')
            outfile.write(' lowY=%s' % (quote_attrib(self.lowY), ))
        if self.lowZ is not None and 'lowZ' not in already_processed:
            already_processed.add('lowZ')
            outfile.write(' lowZ=%s' % (quote_attrib(self.lowZ), ))
        if self.highX is not None and 'highX' not in already_processed:
            already_processed.add('highX')
            outfile.write(' highX=%s' % (quote_attrib(self.highX), ))
        if self.highY is not None and 'highY' not in already_processed:
            already_processed.add('highY')
            outfile.write(' highY=%s' % (quote_attrib(self.highY), ))
        if self.highZ is not None and 'highZ' not in already_processed:
            already_processed.add('highZ')
            outfile.write(' highZ=%s' % (quote_attrib(self.highZ), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cutTube', fromsubclass_=False, pretty_print=True):
        super(cutTube, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='cutTube', mapping_=None, nsmap_=None):
        element = super(cutTube, self).to_etree(parent_element, name_, mapping_)
        if self.z is not None:
            element.set('z', self.z)
        if self.rmin is not None:
            element.set('rmin', self.rmin)
        if self.rmax is not None:
            element.set('rmax', self.rmax)
        if self.startphi is not None:
            element.set('startphi', self.startphi)
        if self.deltaphi is not None:
            element.set('deltaphi', self.deltaphi)
        if self.lowX is not None:
            element.set('lowX', self.lowX)
        if self.lowY is not None:
            element.set('lowY', self.lowY)
        if self.lowZ is not None:
            element.set('lowZ', self.lowZ)
        if self.highX is not None:
            element.set('highX', self.highX)
        if self.highY is not None:
            element.set('highY', self.highY)
        if self.highZ is not None:
            element.set('highZ', self.highZ)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='cutTube'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        if self.rmin is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            showIndent(outfile, level)
            outfile.write('rmin=%s,\n' % (self.rmin,))
        if self.rmax is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            showIndent(outfile, level)
            outfile.write('rmax=%s,\n' % (self.rmax,))
        if self.startphi is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            showIndent(outfile, level)
            outfile.write('startphi=%s,\n' % (self.startphi,))
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            showIndent(outfile, level)
            outfile.write('deltaphi=%s,\n' % (self.deltaphi,))
        if self.lowX is not None and 'lowX' not in already_processed:
            already_processed.add('lowX')
            showIndent(outfile, level)
            outfile.write('lowX=%s,\n' % (self.lowX,))
        if self.lowY is not None and 'lowY' not in already_processed:
            already_processed.add('lowY')
            showIndent(outfile, level)
            outfile.write('lowY=%s,\n' % (self.lowY,))
        if self.lowZ is not None and 'lowZ' not in already_processed:
            already_processed.add('lowZ')
            showIndent(outfile, level)
            outfile.write('lowZ=%s,\n' % (self.lowZ,))
        if self.highX is not None and 'highX' not in already_processed:
            already_processed.add('highX')
            showIndent(outfile, level)
            outfile.write('highX=%s,\n' % (self.highX,))
        if self.highY is not None and 'highY' not in already_processed:
            already_processed.add('highY')
            showIndent(outfile, level)
            outfile.write('highY=%s,\n' % (self.highY,))
        if self.highZ is not None and 'highZ' not in already_processed:
            already_processed.add('highZ')
            showIndent(outfile, level)
            outfile.write('highZ=%s,\n' % (self.highZ,))
        super(cutTube, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(cutTube, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmin', node)
        if value is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            self.rmin = value
            self.validate_ExpressionOrIDREFType(self.rmin)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmax', node)
        if value is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            self.rmax = value
            self.validate_ExpressionOrIDREFType(self.rmax)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('startphi', node)
        if value is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            self.startphi = value
            self.validate_ExpressionOrIDREFType(self.startphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('deltaphi', node)
        if value is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            self.deltaphi = value
            self.validate_ExpressionOrIDREFType(self.deltaphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('lowX', node)
        if value is not None and 'lowX' not in already_processed:
            already_processed.add('lowX')
            self.lowX = value
            self.validate_ExpressionOrIDREFType(self.lowX)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('lowY', node)
        if value is not None and 'lowY' not in already_processed:
            already_processed.add('lowY')
            self.lowY = value
            self.validate_ExpressionOrIDREFType(self.lowY)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('lowZ', node)
        if value is not None and 'lowZ' not in already_processed:
            already_processed.add('lowZ')
            self.lowZ = value
            self.validate_ExpressionOrIDREFType(self.lowZ)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('highX', node)
        if value is not None and 'highX' not in already_processed:
            already_processed.add('highX')
            self.highX = value
            self.validate_ExpressionOrIDREFType(self.highX)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('highY', node)
        if value is not None and 'highY' not in already_processed:
            already_processed.add('highY')
            self.highY = value
            self.validate_ExpressionOrIDREFType(self.highY)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('highZ', node)
        if value is not None and 'highZ' not in already_processed:
            already_processed.add('highZ')
            self.highZ = value
            self.validate_ExpressionOrIDREFType(self.highZ)    # validate type ExpressionOrIDREFType
        super(cutTube, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(cutTube, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class cutTube


class cone(SolidType):
    """CSG cone or cone segment described by
    rmin1 inside radius at z/2
    rmin2 inside radius at z/2
    rmax1 outside radius at z/2
    rmax2 outside radius at z/2
    z length in z
    startphi starting angle of the segment in radians
    deltaphi delta angle of the segment in radians"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, z=None, rmin1='0.0', rmin2='0.0', rmax1=None, rmax2=None, startphi='0.0', deltaphi=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(cone, self).__init__(lunit, aunit, name,  **kwargs_)
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.rmin1 = _cast(None, rmin1)
        self.rmin1_nsprefix_ = None
        self.rmin2 = _cast(None, rmin2)
        self.rmin2_nsprefix_ = None
        self.rmax1 = _cast(None, rmax1)
        self.rmax1_nsprefix_ = None
        self.rmax2 = _cast(None, rmax2)
        self.rmax2_nsprefix_ = None
        self.startphi = _cast(None, startphi)
        self.startphi_nsprefix_ = None
        self.deltaphi = _cast(None, deltaphi)
        self.deltaphi_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cone.subclass:
            return cone.subclass(*args_, **kwargs_)
        else:
            return cone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_rmin1(self):
        return self.rmin1
    def set_rmin1(self, rmin1):
        self.rmin1 = rmin1
    rmin1Prop = property(get_rmin1, set_rmin1)
    def get_rmin2(self):
        return self.rmin2
    def set_rmin2(self, rmin2):
        self.rmin2 = rmin2
    rmin2Prop = property(get_rmin2, set_rmin2)
    def get_rmax1(self):
        return self.rmax1
    def set_rmax1(self, rmax1):
        self.rmax1 = rmax1
    rmax1Prop = property(get_rmax1, set_rmax1)
    def get_rmax2(self):
        return self.rmax2
    def set_rmax2(self, rmax2):
        self.rmax2 = rmax2
    rmax2Prop = property(get_rmax2, set_rmax2)
    def get_startphi(self):
        return self.startphi
    def set_startphi(self, startphi):
        self.startphi = startphi
    startphiProp = property(get_startphi, set_startphi)
    def get_deltaphi(self):
        return self.deltaphi
    def set_deltaphi(self, deltaphi):
        self.deltaphi = deltaphi
    deltaphiProp = property(get_deltaphi, set_deltaphi)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(cone, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cone', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cone')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cone':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cone', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cone'):
        super(cone, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cone')
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.rmin1 != "0.0" and 'rmin1' not in already_processed:
            already_processed.add('rmin1')
            outfile.write(' rmin1=%s' % (quote_attrib(self.rmin1), ))
        if self.rmin2 != "0.0" and 'rmin2' not in already_processed:
            already_processed.add('rmin2')
            outfile.write(' rmin2=%s' % (quote_attrib(self.rmin2), ))
        if self.rmax1 is not None and 'rmax1' not in already_processed:
            already_processed.add('rmax1')
            outfile.write(' rmax1=%s' % (quote_attrib(self.rmax1), ))
        if self.rmax2 is not None and 'rmax2' not in already_processed:
            already_processed.add('rmax2')
            outfile.write(' rmax2=%s' % (quote_attrib(self.rmax2), ))
        if self.startphi != "0.0" and 'startphi' not in already_processed:
            already_processed.add('startphi')
            outfile.write(' startphi=%s' % (quote_attrib(self.startphi), ))
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            outfile.write(' deltaphi=%s' % (quote_attrib(self.deltaphi), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cone', fromsubclass_=False, pretty_print=True):
        super(cone, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='cone', mapping_=None, nsmap_=None):
        element = super(cone, self).to_etree(parent_element, name_, mapping_)
        if self.z is not None:
            element.set('z', self.z)
        if self.rmin1 is not None:
            element.set('rmin1', self.rmin1)
        if self.rmin2 is not None:
            element.set('rmin2', self.rmin2)
        if self.rmax1 is not None:
            element.set('rmax1', self.rmax1)
        if self.rmax2 is not None:
            element.set('rmax2', self.rmax2)
        if self.startphi is not None:
            element.set('startphi', self.startphi)
        if self.deltaphi is not None:
            element.set('deltaphi', self.deltaphi)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='cone'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        if self.rmin1 is not None and 'rmin1' not in already_processed:
            already_processed.add('rmin1')
            showIndent(outfile, level)
            outfile.write('rmin1=%s,\n' % (self.rmin1,))
        if self.rmin2 is not None and 'rmin2' not in already_processed:
            already_processed.add('rmin2')
            showIndent(outfile, level)
            outfile.write('rmin2=%s,\n' % (self.rmin2,))
        if self.rmax1 is not None and 'rmax1' not in already_processed:
            already_processed.add('rmax1')
            showIndent(outfile, level)
            outfile.write('rmax1=%s,\n' % (self.rmax1,))
        if self.rmax2 is not None and 'rmax2' not in already_processed:
            already_processed.add('rmax2')
            showIndent(outfile, level)
            outfile.write('rmax2=%s,\n' % (self.rmax2,))
        if self.startphi is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            showIndent(outfile, level)
            outfile.write('startphi=%s,\n' % (self.startphi,))
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            showIndent(outfile, level)
            outfile.write('deltaphi=%s,\n' % (self.deltaphi,))
        super(cone, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(cone, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmin1', node)
        if value is not None and 'rmin1' not in already_processed:
            already_processed.add('rmin1')
            self.rmin1 = value
            self.validate_ExpressionOrIDREFType(self.rmin1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmin2', node)
        if value is not None and 'rmin2' not in already_processed:
            already_processed.add('rmin2')
            self.rmin2 = value
            self.validate_ExpressionOrIDREFType(self.rmin2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmax1', node)
        if value is not None and 'rmax1' not in already_processed:
            already_processed.add('rmax1')
            self.rmax1 = value
            self.validate_ExpressionOrIDREFType(self.rmax1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmax2', node)
        if value is not None and 'rmax2' not in already_processed:
            already_processed.add('rmax2')
            self.rmax2 = value
            self.validate_ExpressionOrIDREFType(self.rmax2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('startphi', node)
        if value is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            self.startphi = value
            self.validate_ExpressionOrIDREFType(self.startphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('deltaphi', node)
        if value is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            self.deltaphi = value
            self.validate_ExpressionOrIDREFType(self.deltaphi)    # validate type ExpressionOrIDREFType
        super(cone, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(cone, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class cone


class elcone(SolidType):
    """CSG cone with elliptical cross section
    dx semiaxis in X
    dy semiaxis in Y
    zmax height of elliptical cone
    zcut upper cut plane level"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, dx=None, dy=None, zmax=None, zcut=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(elcone, self).__init__(lunit, aunit, name,  **kwargs_)
        self.dx = _cast(None, dx)
        self.dx_nsprefix_ = None
        self.dy = _cast(None, dy)
        self.dy_nsprefix_ = None
        self.zmax = _cast(None, zmax)
        self.zmax_nsprefix_ = None
        self.zcut = _cast(None, zcut)
        self.zcut_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, elcone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if elcone.subclass:
            return elcone.subclass(*args_, **kwargs_)
        else:
            return elcone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dx(self):
        return self.dx
    def set_dx(self, dx):
        self.dx = dx
    dxProp = property(get_dx, set_dx)
    def get_dy(self):
        return self.dy
    def set_dy(self, dy):
        self.dy = dy
    dyProp = property(get_dy, set_dy)
    def get_zmax(self):
        return self.zmax
    def set_zmax(self, zmax):
        self.zmax = zmax
    zmaxProp = property(get_zmax, set_zmax)
    def get_zcut(self):
        return self.zcut
    def set_zcut(self, zcut):
        self.zcut = zcut
    zcutProp = property(get_zcut, set_zcut)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(elcone, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='elcone', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('elcone')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'elcone':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='elcone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='elcone', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='elcone'):
        super(elcone, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='elcone')
        if self.dx is not None and 'dx' not in already_processed:
            already_processed.add('dx')
            outfile.write(' dx=%s' % (quote_attrib(self.dx), ))
        if self.dy is not None and 'dy' not in already_processed:
            already_processed.add('dy')
            outfile.write(' dy=%s' % (quote_attrib(self.dy), ))
        if self.zmax is not None and 'zmax' not in already_processed:
            already_processed.add('zmax')
            outfile.write(' zmax=%s' % (quote_attrib(self.zmax), ))
        if self.zcut is not None and 'zcut' not in already_processed:
            already_processed.add('zcut')
            outfile.write(' zcut=%s' % (quote_attrib(self.zcut), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='elcone', fromsubclass_=False, pretty_print=True):
        super(elcone, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='elcone', mapping_=None, nsmap_=None):
        element = super(elcone, self).to_etree(parent_element, name_, mapping_)
        if self.dx is not None:
            element.set('dx', self.dx)
        if self.dy is not None:
            element.set('dy', self.dy)
        if self.zmax is not None:
            element.set('zmax', self.zmax)
        if self.zcut is not None:
            element.set('zcut', self.zcut)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='elcone'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dx is not None and 'dx' not in already_processed:
            already_processed.add('dx')
            showIndent(outfile, level)
            outfile.write('dx=%s,\n' % (self.dx,))
        if self.dy is not None and 'dy' not in already_processed:
            already_processed.add('dy')
            showIndent(outfile, level)
            outfile.write('dy=%s,\n' % (self.dy,))
        if self.zmax is not None and 'zmax' not in already_processed:
            already_processed.add('zmax')
            showIndent(outfile, level)
            outfile.write('zmax=%s,\n' % (self.zmax,))
        if self.zcut is not None and 'zcut' not in already_processed:
            already_processed.add('zcut')
            showIndent(outfile, level)
            outfile.write('zcut=%s,\n' % (self.zcut,))
        super(elcone, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(elcone, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dx', node)
        if value is not None and 'dx' not in already_processed:
            already_processed.add('dx')
            self.dx = value
            self.validate_ExpressionOrIDREFType(self.dx)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('dy', node)
        if value is not None and 'dy' not in already_processed:
            already_processed.add('dy')
            self.dy = value
            self.validate_ExpressionOrIDREFType(self.dy)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('zmax', node)
        if value is not None and 'zmax' not in already_processed:
            already_processed.add('zmax')
            self.zmax = value
            self.validate_ExpressionOrIDREFType(self.zmax)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('zcut', node)
        if value is not None and 'zcut' not in already_processed:
            already_processed.add('zcut')
            self.zcut = value
            self.validate_ExpressionOrIDREFType(self.zcut)    # validate type ExpressionOrIDREFType
        super(elcone, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(elcone, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class elcone


class polycone(SolidType):
    """CSG polycone or polycone segment described by
    startphi starting angle of the segment in radians
    deltaphi delta angle of the segment in radians
    and a set of z-planes each described by
    rmin inside radius at z/2
    rmax outside radius at z/2
    z length in z"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, deltaphi=None, startphi='0.0', zplane=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(polycone, self).__init__(lunit, aunit, name,  **kwargs_)
        self.deltaphi = _cast(None, deltaphi)
        self.deltaphi_nsprefix_ = None
        self.startphi = _cast(None, startphi)
        self.startphi_nsprefix_ = None
        if zplane is None:
            self.zplane = []
        else:
            self.zplane = zplane
        self.zplane_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, polycone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if polycone.subclass:
            return polycone.subclass(*args_, **kwargs_)
        else:
            return polycone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_zplane(self):
        return self.zplane
    def set_zplane(self, zplane):
        self.zplane = zplane
    def add_zplane(self, value):
        self.zplane.append(value)
    def insert_zplane_at(self, index, value):
        self.zplane.insert(index, value)
    def replace_zplane_at(self, index, value):
        self.zplane[index] = value
    zplaneProp = property(get_zplane, set_zplane)
    def get_deltaphi(self):
        return self.deltaphi
    def set_deltaphi(self, deltaphi):
        self.deltaphi = deltaphi
    deltaphiProp = property(get_deltaphi, set_deltaphi)
    def get_startphi(self):
        return self.startphi
    def set_startphi(self, startphi):
        self.startphi = startphi
    startphiProp = property(get_startphi, set_startphi)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.zplane or
            super(polycone, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='polycone', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('polycone')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'polycone':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='polycone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='polycone', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='polycone'):
        super(polycone, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='polycone')
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            outfile.write(' deltaphi=%s' % (quote_attrib(self.deltaphi), ))
        if self.startphi != "0.0" and 'startphi' not in already_processed:
            already_processed.add('startphi')
            outfile.write(' startphi=%s' % (quote_attrib(self.startphi), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='polycone', fromsubclass_=False, pretty_print=True):
        super(polycone, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for zplane_ in self.zplane:
            namespaceprefix_ = self.zplane_nsprefix_ + ':' if (UseCapturedNS_ and self.zplane_nsprefix_) else ''
            zplane_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='zplane', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='polycone', mapping_=None, nsmap_=None):
        element = super(polycone, self).to_etree(parent_element, name_, mapping_)
        if self.deltaphi is not None:
            element.set('deltaphi', self.deltaphi)
        if self.startphi is not None:
            element.set('startphi', self.startphi)
        for zplane_ in self.zplane:
            zplane_.to_etree(element, name_='zplane', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='polycone'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            showIndent(outfile, level)
            outfile.write('deltaphi=%s,\n' % (self.deltaphi,))
        if self.startphi is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            showIndent(outfile, level)
            outfile.write('startphi=%s,\n' % (self.startphi,))
        super(polycone, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(polycone, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('zplane=[\n')
        level += 1
        for zplane_ in self.zplane:
            showIndent(outfile, level)
            outfile.write('model_.ZPlaneType(\n')
            zplane_.exportLiteral(outfile, level, name_='ZPlaneType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deltaphi', node)
        if value is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            self.deltaphi = value
            self.validate_ExpressionOrIDREFType(self.deltaphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('startphi', node)
        if value is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            self.startphi = value
            self.validate_ExpressionOrIDREFType(self.startphi)    # validate type ExpressionOrIDREFType
        super(polycone, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'zplane':
            obj_ = ZPlaneType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.zplane.append(obj_)
            obj_.original_tagname_ = 'zplane'
        super(polycone, self).buildChildren(child_, node, nodeName_, True)
# end class polycone


class ZPlaneType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, z=None, rmin='0.0', rmax=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.rmin = _cast(None, rmin)
        self.rmin_nsprefix_ = None
        self.rmax = _cast(None, rmax)
        self.rmax_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ZPlaneType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ZPlaneType.subclass:
            return ZPlaneType.subclass(*args_, **kwargs_)
        else:
            return ZPlaneType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_rmin(self):
        return self.rmin
    def set_rmin(self, rmin):
        self.rmin = rmin
    rminProp = property(get_rmin, set_rmin)
    def get_rmax(self):
        return self.rmax
    def set_rmax(self, rmax):
        self.rmax = rmax
    rmaxProp = property(get_rmax, set_rmax)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ZPlaneType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ZPlaneType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ZPlaneType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ZPlaneType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ZPlaneType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ZPlaneType'):
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.rmin != "0.0" and 'rmin' not in already_processed:
            already_processed.add('rmin')
            outfile.write(' rmin=%s' % (quote_attrib(self.rmin), ))
        if self.rmax is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            outfile.write(' rmax=%s' % (quote_attrib(self.rmax), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ZPlaneType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='ZPlaneType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.z is not None:
            element.set('z', self.z)
        if self.rmin is not None:
            element.set('rmin', self.rmin)
        if self.rmax is not None:
            element.set('rmax', self.rmax)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ZPlaneType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        if self.rmin is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            showIndent(outfile, level)
            outfile.write('rmin=%s,\n' % (self.rmin,))
        if self.rmax is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            showIndent(outfile, level)
            outfile.write('rmax=%s,\n' % (self.rmax,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmin', node)
        if value is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            self.rmin = value
            self.validate_ExpressionOrIDREFType(self.rmin)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmax', node)
        if value is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            self.rmax = value
            self.validate_ExpressionOrIDREFType(self.rmax)    # validate type ExpressionOrIDREFType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ZPlaneType


class genericPolycone(SolidType):
    """Generic polycone or polycone segment described by
    startphi starting angle of the segment in radians
    deltaphi delta angle of the segment in radians
    and a set of points with (r,z)coordinates"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, deltaphi=None, startphi='0.0', rzpoint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(genericPolycone, self).__init__(lunit, aunit, name,  **kwargs_)
        self.deltaphi = _cast(None, deltaphi)
        self.deltaphi_nsprefix_ = None
        self.startphi = _cast(None, startphi)
        self.startphi_nsprefix_ = None
        if rzpoint is None:
            self.rzpoint = []
        else:
            self.rzpoint = rzpoint
        self.rzpoint_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, genericPolycone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if genericPolycone.subclass:
            return genericPolycone.subclass(*args_, **kwargs_)
        else:
            return genericPolycone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_rzpoint(self):
        return self.rzpoint
    def set_rzpoint(self, rzpoint):
        self.rzpoint = rzpoint
    def add_rzpoint(self, value):
        self.rzpoint.append(value)
    def insert_rzpoint_at(self, index, value):
        self.rzpoint.insert(index, value)
    def replace_rzpoint_at(self, index, value):
        self.rzpoint[index] = value
    rzpointProp = property(get_rzpoint, set_rzpoint)
    def get_deltaphi(self):
        return self.deltaphi
    def set_deltaphi(self, deltaphi):
        self.deltaphi = deltaphi
    deltaphiProp = property(get_deltaphi, set_deltaphi)
    def get_startphi(self):
        return self.startphi
    def set_startphi(self, startphi):
        self.startphi = startphi
    startphiProp = property(get_startphi, set_startphi)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.rzpoint or
            super(genericPolycone, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='genericPolycone', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('genericPolycone')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'genericPolycone':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='genericPolycone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='genericPolycone', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='genericPolycone'):
        super(genericPolycone, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='genericPolycone')
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            outfile.write(' deltaphi=%s' % (quote_attrib(self.deltaphi), ))
        if self.startphi != "0.0" and 'startphi' not in already_processed:
            already_processed.add('startphi')
            outfile.write(' startphi=%s' % (quote_attrib(self.startphi), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='genericPolycone', fromsubclass_=False, pretty_print=True):
        super(genericPolycone, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for rzpoint_ in self.rzpoint:
            namespaceprefix_ = self.rzpoint_nsprefix_ + ':' if (UseCapturedNS_ and self.rzpoint_nsprefix_) else ''
            rzpoint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rzpoint', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='genericPolycone', mapping_=None, nsmap_=None):
        element = super(genericPolycone, self).to_etree(parent_element, name_, mapping_)
        if self.deltaphi is not None:
            element.set('deltaphi', self.deltaphi)
        if self.startphi is not None:
            element.set('startphi', self.startphi)
        for rzpoint_ in self.rzpoint:
            rzpoint_.to_etree(element, name_='rzpoint', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='genericPolycone'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            showIndent(outfile, level)
            outfile.write('deltaphi=%s,\n' % (self.deltaphi,))
        if self.startphi is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            showIndent(outfile, level)
            outfile.write('startphi=%s,\n' % (self.startphi,))
        super(genericPolycone, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(genericPolycone, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('rzpoint=[\n')
        level += 1
        for rzpoint_ in self.rzpoint:
            showIndent(outfile, level)
            outfile.write('model_.RZPointType(\n')
            rzpoint_.exportLiteral(outfile, level, name_='RZPointType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deltaphi', node)
        if value is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            self.deltaphi = value
            self.validate_ExpressionOrIDREFType(self.deltaphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('startphi', node)
        if value is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            self.startphi = value
            self.validate_ExpressionOrIDREFType(self.startphi)    # validate type ExpressionOrIDREFType
        super(genericPolycone, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'rzpoint':
            obj_ = RZPointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rzpoint.append(obj_)
            obj_.original_tagname_ = 'rzpoint'
        super(genericPolycone, self).buildChildren(child_, node, nodeName_, True)
# end class genericPolycone


class RZPointType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, r=None, z=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.r = _cast(None, r)
        self.r_nsprefix_ = None
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RZPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RZPointType.subclass:
            return RZPointType.subclass(*args_, **kwargs_)
        else:
            return RZPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_r(self):
        return self.r
    def set_r(self, r):
        self.r = r
    rProp = property(get_r, set_r)
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RZPointType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RZPointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RZPointType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RZPointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RZPointType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RZPointType'):
        if self.r is not None and 'r' not in already_processed:
            already_processed.add('r')
            outfile.write(' r=%s' % (quote_attrib(self.r), ))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RZPointType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='RZPointType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.r is not None:
            element.set('r', self.r)
        if self.z is not None:
            element.set('z', self.z)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='RZPointType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.r is not None and 'r' not in already_processed:
            already_processed.add('r')
            showIndent(outfile, level)
            outfile.write('r=%s,\n' % (self.r,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('r', node)
        if value is not None and 'r' not in already_processed:
            already_processed.add('r')
            self.r = value
            self.validate_ExpressionOrIDREFType(self.r)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RZPointType


class para(SolidType):
    """CSG parallelepiped solid is described by
    x, y, z length in x,y,z
    alpha Angle formed by the y axis and by the plane joining the centre of the
    faces
    G4Parallel to the z-x plane at -y and +y
    theta Polar angle of the line joining the centres of the faces at -z and +z
    in z
    phi Azimuthal angle of the line joining the centres of the faces at -z and
    +z in z"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, x=None, y=None, z=None, alpha=None, theta=None, phi=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(para, self).__init__(lunit, aunit, name,  **kwargs_)
        self.x = _cast(None, x)
        self.x_nsprefix_ = None
        self.y = _cast(None, y)
        self.y_nsprefix_ = None
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.alpha = _cast(None, alpha)
        self.alpha_nsprefix_ = None
        self.theta = _cast(None, theta)
        self.theta_nsprefix_ = None
        self.phi = _cast(None, phi)
        self.phi_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, para)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if para.subclass:
            return para.subclass(*args_, **kwargs_)
        else:
            return para(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    xProp = property(get_x, set_x)
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    yProp = property(get_y, set_y)
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_alpha(self):
        return self.alpha
    def set_alpha(self, alpha):
        self.alpha = alpha
    alphaProp = property(get_alpha, set_alpha)
    def get_theta(self):
        return self.theta
    def set_theta(self, theta):
        self.theta = theta
    thetaProp = property(get_theta, set_theta)
    def get_phi(self):
        return self.phi
    def set_phi(self, phi):
        self.phi = phi
    phiProp = property(get_phi, set_phi)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(para, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='para', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('para')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'para':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='para')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='para', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='para'):
        super(para, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='para')
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x=%s' % (quote_attrib(self.x), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y=%s' % (quote_attrib(self.y), ))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.alpha is not None and 'alpha' not in already_processed:
            already_processed.add('alpha')
            outfile.write(' alpha=%s' % (quote_attrib(self.alpha), ))
        if self.theta is not None and 'theta' not in already_processed:
            already_processed.add('theta')
            outfile.write(' theta=%s' % (quote_attrib(self.theta), ))
        if self.phi is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            outfile.write(' phi=%s' % (quote_attrib(self.phi), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='para', fromsubclass_=False, pretty_print=True):
        super(para, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='para', mapping_=None, nsmap_=None):
        element = super(para, self).to_etree(parent_element, name_, mapping_)
        if self.x is not None:
            element.set('x', self.x)
        if self.y is not None:
            element.set('y', self.y)
        if self.z is not None:
            element.set('z', self.z)
        if self.alpha is not None:
            element.set('alpha', self.alpha)
        if self.theta is not None:
            element.set('theta', self.theta)
        if self.phi is not None:
            element.set('phi', self.phi)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='para'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%s,\n' % (self.x,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%s,\n' % (self.y,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        if self.alpha is not None and 'alpha' not in already_processed:
            already_processed.add('alpha')
            showIndent(outfile, level)
            outfile.write('alpha=%s,\n' % (self.alpha,))
        if self.theta is not None and 'theta' not in already_processed:
            already_processed.add('theta')
            showIndent(outfile, level)
            outfile.write('theta=%s,\n' % (self.theta,))
        if self.phi is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            showIndent(outfile, level)
            outfile.write('phi=%s,\n' % (self.phi,))
        super(para, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(para, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            self.x = value
            self.validate_ExpressionOrIDREFType(self.x)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            self.y = value
            self.validate_ExpressionOrIDREFType(self.y)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('alpha', node)
        if value is not None and 'alpha' not in already_processed:
            already_processed.add('alpha')
            self.alpha = value
            self.validate_ExpressionOrIDREFType(self.alpha)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('theta', node)
        if value is not None and 'theta' not in already_processed:
            already_processed.add('theta')
            self.theta = value
            self.validate_ExpressionOrIDREFType(self.theta)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('phi', node)
        if value is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            self.phi = value
            self.validate_ExpressionOrIDREFType(self.phi)    # validate type ExpressionOrIDREFType
        super(para, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(para, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class para


class trd(SolidType):
    """CSG trapezoid solid with varying x and y dimensions along z axis
    x1 Length along x at the surface positioned at -z
    x2 Length along x at the surface positioned at +z
    y1 Length along y at the surface positioned at -z
    y2 Length along y at the surface positioned at +z
    z Length along z axis"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, x1=None, x2=None, y1=None, y2=None, z=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(trd, self).__init__(lunit, aunit, name,  **kwargs_)
        self.x1 = _cast(None, x1)
        self.x1_nsprefix_ = None
        self.x2 = _cast(None, x2)
        self.x2_nsprefix_ = None
        self.y1 = _cast(None, y1)
        self.y1_nsprefix_ = None
        self.y2 = _cast(None, y2)
        self.y2_nsprefix_ = None
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trd)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trd.subclass:
            return trd.subclass(*args_, **kwargs_)
        else:
            return trd(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_x1(self):
        return self.x1
    def set_x1(self, x1):
        self.x1 = x1
    x1Prop = property(get_x1, set_x1)
    def get_x2(self):
        return self.x2
    def set_x2(self, x2):
        self.x2 = x2
    x2Prop = property(get_x2, set_x2)
    def get_y1(self):
        return self.y1
    def set_y1(self, y1):
        self.y1 = y1
    y1Prop = property(get_y1, set_y1)
    def get_y2(self):
        return self.y2
    def set_y2(self, y2):
        self.y2 = y2
    y2Prop = property(get_y2, set_y2)
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(trd, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trd', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('trd')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'trd':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trd')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='trd', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='trd'):
        super(trd, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trd')
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.add('x1')
            outfile.write(' x1=%s' % (quote_attrib(self.x1), ))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.add('x2')
            outfile.write(' x2=%s' % (quote_attrib(self.x2), ))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.add('y1')
            outfile.write(' y1=%s' % (quote_attrib(self.y1), ))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.add('y2')
            outfile.write(' y2=%s' % (quote_attrib(self.y2), ))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trd', fromsubclass_=False, pretty_print=True):
        super(trd, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='trd', mapping_=None, nsmap_=None):
        element = super(trd, self).to_etree(parent_element, name_, mapping_)
        if self.x1 is not None:
            element.set('x1', self.x1)
        if self.x2 is not None:
            element.set('x2', self.x2)
        if self.y1 is not None:
            element.set('y1', self.y1)
        if self.y2 is not None:
            element.set('y2', self.y2)
        if self.z is not None:
            element.set('z', self.z)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='trd'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.add('x1')
            showIndent(outfile, level)
            outfile.write('x1=%s,\n' % (self.x1,))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.add('x2')
            showIndent(outfile, level)
            outfile.write('x2=%s,\n' % (self.x2,))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.add('y1')
            showIndent(outfile, level)
            outfile.write('y1=%s,\n' % (self.y1,))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.add('y2')
            showIndent(outfile, level)
            outfile.write('y2=%s,\n' % (self.y2,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        super(trd, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(trd, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('x1', node)
        if value is not None and 'x1' not in already_processed:
            already_processed.add('x1')
            self.x1 = value
            self.validate_ExpressionOrIDREFType(self.x1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('x2', node)
        if value is not None and 'x2' not in already_processed:
            already_processed.add('x2')
            self.x2 = value
            self.validate_ExpressionOrIDREFType(self.x2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y1', node)
        if value is not None and 'y1' not in already_processed:
            already_processed.add('y1')
            self.y1 = value
            self.validate_ExpressionOrIDREFType(self.y1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y2', node)
        if value is not None and 'y2' not in already_processed:
            already_processed.add('y2')
            self.y2 = value
            self.validate_ExpressionOrIDREFType(self.y2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        super(trd, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(trd, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class trd


class trap(SolidType):
    """CSG general trapezoid solid is described by
    z Length along the z-axis
    theta Polar angle of the line joining the centres of the faces at -/+z
    phi Azimuthal angle of the line joing the centre of the face at -z to the
    centre of the face at +z
    y1 Length along y of the face at -z
    x1 Length along x of the side at y = -y1 of the face at -z
    x2 Length along x of the side at y = +y1 of the face at -z
    alp1 Angle with respect to the y axis from the centre of the side at y =-
    y1 to the centre at y = +y1 of the face at -z
    y2 Length along y of the face at +z
    x3 Length along x of the side at y = -y2 of the face at +z
    x4 Length along x of the side at y = +y2 of the face at +z
    alp2 Angle with respect to the y axis from the centre of the side at y =
    -y2 to the centre at y = +y2 of the face at +z"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, z=None, theta=None, phi=None, y1=None, x1=None, x2=None, alpha1=None, y2=None, x3=None, x4=None, alpha2=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(trap, self).__init__(lunit, aunit, name,  **kwargs_)
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.theta = _cast(None, theta)
        self.theta_nsprefix_ = None
        self.phi = _cast(None, phi)
        self.phi_nsprefix_ = None
        self.y1 = _cast(None, y1)
        self.y1_nsprefix_ = None
        self.x1 = _cast(None, x1)
        self.x1_nsprefix_ = None
        self.x2 = _cast(None, x2)
        self.x2_nsprefix_ = None
        self.alpha1 = _cast(None, alpha1)
        self.alpha1_nsprefix_ = None
        self.y2 = _cast(None, y2)
        self.y2_nsprefix_ = None
        self.x3 = _cast(None, x3)
        self.x3_nsprefix_ = None
        self.x4 = _cast(None, x4)
        self.x4_nsprefix_ = None
        self.alpha2 = _cast(None, alpha2)
        self.alpha2_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trap.subclass:
            return trap.subclass(*args_, **kwargs_)
        else:
            return trap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_theta(self):
        return self.theta
    def set_theta(self, theta):
        self.theta = theta
    thetaProp = property(get_theta, set_theta)
    def get_phi(self):
        return self.phi
    def set_phi(self, phi):
        self.phi = phi
    phiProp = property(get_phi, set_phi)
    def get_y1(self):
        return self.y1
    def set_y1(self, y1):
        self.y1 = y1
    y1Prop = property(get_y1, set_y1)
    def get_x1(self):
        return self.x1
    def set_x1(self, x1):
        self.x1 = x1
    x1Prop = property(get_x1, set_x1)
    def get_x2(self):
        return self.x2
    def set_x2(self, x2):
        self.x2 = x2
    x2Prop = property(get_x2, set_x2)
    def get_alpha1(self):
        return self.alpha1
    def set_alpha1(self, alpha1):
        self.alpha1 = alpha1
    alpha1Prop = property(get_alpha1, set_alpha1)
    def get_y2(self):
        return self.y2
    def set_y2(self, y2):
        self.y2 = y2
    y2Prop = property(get_y2, set_y2)
    def get_x3(self):
        return self.x3
    def set_x3(self, x3):
        self.x3 = x3
    x3Prop = property(get_x3, set_x3)
    def get_x4(self):
        return self.x4
    def set_x4(self, x4):
        self.x4 = x4
    x4Prop = property(get_x4, set_x4)
    def get_alpha2(self):
        return self.alpha2
    def set_alpha2(self, alpha2):
        self.alpha2 = alpha2
    alpha2Prop = property(get_alpha2, set_alpha2)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(trap, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trap', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('trap')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'trap':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='trap', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='trap'):
        super(trap, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='trap')
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.theta is not None and 'theta' not in already_processed:
            already_processed.add('theta')
            outfile.write(' theta=%s' % (quote_attrib(self.theta), ))
        if self.phi is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            outfile.write(' phi=%s' % (quote_attrib(self.phi), ))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.add('y1')
            outfile.write(' y1=%s' % (quote_attrib(self.y1), ))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.add('x1')
            outfile.write(' x1=%s' % (quote_attrib(self.x1), ))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.add('x2')
            outfile.write(' x2=%s' % (quote_attrib(self.x2), ))
        if self.alpha1 is not None and 'alpha1' not in already_processed:
            already_processed.add('alpha1')
            outfile.write(' alpha1=%s' % (quote_attrib(self.alpha1), ))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.add('y2')
            outfile.write(' y2=%s' % (quote_attrib(self.y2), ))
        if self.x3 is not None and 'x3' not in already_processed:
            already_processed.add('x3')
            outfile.write(' x3=%s' % (quote_attrib(self.x3), ))
        if self.x4 is not None and 'x4' not in already_processed:
            already_processed.add('x4')
            outfile.write(' x4=%s' % (quote_attrib(self.x4), ))
        if self.alpha2 is not None and 'alpha2' not in already_processed:
            already_processed.add('alpha2')
            outfile.write(' alpha2=%s' % (quote_attrib(self.alpha2), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='trap', fromsubclass_=False, pretty_print=True):
        super(trap, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='trap', mapping_=None, nsmap_=None):
        element = super(trap, self).to_etree(parent_element, name_, mapping_)
        if self.z is not None:
            element.set('z', self.z)
        if self.theta is not None:
            element.set('theta', self.theta)
        if self.phi is not None:
            element.set('phi', self.phi)
        if self.y1 is not None:
            element.set('y1', self.y1)
        if self.x1 is not None:
            element.set('x1', self.x1)
        if self.x2 is not None:
            element.set('x2', self.x2)
        if self.alpha1 is not None:
            element.set('alpha1', self.alpha1)
        if self.y2 is not None:
            element.set('y2', self.y2)
        if self.x3 is not None:
            element.set('x3', self.x3)
        if self.x4 is not None:
            element.set('x4', self.x4)
        if self.alpha2 is not None:
            element.set('alpha2', self.alpha2)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='trap'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        if self.theta is not None and 'theta' not in already_processed:
            already_processed.add('theta')
            showIndent(outfile, level)
            outfile.write('theta=%s,\n' % (self.theta,))
        if self.phi is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            showIndent(outfile, level)
            outfile.write('phi=%s,\n' % (self.phi,))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.add('y1')
            showIndent(outfile, level)
            outfile.write('y1=%s,\n' % (self.y1,))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.add('x1')
            showIndent(outfile, level)
            outfile.write('x1=%s,\n' % (self.x1,))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.add('x2')
            showIndent(outfile, level)
            outfile.write('x2=%s,\n' % (self.x2,))
        if self.alpha1 is not None and 'alpha1' not in already_processed:
            already_processed.add('alpha1')
            showIndent(outfile, level)
            outfile.write('alpha1=%s,\n' % (self.alpha1,))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.add('y2')
            showIndent(outfile, level)
            outfile.write('y2=%s,\n' % (self.y2,))
        if self.x3 is not None and 'x3' not in already_processed:
            already_processed.add('x3')
            showIndent(outfile, level)
            outfile.write('x3=%s,\n' % (self.x3,))
        if self.x4 is not None and 'x4' not in already_processed:
            already_processed.add('x4')
            showIndent(outfile, level)
            outfile.write('x4=%s,\n' % (self.x4,))
        if self.alpha2 is not None and 'alpha2' not in already_processed:
            already_processed.add('alpha2')
            showIndent(outfile, level)
            outfile.write('alpha2=%s,\n' % (self.alpha2,))
        super(trap, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(trap, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('theta', node)
        if value is not None and 'theta' not in already_processed:
            already_processed.add('theta')
            self.theta = value
            self.validate_ExpressionOrIDREFType(self.theta)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('phi', node)
        if value is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            self.phi = value
            self.validate_ExpressionOrIDREFType(self.phi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y1', node)
        if value is not None and 'y1' not in already_processed:
            already_processed.add('y1')
            self.y1 = value
            self.validate_ExpressionOrIDREFType(self.y1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('x1', node)
        if value is not None and 'x1' not in already_processed:
            already_processed.add('x1')
            self.x1 = value
            self.validate_ExpressionOrIDREFType(self.x1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('x2', node)
        if value is not None and 'x2' not in already_processed:
            already_processed.add('x2')
            self.x2 = value
            self.validate_ExpressionOrIDREFType(self.x2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('alpha1', node)
        if value is not None and 'alpha1' not in already_processed:
            already_processed.add('alpha1')
            self.alpha1 = value
            self.validate_ExpressionOrIDREFType(self.alpha1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y2', node)
        if value is not None and 'y2' not in already_processed:
            already_processed.add('y2')
            self.y2 = value
            self.validate_ExpressionOrIDREFType(self.y2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('x3', node)
        if value is not None and 'x3' not in already_processed:
            already_processed.add('x3')
            self.x3 = value
            self.validate_ExpressionOrIDREFType(self.x3)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('x4', node)
        if value is not None and 'x4' not in already_processed:
            already_processed.add('x4')
            self.x4 = value
            self.validate_ExpressionOrIDREFType(self.x4)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('alpha2', node)
        if value is not None and 'alpha2' not in already_processed:
            already_processed.add('alpha2')
            self.alpha2 = value
            self.validate_ExpressionOrIDREFType(self.alpha2)    # validate type ExpressionOrIDREFType
        super(trap, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(trap, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class trap


class torus(SolidType):
    """CSG torus solid is described by
    rmin Inside radius
    rmax Outside radius
    rtor swept radius of torus
    startphi The starting phi angle in radians adjusted such that sphi+dphi lt
    2PI, sphi gt -2PI
    deltaphi Delta angle of the segment in radians"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, rmin=None, rmax=None, rtor=None, startphi=None, deltaphi=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(torus, self).__init__(lunit, aunit, name,  **kwargs_)
        self.rmin = _cast(None, rmin)
        self.rmin_nsprefix_ = None
        self.rmax = _cast(None, rmax)
        self.rmax_nsprefix_ = None
        self.rtor = _cast(None, rtor)
        self.rtor_nsprefix_ = None
        self.startphi = _cast(None, startphi)
        self.startphi_nsprefix_ = None
        self.deltaphi = _cast(None, deltaphi)
        self.deltaphi_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, torus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if torus.subclass:
            return torus.subclass(*args_, **kwargs_)
        else:
            return torus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_rmin(self):
        return self.rmin
    def set_rmin(self, rmin):
        self.rmin = rmin
    rminProp = property(get_rmin, set_rmin)
    def get_rmax(self):
        return self.rmax
    def set_rmax(self, rmax):
        self.rmax = rmax
    rmaxProp = property(get_rmax, set_rmax)
    def get_rtor(self):
        return self.rtor
    def set_rtor(self, rtor):
        self.rtor = rtor
    rtorProp = property(get_rtor, set_rtor)
    def get_startphi(self):
        return self.startphi
    def set_startphi(self, startphi):
        self.startphi = startphi
    startphiProp = property(get_startphi, set_startphi)
    def get_deltaphi(self):
        return self.deltaphi
    def set_deltaphi(self, deltaphi):
        self.deltaphi = deltaphi
    deltaphiProp = property(get_deltaphi, set_deltaphi)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(torus, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='torus', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('torus')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'torus':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='torus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='torus', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='torus'):
        super(torus, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='torus')
        if self.rmin is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            outfile.write(' rmin=%s' % (quote_attrib(self.rmin), ))
        if self.rmax is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            outfile.write(' rmax=%s' % (quote_attrib(self.rmax), ))
        if self.rtor is not None and 'rtor' not in already_processed:
            already_processed.add('rtor')
            outfile.write(' rtor=%s' % (quote_attrib(self.rtor), ))
        if self.startphi is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            outfile.write(' startphi=%s' % (quote_attrib(self.startphi), ))
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            outfile.write(' deltaphi=%s' % (quote_attrib(self.deltaphi), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='torus', fromsubclass_=False, pretty_print=True):
        super(torus, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='torus', mapping_=None, nsmap_=None):
        element = super(torus, self).to_etree(parent_element, name_, mapping_)
        if self.rmin is not None:
            element.set('rmin', self.rmin)
        if self.rmax is not None:
            element.set('rmax', self.rmax)
        if self.rtor is not None:
            element.set('rtor', self.rtor)
        if self.startphi is not None:
            element.set('startphi', self.startphi)
        if self.deltaphi is not None:
            element.set('deltaphi', self.deltaphi)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='torus'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rmin is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            showIndent(outfile, level)
            outfile.write('rmin=%s,\n' % (self.rmin,))
        if self.rmax is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            showIndent(outfile, level)
            outfile.write('rmax=%s,\n' % (self.rmax,))
        if self.rtor is not None and 'rtor' not in already_processed:
            already_processed.add('rtor')
            showIndent(outfile, level)
            outfile.write('rtor=%s,\n' % (self.rtor,))
        if self.startphi is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            showIndent(outfile, level)
            outfile.write('startphi=%s,\n' % (self.startphi,))
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            showIndent(outfile, level)
            outfile.write('deltaphi=%s,\n' % (self.deltaphi,))
        super(torus, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(torus, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rmin', node)
        if value is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            self.rmin = value
            self.validate_ExpressionOrIDREFType(self.rmin)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmax', node)
        if value is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            self.rmax = value
            self.validate_ExpressionOrIDREFType(self.rmax)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rtor', node)
        if value is not None and 'rtor' not in already_processed:
            already_processed.add('rtor')
            self.rtor = value
            self.validate_ExpressionOrIDREFType(self.rtor)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('startphi', node)
        if value is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            self.startphi = value
            self.validate_ExpressionOrIDREFType(self.startphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('deltaphi', node)
        if value is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            self.deltaphi = value
            self.validate_ExpressionOrIDREFType(self.deltaphi)    # validate type ExpressionOrIDREFType
        super(torus, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(torus, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class torus


class orb(SolidType):
    """CSG orb solid (simplified sphere with only rmax) is described by
    r Outside radius"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, r=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(orb, self).__init__(lunit, aunit, name,  **kwargs_)
        self.r = _cast(None, r)
        self.r_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, orb)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if orb.subclass:
            return orb.subclass(*args_, **kwargs_)
        else:
            return orb(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_r(self):
        return self.r
    def set_r(self, r):
        self.r = r
    rProp = property(get_r, set_r)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(orb, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='orb', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('orb')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'orb':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='orb')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='orb', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='orb'):
        super(orb, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='orb')
        if self.r is not None and 'r' not in already_processed:
            already_processed.add('r')
            outfile.write(' r=%s' % (quote_attrib(self.r), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='orb', fromsubclass_=False, pretty_print=True):
        super(orb, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='orb', mapping_=None, nsmap_=None):
        element = super(orb, self).to_etree(parent_element, name_, mapping_)
        if self.r is not None:
            element.set('r', self.r)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='orb'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.r is not None and 'r' not in already_processed:
            already_processed.add('r')
            showIndent(outfile, level)
            outfile.write('r=%s,\n' % (self.r,))
        super(orb, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(orb, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('r', node)
        if value is not None and 'r' not in already_processed:
            already_processed.add('r')
            self.r = value
            self.validate_ExpressionOrIDREFType(self.r)    # validate type ExpressionOrIDREFType
        super(orb, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(orb, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class orb


class polyhedra(SolidType):
    """Polyhedra is described by
    startphi initial phi starting angle
    totalphi total phi angle
    numsides number sides
    and a set of zplanes."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, startphi=None, deltaphi=None, numsides=None, zplane=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(polyhedra, self).__init__(lunit, aunit, name,  **kwargs_)
        self.startphi = _cast(None, startphi)
        self.startphi_nsprefix_ = None
        self.deltaphi = _cast(None, deltaphi)
        self.deltaphi_nsprefix_ = None
        self.numsides = _cast(None, numsides)
        self.numsides_nsprefix_ = None
        if zplane is None:
            self.zplane = []
        else:
            self.zplane = zplane
        self.zplane_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, polyhedra)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if polyhedra.subclass:
            return polyhedra.subclass(*args_, **kwargs_)
        else:
            return polyhedra(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_zplane(self):
        return self.zplane
    def set_zplane(self, zplane):
        self.zplane = zplane
    def add_zplane(self, value):
        self.zplane.append(value)
    def insert_zplane_at(self, index, value):
        self.zplane.insert(index, value)
    def replace_zplane_at(self, index, value):
        self.zplane[index] = value
    zplaneProp = property(get_zplane, set_zplane)
    def get_startphi(self):
        return self.startphi
    def set_startphi(self, startphi):
        self.startphi = startphi
    startphiProp = property(get_startphi, set_startphi)
    def get_deltaphi(self):
        return self.deltaphi
    def set_deltaphi(self, deltaphi):
        self.deltaphi = deltaphi
    deltaphiProp = property(get_deltaphi, set_deltaphi)
    def get_numsides(self):
        return self.numsides
    def set_numsides(self, numsides):
        self.numsides = numsides
    numsidesProp = property(get_numsides, set_numsides)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.zplane or
            super(polyhedra, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='polyhedra', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('polyhedra')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'polyhedra':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='polyhedra')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='polyhedra', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='polyhedra'):
        super(polyhedra, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='polyhedra')
        if self.startphi is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            outfile.write(' startphi=%s' % (quote_attrib(self.startphi), ))
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            outfile.write(' deltaphi=%s' % (quote_attrib(self.deltaphi), ))
        if self.numsides is not None and 'numsides' not in already_processed:
            already_processed.add('numsides')
            outfile.write(' numsides=%s' % (quote_attrib(self.numsides), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='polyhedra', fromsubclass_=False, pretty_print=True):
        super(polyhedra, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for zplane_ in self.zplane:
            namespaceprefix_ = self.zplane_nsprefix_ + ':' if (UseCapturedNS_ and self.zplane_nsprefix_) else ''
            zplane_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='zplane', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='polyhedra', mapping_=None, nsmap_=None):
        element = super(polyhedra, self).to_etree(parent_element, name_, mapping_)
        if self.startphi is not None:
            element.set('startphi', self.startphi)
        if self.deltaphi is not None:
            element.set('deltaphi', self.deltaphi)
        if self.numsides is not None:
            element.set('numsides', self.numsides)
        for zplane_ in self.zplane:
            zplane_.to_etree(element, name_='zplane', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='polyhedra'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.startphi is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            showIndent(outfile, level)
            outfile.write('startphi=%s,\n' % (self.startphi,))
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            showIndent(outfile, level)
            outfile.write('deltaphi=%s,\n' % (self.deltaphi,))
        if self.numsides is not None and 'numsides' not in already_processed:
            already_processed.add('numsides')
            showIndent(outfile, level)
            outfile.write('numsides=%s,\n' % (self.numsides,))
        super(polyhedra, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(polyhedra, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('zplane=[\n')
        level += 1
        for zplane_ in self.zplane:
            showIndent(outfile, level)
            outfile.write('model_.ZPlaneType(\n')
            zplane_.exportLiteral(outfile, level, name_='ZPlaneType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('startphi', node)
        if value is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            self.startphi = value
            self.validate_ExpressionOrIDREFType(self.startphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('deltaphi', node)
        if value is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            self.deltaphi = value
            self.validate_ExpressionOrIDREFType(self.deltaphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('numsides', node)
        if value is not None and 'numsides' not in already_processed:
            already_processed.add('numsides')
            self.numsides = value
            self.validate_ExpressionOrIDREFType(self.numsides)    # validate type ExpressionOrIDREFType
        super(polyhedra, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'zplane':
            obj_ = ZPlaneType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.zplane.append(obj_)
            obj_.original_tagname_ = 'zplane'
        super(polyhedra, self).buildChildren(child_, node, nodeName_, True)
# end class polyhedra


class genericPolyhedra(SolidType):
    """Polyhedra is described by
    startphi initial phi starting angle
    totalphi total phi angle
    numsides number sides
    and a set of points with (r,z) coordinates."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, startphi=None, deltaphi=None, numsides=None, rzpoint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(genericPolyhedra, self).__init__(lunit, aunit, name,  **kwargs_)
        self.startphi = _cast(None, startphi)
        self.startphi_nsprefix_ = None
        self.deltaphi = _cast(None, deltaphi)
        self.deltaphi_nsprefix_ = None
        self.numsides = _cast(None, numsides)
        self.numsides_nsprefix_ = None
        if rzpoint is None:
            self.rzpoint = []
        else:
            self.rzpoint = rzpoint
        self.rzpoint_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, genericPolyhedra)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if genericPolyhedra.subclass:
            return genericPolyhedra.subclass(*args_, **kwargs_)
        else:
            return genericPolyhedra(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_rzpoint(self):
        return self.rzpoint
    def set_rzpoint(self, rzpoint):
        self.rzpoint = rzpoint
    def add_rzpoint(self, value):
        self.rzpoint.append(value)
    def insert_rzpoint_at(self, index, value):
        self.rzpoint.insert(index, value)
    def replace_rzpoint_at(self, index, value):
        self.rzpoint[index] = value
    rzpointProp = property(get_rzpoint, set_rzpoint)
    def get_startphi(self):
        return self.startphi
    def set_startphi(self, startphi):
        self.startphi = startphi
    startphiProp = property(get_startphi, set_startphi)
    def get_deltaphi(self):
        return self.deltaphi
    def set_deltaphi(self, deltaphi):
        self.deltaphi = deltaphi
    deltaphiProp = property(get_deltaphi, set_deltaphi)
    def get_numsides(self):
        return self.numsides
    def set_numsides(self, numsides):
        self.numsides = numsides
    numsidesProp = property(get_numsides, set_numsides)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.rzpoint or
            super(genericPolyhedra, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='genericPolyhedra', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('genericPolyhedra')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'genericPolyhedra':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='genericPolyhedra')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='genericPolyhedra', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='genericPolyhedra'):
        super(genericPolyhedra, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='genericPolyhedra')
        if self.startphi is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            outfile.write(' startphi=%s' % (quote_attrib(self.startphi), ))
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            outfile.write(' deltaphi=%s' % (quote_attrib(self.deltaphi), ))
        if self.numsides is not None and 'numsides' not in already_processed:
            already_processed.add('numsides')
            outfile.write(' numsides=%s' % (quote_attrib(self.numsides), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='genericPolyhedra', fromsubclass_=False, pretty_print=True):
        super(genericPolyhedra, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for rzpoint_ in self.rzpoint:
            namespaceprefix_ = self.rzpoint_nsprefix_ + ':' if (UseCapturedNS_ and self.rzpoint_nsprefix_) else ''
            rzpoint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rzpoint', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='genericPolyhedra', mapping_=None, nsmap_=None):
        element = super(genericPolyhedra, self).to_etree(parent_element, name_, mapping_)
        if self.startphi is not None:
            element.set('startphi', self.startphi)
        if self.deltaphi is not None:
            element.set('deltaphi', self.deltaphi)
        if self.numsides is not None:
            element.set('numsides', self.numsides)
        for rzpoint_ in self.rzpoint:
            rzpoint_.to_etree(element, name_='rzpoint', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='genericPolyhedra'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.startphi is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            showIndent(outfile, level)
            outfile.write('startphi=%s,\n' % (self.startphi,))
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            showIndent(outfile, level)
            outfile.write('deltaphi=%s,\n' % (self.deltaphi,))
        if self.numsides is not None and 'numsides' not in already_processed:
            already_processed.add('numsides')
            showIndent(outfile, level)
            outfile.write('numsides=%s,\n' % (self.numsides,))
        super(genericPolyhedra, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(genericPolyhedra, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('rzpoint=[\n')
        level += 1
        for rzpoint_ in self.rzpoint:
            showIndent(outfile, level)
            outfile.write('model_.RZPointType(\n')
            rzpoint_.exportLiteral(outfile, level, name_='RZPointType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('startphi', node)
        if value is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            self.startphi = value
            self.validate_ExpressionOrIDREFType(self.startphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('deltaphi', node)
        if value is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            self.deltaphi = value
            self.validate_ExpressionOrIDREFType(self.deltaphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('numsides', node)
        if value is not None and 'numsides' not in already_processed:
            already_processed.add('numsides')
            self.numsides = value
            self.validate_ExpressionOrIDREFType(self.numsides)    # validate type ExpressionOrIDREFType
        super(genericPolyhedra, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'rzpoint':
            obj_ = RZPointType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rzpoint.append(obj_)
            obj_.original_tagname_ = 'rzpoint'
        super(genericPolyhedra, self).buildChildren(child_, node, nodeName_, True)
# end class genericPolyhedra


class TwoDimVertexType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, x=None, y=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.x = _cast(None, x)
        self.x_nsprefix_ = None
        self.y = _cast(None, y)
        self.y_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TwoDimVertexType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TwoDimVertexType.subclass:
            return TwoDimVertexType.subclass(*args_, **kwargs_)
        else:
            return TwoDimVertexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    xProp = property(get_x, set_x)
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    yProp = property(get_y, set_y)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TwoDimVertexType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TwoDimVertexType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TwoDimVertexType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TwoDimVertexType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TwoDimVertexType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TwoDimVertexType'):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x=%s' % (quote_attrib(self.x), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y=%s' % (quote_attrib(self.y), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TwoDimVertexType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='TwoDimVertexType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.x is not None:
            element.set('x', self.x)
        if self.y is not None:
            element.set('y', self.y)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TwoDimVertexType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%s,\n' % (self.x,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%s,\n' % (self.y,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            self.x = value
            self.validate_ExpressionOrIDREFType(self.x)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            self.y = value
            self.validate_ExpressionOrIDREFType(self.y)    # validate type ExpressionOrIDREFType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TwoDimVertexType


class SectionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, zOrder=None, zPosition=None, xOffset=None, yOffset=None, scalingFactor=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.zOrder = _cast(None, zOrder)
        self.zOrder_nsprefix_ = None
        self.zPosition = _cast(None, zPosition)
        self.zPosition_nsprefix_ = None
        self.xOffset = _cast(None, xOffset)
        self.xOffset_nsprefix_ = None
        self.yOffset = _cast(None, yOffset)
        self.yOffset_nsprefix_ = None
        self.scalingFactor = _cast(None, scalingFactor)
        self.scalingFactor_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SectionType.subclass:
            return SectionType.subclass(*args_, **kwargs_)
        else:
            return SectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_zOrder(self):
        return self.zOrder
    def set_zOrder(self, zOrder):
        self.zOrder = zOrder
    zOrderProp = property(get_zOrder, set_zOrder)
    def get_zPosition(self):
        return self.zPosition
    def set_zPosition(self, zPosition):
        self.zPosition = zPosition
    zPositionProp = property(get_zPosition, set_zPosition)
    def get_xOffset(self):
        return self.xOffset
    def set_xOffset(self, xOffset):
        self.xOffset = xOffset
    xOffsetProp = property(get_xOffset, set_xOffset)
    def get_yOffset(self):
        return self.yOffset
    def set_yOffset(self, yOffset):
        self.yOffset = yOffset
    yOffsetProp = property(get_yOffset, set_yOffset)
    def get_scalingFactor(self):
        return self.scalingFactor
    def set_scalingFactor(self, scalingFactor):
        self.scalingFactor = scalingFactor
    scalingFactorProp = property(get_scalingFactor, set_scalingFactor)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SectionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SectionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SectionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SectionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SectionType'):
        if self.zOrder is not None and 'zOrder' not in already_processed:
            already_processed.add('zOrder')
            outfile.write(' zOrder=%s' % (quote_attrib(self.zOrder), ))
        if self.zPosition is not None and 'zPosition' not in already_processed:
            already_processed.add('zPosition')
            outfile.write(' zPosition=%s' % (quote_attrib(self.zPosition), ))
        if self.xOffset is not None and 'xOffset' not in already_processed:
            already_processed.add('xOffset')
            outfile.write(' xOffset=%s' % (quote_attrib(self.xOffset), ))
        if self.yOffset is not None and 'yOffset' not in already_processed:
            already_processed.add('yOffset')
            outfile.write(' yOffset=%s' % (quote_attrib(self.yOffset), ))
        if self.scalingFactor is not None and 'scalingFactor' not in already_processed:
            already_processed.add('scalingFactor')
            outfile.write(' scalingFactor=%s' % (quote_attrib(self.scalingFactor), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SectionType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='SectionType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.zOrder is not None:
            element.set('zOrder', self.zOrder)
        if self.zPosition is not None:
            element.set('zPosition', self.zPosition)
        if self.xOffset is not None:
            element.set('xOffset', self.xOffset)
        if self.yOffset is not None:
            element.set('yOffset', self.yOffset)
        if self.scalingFactor is not None:
            element.set('scalingFactor', self.scalingFactor)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='SectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.zOrder is not None and 'zOrder' not in already_processed:
            already_processed.add('zOrder')
            showIndent(outfile, level)
            outfile.write('zOrder=%s,\n' % (self.zOrder,))
        if self.zPosition is not None and 'zPosition' not in already_processed:
            already_processed.add('zPosition')
            showIndent(outfile, level)
            outfile.write('zPosition=%s,\n' % (self.zPosition,))
        if self.xOffset is not None and 'xOffset' not in already_processed:
            already_processed.add('xOffset')
            showIndent(outfile, level)
            outfile.write('xOffset=%s,\n' % (self.xOffset,))
        if self.yOffset is not None and 'yOffset' not in already_processed:
            already_processed.add('yOffset')
            showIndent(outfile, level)
            outfile.write('yOffset=%s,\n' % (self.yOffset,))
        if self.scalingFactor is not None and 'scalingFactor' not in already_processed:
            already_processed.add('scalingFactor')
            showIndent(outfile, level)
            outfile.write('scalingFactor=%s,\n' % (self.scalingFactor,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('zOrder', node)
        if value is not None and 'zOrder' not in already_processed:
            already_processed.add('zOrder')
            self.zOrder = value
            self.validate_ExpressionOrIDREFType(self.zOrder)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('zPosition', node)
        if value is not None and 'zPosition' not in already_processed:
            already_processed.add('zPosition')
            self.zPosition = value
            self.validate_ExpressionOrIDREFType(self.zPosition)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('xOffset', node)
        if value is not None and 'xOffset' not in already_processed:
            already_processed.add('xOffset')
            self.xOffset = value
            self.validate_ExpressionOrIDREFType(self.xOffset)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('yOffset', node)
        if value is not None and 'yOffset' not in already_processed:
            already_processed.add('yOffset')
            self.yOffset = value
            self.validate_ExpressionOrIDREFType(self.yOffset)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('scalingFactor', node)
        if value is not None and 'scalingFactor' not in already_processed:
            already_processed.add('scalingFactor')
            self.scalingFactor = value
            self.validate_ExpressionOrIDREFType(self.scalingFactor)    # validate type ExpressionOrIDREFType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SectionType


class xtru(SolidType):
    """Poligonal extrusion is described by
    an unbounded (min. 3) number of vertices of the blueprint polygon
    and an unbounded number of Z sections."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, twoDimVertex=None, section=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(xtru, self).__init__(lunit, aunit, name,  **kwargs_)
        if twoDimVertex is None:
            self.twoDimVertex = []
        else:
            self.twoDimVertex = twoDimVertex
        self.twoDimVertex_nsprefix_ = None
        if section is None:
            self.section = []
        else:
            self.section = section
        self.section_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, xtru)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if xtru.subclass:
            return xtru.subclass(*args_, **kwargs_)
        else:
            return xtru(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_twoDimVertex(self):
        return self.twoDimVertex
    def set_twoDimVertex(self, twoDimVertex):
        self.twoDimVertex = twoDimVertex
    def add_twoDimVertex(self, value):
        self.twoDimVertex.append(value)
    def insert_twoDimVertex_at(self, index, value):
        self.twoDimVertex.insert(index, value)
    def replace_twoDimVertex_at(self, index, value):
        self.twoDimVertex[index] = value
    twoDimVertexProp = property(get_twoDimVertex, set_twoDimVertex)
    def get_section(self):
        return self.section
    def set_section(self, section):
        self.section = section
    def add_section(self, value):
        self.section.append(value)
    def insert_section_at(self, index, value):
        self.section.insert(index, value)
    def replace_section_at(self, index, value):
        self.section[index] = value
    sectionProp = property(get_section, set_section)
    def hasContent_(self):
        if (
            self.twoDimVertex or
            self.section or
            super(xtru, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='xtru', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('xtru')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'xtru':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='xtru')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='xtru', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='xtru'):
        super(xtru, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='xtru')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='xtru', fromsubclass_=False, pretty_print=True):
        super(xtru, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for twoDimVertex_ in self.twoDimVertex:
            namespaceprefix_ = self.twoDimVertex_nsprefix_ + ':' if (UseCapturedNS_ and self.twoDimVertex_nsprefix_) else ''
            twoDimVertex_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='twoDimVertex', pretty_print=pretty_print)
        for section_ in self.section:
            namespaceprefix_ = self.section_nsprefix_ + ':' if (UseCapturedNS_ and self.section_nsprefix_) else ''
            section_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='section', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='xtru', mapping_=None, nsmap_=None):
        element = super(xtru, self).to_etree(parent_element, name_, mapping_)
        for twoDimVertex_ in self.twoDimVertex:
            twoDimVertex_.to_etree(element, name_='twoDimVertex', mapping_=mapping_, nsmap_=nsmap_)
        for section_ in self.section:
            section_.to_etree(element, name_='section', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='xtru'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(xtru, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(xtru, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('twoDimVertex=[\n')
        level += 1
        for twoDimVertex_ in self.twoDimVertex:
            showIndent(outfile, level)
            outfile.write('model_.TwoDimVertexType(\n')
            twoDimVertex_.exportLiteral(outfile, level, name_='TwoDimVertexType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('section=[\n')
        level += 1
        for section_ in self.section:
            showIndent(outfile, level)
            outfile.write('model_.SectionType(\n')
            section_.exportLiteral(outfile, level, name_='SectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(xtru, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'twoDimVertex':
            obj_ = TwoDimVertexType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.twoDimVertex.append(obj_)
            obj_.original_tagname_ = 'twoDimVertex'
        elif nodeName_ == 'section':
            obj_ = SectionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.section.append(obj_)
            obj_.original_tagname_ = 'section'
        super(xtru, self).buildChildren(child_, node, nodeName_, True)
# end class xtru


class hype(SolidType):
    """Tube with hyperbolic profile described by
    rmin innerRadius
    rmax outerRadius
    inst innerStereo
    outst outerStereo
    z z length"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, rmin=None, rmax=None, inst=None, outst=None, z=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(hype, self).__init__(lunit, aunit, name,  **kwargs_)
        self.rmin = _cast(None, rmin)
        self.rmin_nsprefix_ = None
        self.rmax = _cast(None, rmax)
        self.rmax_nsprefix_ = None
        self.inst = _cast(None, inst)
        self.inst_nsprefix_ = None
        self.outst = _cast(None, outst)
        self.outst_nsprefix_ = None
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, hype)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if hype.subclass:
            return hype.subclass(*args_, **kwargs_)
        else:
            return hype(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_rmin(self):
        return self.rmin
    def set_rmin(self, rmin):
        self.rmin = rmin
    rminProp = property(get_rmin, set_rmin)
    def get_rmax(self):
        return self.rmax
    def set_rmax(self, rmax):
        self.rmax = rmax
    rmaxProp = property(get_rmax, set_rmax)
    def get_inst(self):
        return self.inst
    def set_inst(self, inst):
        self.inst = inst
    instProp = property(get_inst, set_inst)
    def get_outst(self):
        return self.outst
    def set_outst(self, outst):
        self.outst = outst
    outstProp = property(get_outst, set_outst)
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(hype, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='hype', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hype')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'hype':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hype')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='hype', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='hype'):
        super(hype, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hype')
        if self.rmin is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            outfile.write(' rmin=%s' % (quote_attrib(self.rmin), ))
        if self.rmax is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            outfile.write(' rmax=%s' % (quote_attrib(self.rmax), ))
        if self.inst is not None and 'inst' not in already_processed:
            already_processed.add('inst')
            outfile.write(' inst=%s' % (quote_attrib(self.inst), ))
        if self.outst is not None and 'outst' not in already_processed:
            already_processed.add('outst')
            outfile.write(' outst=%s' % (quote_attrib(self.outst), ))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='hype', fromsubclass_=False, pretty_print=True):
        super(hype, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='hype', mapping_=None, nsmap_=None):
        element = super(hype, self).to_etree(parent_element, name_, mapping_)
        if self.rmin is not None:
            element.set('rmin', self.rmin)
        if self.rmax is not None:
            element.set('rmax', self.rmax)
        if self.inst is not None:
            element.set('inst', self.inst)
        if self.outst is not None:
            element.set('outst', self.outst)
        if self.z is not None:
            element.set('z', self.z)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='hype'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rmin is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            showIndent(outfile, level)
            outfile.write('rmin=%s,\n' % (self.rmin,))
        if self.rmax is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            showIndent(outfile, level)
            outfile.write('rmax=%s,\n' % (self.rmax,))
        if self.inst is not None and 'inst' not in already_processed:
            already_processed.add('inst')
            showIndent(outfile, level)
            outfile.write('inst=%s,\n' % (self.inst,))
        if self.outst is not None and 'outst' not in already_processed:
            already_processed.add('outst')
            showIndent(outfile, level)
            outfile.write('outst=%s,\n' % (self.outst,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        super(hype, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(hype, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rmin', node)
        if value is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            self.rmin = value
            self.validate_ExpressionOrIDREFType(self.rmin)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmax', node)
        if value is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            self.rmax = value
            self.validate_ExpressionOrIDREFType(self.rmax)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('inst', node)
        if value is not None and 'inst' not in already_processed:
            already_processed.add('inst')
            self.inst = value
            self.validate_ExpressionOrIDREFType(self.inst)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('outst', node)
        if value is not None and 'outst' not in already_processed:
            already_processed.add('outst')
            self.outst = value
            self.validate_ExpressionOrIDREFType(self.outst)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        super(hype, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(hype, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class hype


class eltube(SolidType):
    """Volume representing a tube with elliptical
    cross section."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, dx=None, dy=None, dz=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(eltube, self).__init__(lunit, aunit, name,  **kwargs_)
        self.dx = _cast(None, dx)
        self.dx_nsprefix_ = None
        self.dy = _cast(None, dy)
        self.dy_nsprefix_ = None
        self.dz = _cast(None, dz)
        self.dz_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, eltube)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if eltube.subclass:
            return eltube.subclass(*args_, **kwargs_)
        else:
            return eltube(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dx(self):
        return self.dx
    def set_dx(self, dx):
        self.dx = dx
    dxProp = property(get_dx, set_dx)
    def get_dy(self):
        return self.dy
    def set_dy(self, dy):
        self.dy = dy
    dyProp = property(get_dy, set_dy)
    def get_dz(self):
        return self.dz
    def set_dz(self, dz):
        self.dz = dz
    dzProp = property(get_dz, set_dz)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(eltube, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='eltube', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('eltube')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'eltube':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='eltube')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='eltube', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='eltube'):
        super(eltube, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='eltube')
        if self.dx is not None and 'dx' not in already_processed:
            already_processed.add('dx')
            outfile.write(' dx=%s' % (quote_attrib(self.dx), ))
        if self.dy is not None and 'dy' not in already_processed:
            already_processed.add('dy')
            outfile.write(' dy=%s' % (quote_attrib(self.dy), ))
        if self.dz is not None and 'dz' not in already_processed:
            already_processed.add('dz')
            outfile.write(' dz=%s' % (quote_attrib(self.dz), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='eltube', fromsubclass_=False, pretty_print=True):
        super(eltube, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='eltube', mapping_=None, nsmap_=None):
        element = super(eltube, self).to_etree(parent_element, name_, mapping_)
        if self.dx is not None:
            element.set('dx', self.dx)
        if self.dy is not None:
            element.set('dy', self.dy)
        if self.dz is not None:
            element.set('dz', self.dz)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='eltube'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dx is not None and 'dx' not in already_processed:
            already_processed.add('dx')
            showIndent(outfile, level)
            outfile.write('dx=%s,\n' % (self.dx,))
        if self.dy is not None and 'dy' not in already_processed:
            already_processed.add('dy')
            showIndent(outfile, level)
            outfile.write('dy=%s,\n' % (self.dy,))
        if self.dz is not None and 'dz' not in already_processed:
            already_processed.add('dz')
            showIndent(outfile, level)
            outfile.write('dz=%s,\n' % (self.dz,))
        super(eltube, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(eltube, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dx', node)
        if value is not None and 'dx' not in already_processed:
            already_processed.add('dx')
            self.dx = value
            self.validate_ExpressionOrIDREFType(self.dx)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('dy', node)
        if value is not None and 'dy' not in already_processed:
            already_processed.add('dy')
            self.dy = value
            self.validate_ExpressionOrIDREFType(self.dy)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('dz', node)
        if value is not None and 'dz' not in already_processed:
            already_processed.add('dz')
            self.dz = value
            self.validate_ExpressionOrIDREFType(self.dz)    # validate type ExpressionOrIDREFType
        super(eltube, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(eltube, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class eltube


class tet(SolidType):
    """Volume representing a tetrahedron."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, vertex1=None, vertex2=None, vertex3=None, vertex4=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(tet, self).__init__(lunit, aunit, name,  **kwargs_)
        self.vertex1 = _cast(None, vertex1)
        self.vertex1_nsprefix_ = None
        self.vertex2 = _cast(None, vertex2)
        self.vertex2_nsprefix_ = None
        self.vertex3 = _cast(None, vertex3)
        self.vertex3_nsprefix_ = None
        self.vertex4 = _cast(None, vertex4)
        self.vertex4_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tet.subclass:
            return tet.subclass(*args_, **kwargs_)
        else:
            return tet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vertex1(self):
        return self.vertex1
    def set_vertex1(self, vertex1):
        self.vertex1 = vertex1
    vertex1Prop = property(get_vertex1, set_vertex1)
    def get_vertex2(self):
        return self.vertex2
    def set_vertex2(self, vertex2):
        self.vertex2 = vertex2
    vertex2Prop = property(get_vertex2, set_vertex2)
    def get_vertex3(self):
        return self.vertex3
    def set_vertex3(self, vertex3):
        self.vertex3 = vertex3
    vertex3Prop = property(get_vertex3, set_vertex3)
    def get_vertex4(self):
        return self.vertex4
    def set_vertex4(self, vertex4):
        self.vertex4 = vertex4
    vertex4Prop = property(get_vertex4, set_vertex4)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(tet, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tet', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tet':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tet', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tet'):
        super(tet, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tet')
        if self.vertex1 is not None and 'vertex1' not in already_processed:
            already_processed.add('vertex1')
            outfile.write(' vertex1=%s' % (quote_attrib(self.vertex1), ))
        if self.vertex2 is not None and 'vertex2' not in already_processed:
            already_processed.add('vertex2')
            outfile.write(' vertex2=%s' % (quote_attrib(self.vertex2), ))
        if self.vertex3 is not None and 'vertex3' not in already_processed:
            already_processed.add('vertex3')
            outfile.write(' vertex3=%s' % (quote_attrib(self.vertex3), ))
        if self.vertex4 is not None and 'vertex4' not in already_processed:
            already_processed.add('vertex4')
            outfile.write(' vertex4=%s' % (quote_attrib(self.vertex4), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tet', fromsubclass_=False, pretty_print=True):
        super(tet, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='tet', mapping_=None, nsmap_=None):
        element = super(tet, self).to_etree(parent_element, name_, mapping_)
        if self.vertex1 is not None:
            element.set('vertex1', self.vertex1)
        if self.vertex2 is not None:
            element.set('vertex2', self.vertex2)
        if self.vertex3 is not None:
            element.set('vertex3', self.vertex3)
        if self.vertex4 is not None:
            element.set('vertex4', self.vertex4)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='tet'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vertex1 is not None and 'vertex1' not in already_processed:
            already_processed.add('vertex1')
            showIndent(outfile, level)
            outfile.write('vertex1=%s,\n' % (self.vertex1,))
        if self.vertex2 is not None and 'vertex2' not in already_processed:
            already_processed.add('vertex2')
            showIndent(outfile, level)
            outfile.write('vertex2=%s,\n' % (self.vertex2,))
        if self.vertex3 is not None and 'vertex3' not in already_processed:
            already_processed.add('vertex3')
            showIndent(outfile, level)
            outfile.write('vertex3=%s,\n' % (self.vertex3,))
        if self.vertex4 is not None and 'vertex4' not in already_processed:
            already_processed.add('vertex4')
            showIndent(outfile, level)
            outfile.write('vertex4=%s,\n' % (self.vertex4,))
        super(tet, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(tet, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vertex1', node)
        if value is not None and 'vertex1' not in already_processed:
            already_processed.add('vertex1')
            self.vertex1 = value
            self.validate_ExpressionOrIDREFType(self.vertex1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('vertex2', node)
        if value is not None and 'vertex2' not in already_processed:
            already_processed.add('vertex2')
            self.vertex2 = value
            self.validate_ExpressionOrIDREFType(self.vertex2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('vertex3', node)
        if value is not None and 'vertex3' not in already_processed:
            already_processed.add('vertex3')
            self.vertex3 = value
            self.validate_ExpressionOrIDREFType(self.vertex3)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('vertex4', node)
        if value is not None and 'vertex4' not in already_processed:
            already_processed.add('vertex4')
            self.vertex4 = value
            self.validate_ExpressionOrIDREFType(self.vertex4)    # validate type ExpressionOrIDREFType
        super(tet, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(tet, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tet


class arb8(SolidType):
    """Volume representing an (almost)arbitrary 8 vertices solid.
    The solid is defined by two quadrilaterals sitting on parallel planes,
    the distance between these two planes is dz*2.
    The base quadrilateral contained within the plane located at -dz is defined
    by
    the first 4 vertices (v1,v2,v3,v4 each one with the x and y coordinates).
    The other parallel quadrilateral contained within the plane at +dz is
    defined by
    the other 4 vertices (v5,v6,v7,v8 each one with the x and y
    coordinates)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, v1x=None, v1y=None, v2x=None, v2y=None, v3x=None, v3y=None, v4x=None, v4y=None, v5x=None, v5y=None, v6x=None, v6y=None, v7x=None, v7y=None, v8x=None, v8y=None, dz=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(arb8, self).__init__(lunit, aunit, name,  **kwargs_)
        self.v1x = _cast(None, v1x)
        self.v1x_nsprefix_ = None
        self.v1y = _cast(None, v1y)
        self.v1y_nsprefix_ = None
        self.v2x = _cast(None, v2x)
        self.v2x_nsprefix_ = None
        self.v2y = _cast(None, v2y)
        self.v2y_nsprefix_ = None
        self.v3x = _cast(None, v3x)
        self.v3x_nsprefix_ = None
        self.v3y = _cast(None, v3y)
        self.v3y_nsprefix_ = None
        self.v4x = _cast(None, v4x)
        self.v4x_nsprefix_ = None
        self.v4y = _cast(None, v4y)
        self.v4y_nsprefix_ = None
        self.v5x = _cast(None, v5x)
        self.v5x_nsprefix_ = None
        self.v5y = _cast(None, v5y)
        self.v5y_nsprefix_ = None
        self.v6x = _cast(None, v6x)
        self.v6x_nsprefix_ = None
        self.v6y = _cast(None, v6y)
        self.v6y_nsprefix_ = None
        self.v7x = _cast(None, v7x)
        self.v7x_nsprefix_ = None
        self.v7y = _cast(None, v7y)
        self.v7y_nsprefix_ = None
        self.v8x = _cast(None, v8x)
        self.v8x_nsprefix_ = None
        self.v8y = _cast(None, v8y)
        self.v8y_nsprefix_ = None
        self.dz = _cast(None, dz)
        self.dz_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, arb8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if arb8.subclass:
            return arb8.subclass(*args_, **kwargs_)
        else:
            return arb8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_v1x(self):
        return self.v1x
    def set_v1x(self, v1x):
        self.v1x = v1x
    v1xProp = property(get_v1x, set_v1x)
    def get_v1y(self):
        return self.v1y
    def set_v1y(self, v1y):
        self.v1y = v1y
    v1yProp = property(get_v1y, set_v1y)
    def get_v2x(self):
        return self.v2x
    def set_v2x(self, v2x):
        self.v2x = v2x
    v2xProp = property(get_v2x, set_v2x)
    def get_v2y(self):
        return self.v2y
    def set_v2y(self, v2y):
        self.v2y = v2y
    v2yProp = property(get_v2y, set_v2y)
    def get_v3x(self):
        return self.v3x
    def set_v3x(self, v3x):
        self.v3x = v3x
    v3xProp = property(get_v3x, set_v3x)
    def get_v3y(self):
        return self.v3y
    def set_v3y(self, v3y):
        self.v3y = v3y
    v3yProp = property(get_v3y, set_v3y)
    def get_v4x(self):
        return self.v4x
    def set_v4x(self, v4x):
        self.v4x = v4x
    v4xProp = property(get_v4x, set_v4x)
    def get_v4y(self):
        return self.v4y
    def set_v4y(self, v4y):
        self.v4y = v4y
    v4yProp = property(get_v4y, set_v4y)
    def get_v5x(self):
        return self.v5x
    def set_v5x(self, v5x):
        self.v5x = v5x
    v5xProp = property(get_v5x, set_v5x)
    def get_v5y(self):
        return self.v5y
    def set_v5y(self, v5y):
        self.v5y = v5y
    v5yProp = property(get_v5y, set_v5y)
    def get_v6x(self):
        return self.v6x
    def set_v6x(self, v6x):
        self.v6x = v6x
    v6xProp = property(get_v6x, set_v6x)
    def get_v6y(self):
        return self.v6y
    def set_v6y(self, v6y):
        self.v6y = v6y
    v6yProp = property(get_v6y, set_v6y)
    def get_v7x(self):
        return self.v7x
    def set_v7x(self, v7x):
        self.v7x = v7x
    v7xProp = property(get_v7x, set_v7x)
    def get_v7y(self):
        return self.v7y
    def set_v7y(self, v7y):
        self.v7y = v7y
    v7yProp = property(get_v7y, set_v7y)
    def get_v8x(self):
        return self.v8x
    def set_v8x(self, v8x):
        self.v8x = v8x
    v8xProp = property(get_v8x, set_v8x)
    def get_v8y(self):
        return self.v8y
    def set_v8y(self, v8y):
        self.v8y = v8y
    v8yProp = property(get_v8y, set_v8y)
    def get_dz(self):
        return self.dz
    def set_dz(self, dz):
        self.dz = dz
    dzProp = property(get_dz, set_dz)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(arb8, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='arb8', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('arb8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'arb8':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='arb8')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='arb8', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='arb8'):
        super(arb8, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='arb8')
        if self.v1x is not None and 'v1x' not in already_processed:
            already_processed.add('v1x')
            outfile.write(' v1x=%s' % (quote_attrib(self.v1x), ))
        if self.v1y is not None and 'v1y' not in already_processed:
            already_processed.add('v1y')
            outfile.write(' v1y=%s' % (quote_attrib(self.v1y), ))
        if self.v2x is not None and 'v2x' not in already_processed:
            already_processed.add('v2x')
            outfile.write(' v2x=%s' % (quote_attrib(self.v2x), ))
        if self.v2y is not None and 'v2y' not in already_processed:
            already_processed.add('v2y')
            outfile.write(' v2y=%s' % (quote_attrib(self.v2y), ))
        if self.v3x is not None and 'v3x' not in already_processed:
            already_processed.add('v3x')
            outfile.write(' v3x=%s' % (quote_attrib(self.v3x), ))
        if self.v3y is not None and 'v3y' not in already_processed:
            already_processed.add('v3y')
            outfile.write(' v3y=%s' % (quote_attrib(self.v3y), ))
        if self.v4x is not None and 'v4x' not in already_processed:
            already_processed.add('v4x')
            outfile.write(' v4x=%s' % (quote_attrib(self.v4x), ))
        if self.v4y is not None and 'v4y' not in already_processed:
            already_processed.add('v4y')
            outfile.write(' v4y=%s' % (quote_attrib(self.v4y), ))
        if self.v5x is not None and 'v5x' not in already_processed:
            already_processed.add('v5x')
            outfile.write(' v5x=%s' % (quote_attrib(self.v5x), ))
        if self.v5y is not None and 'v5y' not in already_processed:
            already_processed.add('v5y')
            outfile.write(' v5y=%s' % (quote_attrib(self.v5y), ))
        if self.v6x is not None and 'v6x' not in already_processed:
            already_processed.add('v6x')
            outfile.write(' v6x=%s' % (quote_attrib(self.v6x), ))
        if self.v6y is not None and 'v6y' not in already_processed:
            already_processed.add('v6y')
            outfile.write(' v6y=%s' % (quote_attrib(self.v6y), ))
        if self.v7x is not None and 'v7x' not in already_processed:
            already_processed.add('v7x')
            outfile.write(' v7x=%s' % (quote_attrib(self.v7x), ))
        if self.v7y is not None and 'v7y' not in already_processed:
            already_processed.add('v7y')
            outfile.write(' v7y=%s' % (quote_attrib(self.v7y), ))
        if self.v8x is not None and 'v8x' not in already_processed:
            already_processed.add('v8x')
            outfile.write(' v8x=%s' % (quote_attrib(self.v8x), ))
        if self.v8y is not None and 'v8y' not in already_processed:
            already_processed.add('v8y')
            outfile.write(' v8y=%s' % (quote_attrib(self.v8y), ))
        if self.dz is not None and 'dz' not in already_processed:
            already_processed.add('dz')
            outfile.write(' dz=%s' % (quote_attrib(self.dz), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='arb8', fromsubclass_=False, pretty_print=True):
        super(arb8, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='arb8', mapping_=None, nsmap_=None):
        element = super(arb8, self).to_etree(parent_element, name_, mapping_)
        if self.v1x is not None:
            element.set('v1x', self.v1x)
        if self.v1y is not None:
            element.set('v1y', self.v1y)
        if self.v2x is not None:
            element.set('v2x', self.v2x)
        if self.v2y is not None:
            element.set('v2y', self.v2y)
        if self.v3x is not None:
            element.set('v3x', self.v3x)
        if self.v3y is not None:
            element.set('v3y', self.v3y)
        if self.v4x is not None:
            element.set('v4x', self.v4x)
        if self.v4y is not None:
            element.set('v4y', self.v4y)
        if self.v5x is not None:
            element.set('v5x', self.v5x)
        if self.v5y is not None:
            element.set('v5y', self.v5y)
        if self.v6x is not None:
            element.set('v6x', self.v6x)
        if self.v6y is not None:
            element.set('v6y', self.v6y)
        if self.v7x is not None:
            element.set('v7x', self.v7x)
        if self.v7y is not None:
            element.set('v7y', self.v7y)
        if self.v8x is not None:
            element.set('v8x', self.v8x)
        if self.v8y is not None:
            element.set('v8y', self.v8y)
        if self.dz is not None:
            element.set('dz', self.dz)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='arb8'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.v1x is not None and 'v1x' not in already_processed:
            already_processed.add('v1x')
            showIndent(outfile, level)
            outfile.write('v1x=%s,\n' % (self.v1x,))
        if self.v1y is not None and 'v1y' not in already_processed:
            already_processed.add('v1y')
            showIndent(outfile, level)
            outfile.write('v1y=%s,\n' % (self.v1y,))
        if self.v2x is not None and 'v2x' not in already_processed:
            already_processed.add('v2x')
            showIndent(outfile, level)
            outfile.write('v2x=%s,\n' % (self.v2x,))
        if self.v2y is not None and 'v2y' not in already_processed:
            already_processed.add('v2y')
            showIndent(outfile, level)
            outfile.write('v2y=%s,\n' % (self.v2y,))
        if self.v3x is not None and 'v3x' not in already_processed:
            already_processed.add('v3x')
            showIndent(outfile, level)
            outfile.write('v3x=%s,\n' % (self.v3x,))
        if self.v3y is not None and 'v3y' not in already_processed:
            already_processed.add('v3y')
            showIndent(outfile, level)
            outfile.write('v3y=%s,\n' % (self.v3y,))
        if self.v4x is not None and 'v4x' not in already_processed:
            already_processed.add('v4x')
            showIndent(outfile, level)
            outfile.write('v4x=%s,\n' % (self.v4x,))
        if self.v4y is not None and 'v4y' not in already_processed:
            already_processed.add('v4y')
            showIndent(outfile, level)
            outfile.write('v4y=%s,\n' % (self.v4y,))
        if self.v5x is not None and 'v5x' not in already_processed:
            already_processed.add('v5x')
            showIndent(outfile, level)
            outfile.write('v5x=%s,\n' % (self.v5x,))
        if self.v5y is not None and 'v5y' not in already_processed:
            already_processed.add('v5y')
            showIndent(outfile, level)
            outfile.write('v5y=%s,\n' % (self.v5y,))
        if self.v6x is not None and 'v6x' not in already_processed:
            already_processed.add('v6x')
            showIndent(outfile, level)
            outfile.write('v6x=%s,\n' % (self.v6x,))
        if self.v6y is not None and 'v6y' not in already_processed:
            already_processed.add('v6y')
            showIndent(outfile, level)
            outfile.write('v6y=%s,\n' % (self.v6y,))
        if self.v7x is not None and 'v7x' not in already_processed:
            already_processed.add('v7x')
            showIndent(outfile, level)
            outfile.write('v7x=%s,\n' % (self.v7x,))
        if self.v7y is not None and 'v7y' not in already_processed:
            already_processed.add('v7y')
            showIndent(outfile, level)
            outfile.write('v7y=%s,\n' % (self.v7y,))
        if self.v8x is not None and 'v8x' not in already_processed:
            already_processed.add('v8x')
            showIndent(outfile, level)
            outfile.write('v8x=%s,\n' % (self.v8x,))
        if self.v8y is not None and 'v8y' not in already_processed:
            already_processed.add('v8y')
            showIndent(outfile, level)
            outfile.write('v8y=%s,\n' % (self.v8y,))
        if self.dz is not None and 'dz' not in already_processed:
            already_processed.add('dz')
            showIndent(outfile, level)
            outfile.write('dz=%s,\n' % (self.dz,))
        super(arb8, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(arb8, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('v1x', node)
        if value is not None and 'v1x' not in already_processed:
            already_processed.add('v1x')
            self.v1x = value
            self.validate_ExpressionOrIDREFType(self.v1x)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('v1y', node)
        if value is not None and 'v1y' not in already_processed:
            already_processed.add('v1y')
            self.v1y = value
            self.validate_ExpressionOrIDREFType(self.v1y)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('v2x', node)
        if value is not None and 'v2x' not in already_processed:
            already_processed.add('v2x')
            self.v2x = value
            self.validate_ExpressionOrIDREFType(self.v2x)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('v2y', node)
        if value is not None and 'v2y' not in already_processed:
            already_processed.add('v2y')
            self.v2y = value
            self.validate_ExpressionOrIDREFType(self.v2y)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('v3x', node)
        if value is not None and 'v3x' not in already_processed:
            already_processed.add('v3x')
            self.v3x = value
            self.validate_ExpressionOrIDREFType(self.v3x)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('v3y', node)
        if value is not None and 'v3y' not in already_processed:
            already_processed.add('v3y')
            self.v3y = value
            self.validate_ExpressionOrIDREFType(self.v3y)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('v4x', node)
        if value is not None and 'v4x' not in already_processed:
            already_processed.add('v4x')
            self.v4x = value
            self.validate_ExpressionOrIDREFType(self.v4x)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('v4y', node)
        if value is not None and 'v4y' not in already_processed:
            already_processed.add('v4y')
            self.v4y = value
            self.validate_ExpressionOrIDREFType(self.v4y)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('v5x', node)
        if value is not None and 'v5x' not in already_processed:
            already_processed.add('v5x')
            self.v5x = value
            self.validate_ExpressionOrIDREFType(self.v5x)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('v5y', node)
        if value is not None and 'v5y' not in already_processed:
            already_processed.add('v5y')
            self.v5y = value
            self.validate_ExpressionOrIDREFType(self.v5y)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('v6x', node)
        if value is not None and 'v6x' not in already_processed:
            already_processed.add('v6x')
            self.v6x = value
            self.validate_ExpressionOrIDREFType(self.v6x)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('v6y', node)
        if value is not None and 'v6y' not in already_processed:
            already_processed.add('v6y')
            self.v6y = value
            self.validate_ExpressionOrIDREFType(self.v6y)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('v7x', node)
        if value is not None and 'v7x' not in already_processed:
            already_processed.add('v7x')
            self.v7x = value
            self.validate_ExpressionOrIDREFType(self.v7x)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('v7y', node)
        if value is not None and 'v7y' not in already_processed:
            already_processed.add('v7y')
            self.v7y = value
            self.validate_ExpressionOrIDREFType(self.v7y)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('v8x', node)
        if value is not None and 'v8x' not in already_processed:
            already_processed.add('v8x')
            self.v8x = value
            self.validate_ExpressionOrIDREFType(self.v8x)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('v8y', node)
        if value is not None and 'v8y' not in already_processed:
            already_processed.add('v8y')
            self.v8y = value
            self.validate_ExpressionOrIDREFType(self.v8y)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('dz', node)
        if value is not None and 'dz' not in already_processed:
            already_processed.add('dz')
            self.dz = value
            self.validate_ExpressionOrIDREFType(self.dz)    # validate type ExpressionOrIDREFType
        super(arb8, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(arb8, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class arb8


class FacetType(GeneratedsSuper):
    """Base facet type"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FacetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FacetType.subclass:
            return FacetType.subclass(*args_, **kwargs_)
        else:
            return FacetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FacetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FacetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FacetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FacetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FacetType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FacetType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FacetType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='FacetType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='FacetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class FacetType


class triangular(FacetType):
    """Triangular facet."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FacetType
    def __init__(self, vertex1=None, vertex2=None, vertex3=None, type_='ABSOLUTE', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(triangular, self).__init__( **kwargs_)
        self.vertex1 = _cast(None, vertex1)
        self.vertex1_nsprefix_ = None
        self.vertex2 = _cast(None, vertex2)
        self.vertex2_nsprefix_ = None
        self.vertex3 = _cast(None, vertex3)
        self.vertex3_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, triangular)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if triangular.subclass:
            return triangular.subclass(*args_, **kwargs_)
        else:
            return triangular(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vertex1(self):
        return self.vertex1
    def set_vertex1(self, vertex1):
        self.vertex1 = vertex1
    vertex1Prop = property(get_vertex1, set_vertex1)
    def get_vertex2(self):
        return self.vertex2
    def set_vertex2(self, vertex2):
        self.vertex2 = vertex2
    vertex2Prop = property(get_vertex2, set_vertex2)
    def get_vertex3(self):
        return self.vertex3
    def set_vertex3(self, vertex3):
        self.vertex3 = vertex3
    vertex3Prop = property(get_vertex3, set_vertex3)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(triangular, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='triangular', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('triangular')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'triangular':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='triangular')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='triangular', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='triangular'):
        super(triangular, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='triangular')
        if self.vertex1 is not None and 'vertex1' not in already_processed:
            already_processed.add('vertex1')
            outfile.write(' vertex1=%s' % (quote_attrib(self.vertex1), ))
        if self.vertex2 is not None and 'vertex2' not in already_processed:
            already_processed.add('vertex2')
            outfile.write(' vertex2=%s' % (quote_attrib(self.vertex2), ))
        if self.vertex3 is not None and 'vertex3' not in already_processed:
            already_processed.add('vertex3')
            outfile.write(' vertex3=%s' % (quote_attrib(self.vertex3), ))
        if self.type_ != "ABSOLUTE" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='triangular', fromsubclass_=False, pretty_print=True):
        super(triangular, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='triangular', mapping_=None, nsmap_=None):
        element = super(triangular, self).to_etree(parent_element, name_, mapping_)
        if self.vertex1 is not None:
            element.set('vertex1', self.vertex1)
        if self.vertex2 is not None:
            element.set('vertex2', self.vertex2)
        if self.vertex3 is not None:
            element.set('vertex3', self.vertex3)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='triangular'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vertex1 is not None and 'vertex1' not in already_processed:
            already_processed.add('vertex1')
            showIndent(outfile, level)
            outfile.write('vertex1=%s,\n' % (self.vertex1,))
        if self.vertex2 is not None and 'vertex2' not in already_processed:
            already_processed.add('vertex2')
            showIndent(outfile, level)
            outfile.write('vertex2=%s,\n' % (self.vertex2,))
        if self.vertex3 is not None and 'vertex3' not in already_processed:
            already_processed.add('vertex3')
            showIndent(outfile, level)
            outfile.write('vertex3=%s,\n' % (self.vertex3,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(triangular, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(triangular, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vertex1', node)
        if value is not None and 'vertex1' not in already_processed:
            already_processed.add('vertex1')
            self.vertex1 = value
            self.validate_ExpressionOrIDREFType(self.vertex1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('vertex2', node)
        if value is not None and 'vertex2' not in already_processed:
            already_processed.add('vertex2')
            self.vertex2 = value
            self.validate_ExpressionOrIDREFType(self.vertex2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('vertex3', node)
        if value is not None and 'vertex3' not in already_processed:
            already_processed.add('vertex3')
            self.vertex3 = value
            self.validate_ExpressionOrIDREFType(self.vertex3)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(triangular, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(triangular, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class triangular


class quadrangular(FacetType):
    """Quadrangular facet."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FacetType
    def __init__(self, vertex1=None, vertex2=None, vertex3=None, vertex4=None, type_='ABSOLUTE', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(quadrangular, self).__init__( **kwargs_)
        self.vertex1 = _cast(None, vertex1)
        self.vertex1_nsprefix_ = None
        self.vertex2 = _cast(None, vertex2)
        self.vertex2_nsprefix_ = None
        self.vertex3 = _cast(None, vertex3)
        self.vertex3_nsprefix_ = None
        self.vertex4 = _cast(None, vertex4)
        self.vertex4_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, quadrangular)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if quadrangular.subclass:
            return quadrangular.subclass(*args_, **kwargs_)
        else:
            return quadrangular(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vertex1(self):
        return self.vertex1
    def set_vertex1(self, vertex1):
        self.vertex1 = vertex1
    vertex1Prop = property(get_vertex1, set_vertex1)
    def get_vertex2(self):
        return self.vertex2
    def set_vertex2(self, vertex2):
        self.vertex2 = vertex2
    vertex2Prop = property(get_vertex2, set_vertex2)
    def get_vertex3(self):
        return self.vertex3
    def set_vertex3(self, vertex3):
        self.vertex3 = vertex3
    vertex3Prop = property(get_vertex3, set_vertex3)
    def get_vertex4(self):
        return self.vertex4
    def set_vertex4(self, vertex4):
        self.vertex4 = vertex4
    vertex4Prop = property(get_vertex4, set_vertex4)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(quadrangular, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='quadrangular', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('quadrangular')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'quadrangular':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='quadrangular')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='quadrangular', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='quadrangular'):
        super(quadrangular, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='quadrangular')
        if self.vertex1 is not None and 'vertex1' not in already_processed:
            already_processed.add('vertex1')
            outfile.write(' vertex1=%s' % (quote_attrib(self.vertex1), ))
        if self.vertex2 is not None and 'vertex2' not in already_processed:
            already_processed.add('vertex2')
            outfile.write(' vertex2=%s' % (quote_attrib(self.vertex2), ))
        if self.vertex3 is not None and 'vertex3' not in already_processed:
            already_processed.add('vertex3')
            outfile.write(' vertex3=%s' % (quote_attrib(self.vertex3), ))
        if self.vertex4 is not None and 'vertex4' not in already_processed:
            already_processed.add('vertex4')
            outfile.write(' vertex4=%s' % (quote_attrib(self.vertex4), ))
        if self.type_ != "ABSOLUTE" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='quadrangular', fromsubclass_=False, pretty_print=True):
        super(quadrangular, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='quadrangular', mapping_=None, nsmap_=None):
        element = super(quadrangular, self).to_etree(parent_element, name_, mapping_)
        if self.vertex1 is not None:
            element.set('vertex1', self.vertex1)
        if self.vertex2 is not None:
            element.set('vertex2', self.vertex2)
        if self.vertex3 is not None:
            element.set('vertex3', self.vertex3)
        if self.vertex4 is not None:
            element.set('vertex4', self.vertex4)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='quadrangular'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vertex1 is not None and 'vertex1' not in already_processed:
            already_processed.add('vertex1')
            showIndent(outfile, level)
            outfile.write('vertex1=%s,\n' % (self.vertex1,))
        if self.vertex2 is not None and 'vertex2' not in already_processed:
            already_processed.add('vertex2')
            showIndent(outfile, level)
            outfile.write('vertex2=%s,\n' % (self.vertex2,))
        if self.vertex3 is not None and 'vertex3' not in already_processed:
            already_processed.add('vertex3')
            showIndent(outfile, level)
            outfile.write('vertex3=%s,\n' % (self.vertex3,))
        if self.vertex4 is not None and 'vertex4' not in already_processed:
            already_processed.add('vertex4')
            showIndent(outfile, level)
            outfile.write('vertex4=%s,\n' % (self.vertex4,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(quadrangular, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(quadrangular, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vertex1', node)
        if value is not None and 'vertex1' not in already_processed:
            already_processed.add('vertex1')
            self.vertex1 = value
            self.validate_ExpressionOrIDREFType(self.vertex1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('vertex2', node)
        if value is not None and 'vertex2' not in already_processed:
            already_processed.add('vertex2')
            self.vertex2 = value
            self.validate_ExpressionOrIDREFType(self.vertex2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('vertex3', node)
        if value is not None and 'vertex3' not in already_processed:
            already_processed.add('vertex3')
            self.vertex3 = value
            self.validate_ExpressionOrIDREFType(self.vertex3)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('vertex4', node)
        if value is not None and 'vertex4' not in already_processed:
            already_processed.add('vertex4')
            self.vertex4 = value
            self.validate_ExpressionOrIDREFType(self.vertex4)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(quadrangular, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(quadrangular, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class quadrangular


class tessellated(SolidType):
    """Tessellated solid"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SolidType
    def __init__(self, lunit='mm', aunit='radian', name=None, Facet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(tessellated, self).__init__(lunit, aunit, name,  **kwargs_)
        if Facet is None:
            self.Facet = []
        else:
            self.Facet = Facet
        self.Facet_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tessellated)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tessellated.subclass:
            return tessellated.subclass(*args_, **kwargs_)
        else:
            return tessellated(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Facet(self):
        return self.Facet
    def set_Facet(self, Facet):
        self.Facet = Facet
    def add_Facet(self, value):
        self.Facet.append(value)
    def insert_Facet_at(self, index, value):
        self.Facet.insert(index, value)
    def replace_Facet_at(self, index, value):
        self.Facet[index] = value
    FacetProp = property(get_Facet, set_Facet)
    def hasContent_(self):
        if (
            self.Facet or
            super(tessellated, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tessellated', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tessellated')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tessellated':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tessellated')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tessellated', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tessellated'):
        super(tessellated, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tessellated')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tessellated', fromsubclass_=False, pretty_print=True):
        super(tessellated, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Facet_ in self.Facet:
            namespaceprefix_ = self.Facet_nsprefix_ + ':' if (UseCapturedNS_ and self.Facet_nsprefix_) else ''
            Facet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Facet', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='tessellated', mapping_=None, nsmap_=None):
        element = super(tessellated, self).to_etree(parent_element, name_, mapping_)
        for Facet_ in self.Facet:
            Facet_.to_etree(element, name_='Facet', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='tessellated'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(tessellated, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(tessellated, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Facet=[\n')
        level += 1
        for Facet_ in self.Facet:
            showIndent(outfile, level)
            outfile.write('model_.FacetType(\n')
            Facet_.exportLiteral(outfile, level, name_='FacetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tessellated, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Facet':
            class_obj_ = self.get_class_obj_(child_, FacetType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Facet.append(obj_)
            obj_.original_tagname_ = 'Facet'
        elif nodeName_ == 'triangular':
            obj_ = triangular.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Facet.append(obj_)
            obj_.original_tagname_ = 'triangular'
        elif nodeName_ == 'quadrangular':
            obj_ = quadrangular.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Facet.append(obj_)
            obj_.original_tagname_ = 'quadrangular'
        super(tessellated, self).buildChildren(child_, node, nodeName_, True)
# end class tessellated


class opticalsurface(SurfacePropertyType):
    """Optical surface used by Geant4 optical processes"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SurfacePropertyType
    def __init__(self, name=None, type_='dielectric_dielectric', property=None, model='glisur', finish='polished', value='1.0', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(opticalsurface, self).__init__(name, type_, property,  **kwargs_)
        self.model = _cast(None, model)
        self.model_nsprefix_ = None
        self.finish = _cast(None, finish)
        self.finish_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, opticalsurface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if opticalsurface.subclass:
            return opticalsurface.subclass(*args_, **kwargs_)
        else:
            return opticalsurface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_model(self):
        return self.model
    def set_model(self, model):
        self.model = model
    modelProp = property(get_model, set_model)
    def get_finish(self):
        return self.finish
    def set_finish(self, finish):
        self.finish = finish
    finishProp = property(get_finish, set_finish)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    valueProp = property(get_value, set_value)
    def hasContent_(self):
        if (
            super(opticalsurface, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='opticalsurface', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('opticalsurface')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'opticalsurface':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='opticalsurface')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='opticalsurface', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='opticalsurface'):
        super(opticalsurface, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='opticalsurface')
        if self.model != "glisur" and 'model' not in already_processed:
            already_processed.add('model')
            outfile.write(' model=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.model), input_name='model')), ))
        if self.finish != "polished" and 'finish' not in already_processed:
            already_processed.add('finish')
            outfile.write(' finish=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.finish), input_name='finish')), ))
        if self.value != "1.0" and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='opticalsurface', fromsubclass_=False, pretty_print=True):
        super(opticalsurface, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='opticalsurface', mapping_=None, nsmap_=None):
        element = super(opticalsurface, self).to_etree(parent_element, name_, mapping_)
        if self.model is not None:
            element.set('model', self.gds_format_string(self.model))
        if self.finish is not None:
            element.set('finish', self.gds_format_string(self.finish))
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='opticalsurface'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.model is not None and 'model' not in already_processed:
            already_processed.add('model')
            showIndent(outfile, level)
            outfile.write('model="%s",\n' % (self.model,))
        if self.finish is not None and 'finish' not in already_processed:
            already_processed.add('finish')
            showIndent(outfile, level)
            outfile.write('finish="%s",\n' % (self.finish,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        super(opticalsurface, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(opticalsurface, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('model', node)
        if value is not None and 'model' not in already_processed:
            already_processed.add('model')
            self.model = value
        value = find_attr_value_('finish', node)
        if value is not None and 'finish' not in already_processed:
            already_processed.add('finish')
            self.finish = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        super(opticalsurface, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(opticalsurface, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class opticalsurface


class ReplicationAlgorithmType(GeneratedsSuper):
    """Abstract base for replication placement strategies"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReplicationAlgorithmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReplicationAlgorithmType.subclass:
            return ReplicationAlgorithmType.subclass(*args_, **kwargs_)
        else:
            return ReplicationAlgorithmType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReplicationAlgorithmType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReplicationAlgorithmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReplicationAlgorithmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReplicationAlgorithmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReplicationAlgorithmType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReplicationAlgorithmType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReplicationAlgorithmType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='ReplicationAlgorithmType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ReplicationAlgorithmType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ReplicationAlgorithmType


class AxisReplicationAlgorithmType(ReplicationAlgorithmType):
    """Replica volumes get created along the specified direction
    starting with the first replica placed at the given position and rotated
    according to the given rotation and others placed using the given distance;
    If position and/or rotation is omitted the defaults will be applied, e.g.
    position at the mother volume center and identity rotation;
    NOTE: THE ROTATION IS APPLIED TO ALL REPLICATED VOLUMES!"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ReplicationAlgorithmType
    def __init__(self, position=None, positionref=None, rotation=None, rotationref=None, direction=None, directionref=None, width=None, offset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(AxisReplicationAlgorithmType, self).__init__( **kwargs_)
        self.position = position
        self.position_nsprefix_ = None
        self.positionref = positionref
        self.positionref_nsprefix_ = None
        self.rotation = rotation
        self.rotation_nsprefix_ = None
        self.rotationref = rotationref
        self.rotationref_nsprefix_ = None
        self.direction = direction
        self.direction_nsprefix_ = None
        self.directionref = directionref
        self.directionref_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.offset = offset
        self.offset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AxisReplicationAlgorithmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AxisReplicationAlgorithmType.subclass:
            return AxisReplicationAlgorithmType.subclass(*args_, **kwargs_)
        else:
            return AxisReplicationAlgorithmType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    positionProp = property(get_position, set_position)
    def get_positionref(self):
        return self.positionref
    def set_positionref(self, positionref):
        self.positionref = positionref
    positionrefProp = property(get_positionref, set_positionref)
    def get_rotation(self):
        return self.rotation
    def set_rotation(self, rotation):
        self.rotation = rotation
    rotationProp = property(get_rotation, set_rotation)
    def get_rotationref(self):
        return self.rotationref
    def set_rotationref(self, rotationref):
        self.rotationref = rotationref
    rotationrefProp = property(get_rotationref, set_rotationref)
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    directionProp = property(get_direction, set_direction)
    def get_directionref(self):
        return self.directionref
    def set_directionref(self, directionref):
        self.directionref = directionref
    directionrefProp = property(get_directionref, set_directionref)
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    widthProp = property(get_width, set_width)
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    offsetProp = property(get_offset, set_offset)
    def hasContent_(self):
        if (
            self.position is not None or
            self.positionref is not None or
            self.rotation is not None or
            self.rotationref is not None or
            self.direction is not None or
            self.directionref is not None or
            self.width is not None or
            self.offset is not None or
            super(AxisReplicationAlgorithmType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AxisReplicationAlgorithmType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AxisReplicationAlgorithmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AxisReplicationAlgorithmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AxisReplicationAlgorithmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AxisReplicationAlgorithmType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AxisReplicationAlgorithmType'):
        super(AxisReplicationAlgorithmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AxisReplicationAlgorithmType')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AxisReplicationAlgorithmType', fromsubclass_=False, pretty_print=True):
        super(AxisReplicationAlgorithmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.position is not None:
            namespaceprefix_ = self.position_nsprefix_ + ':' if (UseCapturedNS_ and self.position_nsprefix_) else ''
            self.position.export(outfile, level, namespaceprefix_, namespacedef_='', name_='position', pretty_print=pretty_print)
        if self.positionref is not None:
            namespaceprefix_ = self.positionref_nsprefix_ + ':' if (UseCapturedNS_ and self.positionref_nsprefix_) else ''
            self.positionref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='positionref', pretty_print=pretty_print)
        if self.rotation is not None:
            namespaceprefix_ = self.rotation_nsprefix_ + ':' if (UseCapturedNS_ and self.rotation_nsprefix_) else ''
            self.rotation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rotation', pretty_print=pretty_print)
        if self.rotationref is not None:
            namespaceprefix_ = self.rotationref_nsprefix_ + ':' if (UseCapturedNS_ and self.rotationref_nsprefix_) else ''
            self.rotationref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rotationref', pretty_print=pretty_print)
        if self.direction is not None:
            namespaceprefix_ = self.direction_nsprefix_ + ':' if (UseCapturedNS_ and self.direction_nsprefix_) else ''
            self.direction.export(outfile, level, namespaceprefix_, namespacedef_='', name_='direction', pretty_print=pretty_print)
        if self.directionref is not None:
            namespaceprefix_ = self.directionref_nsprefix_ + ':' if (UseCapturedNS_ and self.directionref_nsprefix_) else ''
            self.directionref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='directionref', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.offset is not None:
            namespaceprefix_ = self.offset_nsprefix_ + ':' if (UseCapturedNS_ and self.offset_nsprefix_) else ''
            self.offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='offset', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AxisReplicationAlgorithmType', mapping_=None, nsmap_=None):
        element = super(AxisReplicationAlgorithmType, self).to_etree(parent_element, name_, mapping_)
        if self.position is not None:
            position_ = self.position
            position_.to_etree(element, name_='position', mapping_=mapping_, nsmap_=nsmap_)
        if self.positionref is not None:
            positionref_ = self.positionref
            positionref_.to_etree(element, name_='positionref', mapping_=mapping_, nsmap_=nsmap_)
        if self.rotation is not None:
            rotation_ = self.rotation
            rotation_.to_etree(element, name_='rotation', mapping_=mapping_, nsmap_=nsmap_)
        if self.rotationref is not None:
            rotationref_ = self.rotationref
            rotationref_.to_etree(element, name_='rotationref', mapping_=mapping_, nsmap_=nsmap_)
        if self.direction is not None:
            direction_ = self.direction
            direction_.to_etree(element, name_='direction', mapping_=mapping_, nsmap_=nsmap_)
        if self.directionref is not None:
            directionref_ = self.directionref
            directionref_.to_etree(element, name_='directionref', mapping_=mapping_, nsmap_=nsmap_)
        if self.width is not None:
            width_ = self.width
            width_.to_etree(element, name_='width', mapping_=mapping_, nsmap_=nsmap_)
        if self.offset is not None:
            offset_ = self.offset
            offset_.to_etree(element, name_='offset', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='AxisReplicationAlgorithmType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AxisReplicationAlgorithmType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AxisReplicationAlgorithmType, self).exportLiteralChildren(outfile, level, name_)
        if self.position is not None:
            showIndent(outfile, level)
            outfile.write('position=model_.positionType(\n')
            self.position.exportLiteral(outfile, level, name_='position')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.positionref is not None:
            showIndent(outfile, level)
            outfile.write('positionref=model_.ReferenceType(\n')
            self.positionref.exportLiteral(outfile, level, name_='positionref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rotation is not None:
            showIndent(outfile, level)
            outfile.write('rotation=model_.rotationType(\n')
            self.rotation.exportLiteral(outfile, level, name_='rotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rotationref is not None:
            showIndent(outfile, level)
            outfile.write('rotationref=model_.ReferenceType(\n')
            self.rotationref.exportLiteral(outfile, level, name_='rotationref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.direction is not None:
            showIndent(outfile, level)
            outfile.write('direction=model_.direction(\n')
            self.direction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.directionref is not None:
            showIndent(outfile, level)
            outfile.write('directionref=model_.ReferenceType(\n')
            self.directionref.exportLiteral(outfile, level, name_='directionref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.width is not None:
            showIndent(outfile, level)
            outfile.write('width=model_.width(\n')
            self.width.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.offset is not None:
            showIndent(outfile, level)
            outfile.write('offset=model_.offset(\n')
            self.offset.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AxisReplicationAlgorithmType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'position':
            obj_ = positionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.position = obj_
            obj_.original_tagname_ = 'position'
        elif nodeName_ == 'positionref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.positionref = obj_
            obj_.original_tagname_ = 'positionref'
        elif nodeName_ == 'rotation':
            obj_ = rotationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rotation = obj_
            obj_.original_tagname_ = 'rotation'
        elif nodeName_ == 'rotationref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rotationref = obj_
            obj_.original_tagname_ = 'rotationref'
        elif nodeName_ == 'direction':
            obj_ = directionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.direction = obj_
            obj_.original_tagname_ = 'direction'
        elif nodeName_ == 'directionref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.directionref = obj_
            obj_.original_tagname_ = 'directionref'
        elif nodeName_ == 'width':
            class_obj_ = self.get_class_obj_(child_, QuantityType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'offset':
            class_obj_ = self.get_class_obj_(child_, QuantityType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.offset = obj_
            obj_.original_tagname_ = 'offset'
        super(AxisReplicationAlgorithmType, self).buildChildren(child_, node, nodeName_, True)
# end class AxisReplicationAlgorithmType


class ReplicaPlacementType(GeneratedsSuper):
    """Base type for replicated volumes"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, copy_num_start=1, copy_num_step=1, volumeref=None, ReplicationAlgorithm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.copy_num_start = _cast(int, copy_num_start)
        self.copy_num_start_nsprefix_ = None
        self.copy_num_step = _cast(int, copy_num_step)
        self.copy_num_step_nsprefix_ = None
        self.volumeref = volumeref
        self.volumeref_nsprefix_ = None
        self.ReplicationAlgorithm = ReplicationAlgorithm
        self.ReplicationAlgorithm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReplicaPlacementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReplicaPlacementType.subclass:
            return ReplicaPlacementType.subclass(*args_, **kwargs_)
        else:
            return ReplicaPlacementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_volumeref(self):
        return self.volumeref
    def set_volumeref(self, volumeref):
        self.volumeref = volumeref
    volumerefProp = property(get_volumeref, set_volumeref)
    def get_ReplicationAlgorithm(self):
        return self.ReplicationAlgorithm
    def set_ReplicationAlgorithm(self, ReplicationAlgorithm):
        self.ReplicationAlgorithm = ReplicationAlgorithm
    ReplicationAlgorithmProp = property(get_ReplicationAlgorithm, set_ReplicationAlgorithm)
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    numberProp = property(get_number, set_number)
    def get_copy_num_start(self):
        return self.copy_num_start
    def set_copy_num_start(self, copy_num_start):
        self.copy_num_start = copy_num_start
    copy_num_startProp = property(get_copy_num_start, set_copy_num_start)
    def get_copy_num_step(self):
        return self.copy_num_step
    def set_copy_num_step(self, copy_num_step):
        self.copy_num_step = copy_num_step
    copy_num_stepProp = property(get_copy_num_step, set_copy_num_step)
    def hasContent_(self):
        if (
            self.volumeref is not None or
            self.ReplicationAlgorithm is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReplicaPlacementType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReplicaPlacementType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReplicaPlacementType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReplicaPlacementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReplicaPlacementType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReplicaPlacementType'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
        if self.copy_num_start != 1 and 'copy_num_start' not in already_processed:
            already_processed.add('copy_num_start')
            outfile.write(' copy_num_start="%s"' % self.gds_format_integer(self.copy_num_start, input_name='copy_num_start'))
        if self.copy_num_step != 1 and 'copy_num_step' not in already_processed:
            already_processed.add('copy_num_step')
            outfile.write(' copy_num_step="%s"' % self.gds_format_integer(self.copy_num_step, input_name='copy_num_step'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReplicaPlacementType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.volumeref is not None:
            namespaceprefix_ = self.volumeref_nsprefix_ + ':' if (UseCapturedNS_ and self.volumeref_nsprefix_) else ''
            self.volumeref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='volumeref', pretty_print=pretty_print)
        if self.ReplicationAlgorithm is not None:
            self.ReplicationAlgorithm.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ReplicaPlacementType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.number is not None:
            element.set('number', self.gds_format_integer(self.number))
        if self.copy_num_start is not None:
            element.set('copy_num_start', self.gds_format_integer(self.copy_num_start))
        if self.copy_num_step is not None:
            element.set('copy_num_step', self.gds_format_integer(self.copy_num_step))
        if self.volumeref is not None:
            volumeref_ = self.volumeref
            volumeref_.to_etree(element, name_='volumeref', mapping_=mapping_, nsmap_=nsmap_)
        if self.ReplicationAlgorithm is not None:
            ReplicationAlgorithm_ = self.ReplicationAlgorithm
            ReplicationAlgorithm_.to_etree(element, name_='ReplicationAlgorithm', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ReplicaPlacementType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            showIndent(outfile, level)
            outfile.write('number=%d,\n' % (self.number,))
        if self.copy_num_start is not None and 'copy_num_start' not in already_processed:
            already_processed.add('copy_num_start')
            showIndent(outfile, level)
            outfile.write('copy_num_start=%d,\n' % (self.copy_num_start,))
        if self.copy_num_step is not None and 'copy_num_step' not in already_processed:
            already_processed.add('copy_num_step')
            showIndent(outfile, level)
            outfile.write('copy_num_step=%d,\n' % (self.copy_num_step,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.volumeref is not None:
            showIndent(outfile, level)
            outfile.write('volumeref=model_.ReferenceType(\n')
            self.volumeref.exportLiteral(outfile, level, name_='volumeref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReplicationAlgorithm is not None:
            showIndent(outfile, level)
            outfile.write('ReplicationAlgorithm=model_.ReplicationAlgorithm(\n')
            self.ReplicationAlgorithm.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('copy_num_start', node)
        if value is not None and 'copy_num_start' not in already_processed:
            already_processed.add('copy_num_start')
            self.copy_num_start = self.gds_parse_integer(value, node, 'copy_num_start')
            if self.copy_num_start <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('copy_num_step', node)
        if value is not None and 'copy_num_step' not in already_processed:
            already_processed.add('copy_num_step')
            self.copy_num_step = self.gds_parse_integer(value, node, 'copy_num_step')
            if self.copy_num_step <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'volumeref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.volumeref = obj_
            obj_.original_tagname_ = 'volumeref'
        elif nodeName_ == 'ReplicationAlgorithm':
            class_obj_ = self.get_class_obj_(child_, ReplicationAlgorithmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReplicationAlgorithm = obj_
            obj_.original_tagname_ = 'ReplicationAlgorithm'
        elif nodeName_ == 'replicate_along_axis':
            obj_ = AxisReplicationAlgorithmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReplicationAlgorithm = obj_
            obj_.original_tagname_ = 'replicate_along_axis'
# end class ReplicaPlacementType


class directionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, x='0.0', y='0.0', z='0.0', phi='0.0', rho='0.0', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.x = _cast(None, x)
        self.x_nsprefix_ = None
        self.y = _cast(None, y)
        self.y_nsprefix_ = None
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.phi = _cast(None, phi)
        self.phi_nsprefix_ = None
        self.rho = _cast(None, rho)
        self.rho_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, directionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if directionType.subclass:
            return directionType.subclass(*args_, **kwargs_)
        else:
            return directionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    xProp = property(get_x, set_x)
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    yProp = property(get_y, set_y)
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_phi(self):
        return self.phi
    def set_phi(self, phi):
        self.phi = phi
    phiProp = property(get_phi, set_phi)
    def get_rho(self):
        return self.rho
    def set_rho(self, rho):
        self.rho = rho
    rhoProp = property(get_rho, set_rho)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='directionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('directionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'directionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='directionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='directionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='directionType'):
        if self.x != "0.0" and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x=%s' % (quote_attrib(self.x), ))
        if self.y != "0.0" and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y=%s' % (quote_attrib(self.y), ))
        if self.z != "0.0" and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.phi != "0.0" and 'phi' not in already_processed:
            already_processed.add('phi')
            outfile.write(' phi=%s' % (quote_attrib(self.phi), ))
        if self.rho != "0.0" and 'rho' not in already_processed:
            already_processed.add('rho')
            outfile.write(' rho=%s' % (quote_attrib(self.rho), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='directionType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='directionType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.x is not None:
            element.set('x', self.x)
        if self.y is not None:
            element.set('y', self.y)
        if self.z is not None:
            element.set('z', self.z)
        if self.phi is not None:
            element.set('phi', self.phi)
        if self.rho is not None:
            element.set('rho', self.rho)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='directionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%s,\n' % (self.x,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%s,\n' % (self.y,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        if self.phi is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            showIndent(outfile, level)
            outfile.write('phi=%s,\n' % (self.phi,))
        if self.rho is not None and 'rho' not in already_processed:
            already_processed.add('rho')
            showIndent(outfile, level)
            outfile.write('rho=%s,\n' % (self.rho,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            self.x = value
            self.validate_ExpressionOrIDREFType(self.x)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            self.y = value
            self.validate_ExpressionOrIDREFType(self.y)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('phi', node)
        if value is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            self.phi = value
            self.validate_ExpressionOrIDREFType(self.phi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rho', node)
        if value is not None and 'rho' not in already_processed:
            already_processed.add('rho')
            self.rho = value
            self.validate_ExpressionOrIDREFType(self.rho)    # validate type ExpressionOrIDREFType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class directionType


class DimensionsType(GeneratedsSuper):
    """Abstract base for parametrised dimensions"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionsType.subclass:
            return DimensionsType.subclass(*args_, **kwargs_)
        else:
            return DimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DimensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DimensionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DimensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DimensionsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DimensionsType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DimensionsType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='DimensionsType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='DimensionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DimensionsType


class BoxDimensionsType(DimensionsType):
    """Dimensions for parametrised Boxes."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DimensionsType
    def __init__(self, x='1.0', y='1.0', z='1.0', lunit='mm', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(BoxDimensionsType, self).__init__( **kwargs_)
        self.x = _cast(None, x)
        self.x_nsprefix_ = None
        self.y = _cast(None, y)
        self.y_nsprefix_ = None
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.lunit = _cast(None, lunit)
        self.lunit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BoxDimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BoxDimensionsType.subclass:
            return BoxDimensionsType.subclass(*args_, **kwargs_)
        else:
            return BoxDimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    xProp = property(get_x, set_x)
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    yProp = property(get_y, set_y)
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_lunit(self):
        return self.lunit
    def set_lunit(self, lunit):
        self.lunit = lunit
    lunitProp = property(get_lunit, set_lunit)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(BoxDimensionsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BoxDimensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BoxDimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BoxDimensionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BoxDimensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BoxDimensionsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BoxDimensionsType'):
        super(BoxDimensionsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BoxDimensionsType')
        if self.x != "1.0" and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x=%s' % (quote_attrib(self.x), ))
        if self.y != "1.0" and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y=%s' % (quote_attrib(self.y), ))
        if self.z != "1.0" and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.lunit != "mm" and 'lunit' not in already_processed:
            already_processed.add('lunit')
            outfile.write(' lunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lunit), input_name='lunit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BoxDimensionsType', fromsubclass_=False, pretty_print=True):
        super(BoxDimensionsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='BoxDimensionsType', mapping_=None, nsmap_=None):
        element = super(BoxDimensionsType, self).to_etree(parent_element, name_, mapping_)
        if self.x is not None:
            element.set('x', self.x)
        if self.y is not None:
            element.set('y', self.y)
        if self.z is not None:
            element.set('z', self.z)
        if self.lunit is not None:
            element.set('lunit', self.gds_format_string(self.lunit))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='BoxDimensionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%s,\n' % (self.x,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%s,\n' % (self.y,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        if self.lunit is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            showIndent(outfile, level)
            outfile.write('lunit="%s",\n' % (self.lunit,))
        super(BoxDimensionsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BoxDimensionsType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            self.x = value
            self.validate_ExpressionOrIDREFType(self.x)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            self.y = value
            self.validate_ExpressionOrIDREFType(self.y)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('lunit', node)
        if value is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            self.lunit = value
        super(BoxDimensionsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BoxDimensionsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BoxDimensionsType


class TrdDimensionsType(DimensionsType):
    """Dimensions for parametrised Trd."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DimensionsType
    def __init__(self, x1='1.0', x2='1.0', y1='1.0', y2='1.0', z='1.0', lunit='mm', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TrdDimensionsType, self).__init__( **kwargs_)
        self.x1 = _cast(None, x1)
        self.x1_nsprefix_ = None
        self.x2 = _cast(None, x2)
        self.x2_nsprefix_ = None
        self.y1 = _cast(None, y1)
        self.y1_nsprefix_ = None
        self.y2 = _cast(None, y2)
        self.y2_nsprefix_ = None
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.lunit = _cast(None, lunit)
        self.lunit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrdDimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrdDimensionsType.subclass:
            return TrdDimensionsType.subclass(*args_, **kwargs_)
        else:
            return TrdDimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_x1(self):
        return self.x1
    def set_x1(self, x1):
        self.x1 = x1
    x1Prop = property(get_x1, set_x1)
    def get_x2(self):
        return self.x2
    def set_x2(self, x2):
        self.x2 = x2
    x2Prop = property(get_x2, set_x2)
    def get_y1(self):
        return self.y1
    def set_y1(self, y1):
        self.y1 = y1
    y1Prop = property(get_y1, set_y1)
    def get_y2(self):
        return self.y2
    def set_y2(self, y2):
        self.y2 = y2
    y2Prop = property(get_y2, set_y2)
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_lunit(self):
        return self.lunit
    def set_lunit(self, lunit):
        self.lunit = lunit
    lunitProp = property(get_lunit, set_lunit)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(TrdDimensionsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TrdDimensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrdDimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TrdDimensionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TrdDimensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TrdDimensionsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TrdDimensionsType'):
        super(TrdDimensionsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TrdDimensionsType')
        if self.x1 != "1.0" and 'x1' not in already_processed:
            already_processed.add('x1')
            outfile.write(' x1=%s' % (quote_attrib(self.x1), ))
        if self.x2 != "1.0" and 'x2' not in already_processed:
            already_processed.add('x2')
            outfile.write(' x2=%s' % (quote_attrib(self.x2), ))
        if self.y1 != "1.0" and 'y1' not in already_processed:
            already_processed.add('y1')
            outfile.write(' y1=%s' % (quote_attrib(self.y1), ))
        if self.y2 != "1.0" and 'y2' not in already_processed:
            already_processed.add('y2')
            outfile.write(' y2=%s' % (quote_attrib(self.y2), ))
        if self.z != "1.0" and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.lunit != "mm" and 'lunit' not in already_processed:
            already_processed.add('lunit')
            outfile.write(' lunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lunit), input_name='lunit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TrdDimensionsType', fromsubclass_=False, pretty_print=True):
        super(TrdDimensionsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='TrdDimensionsType', mapping_=None, nsmap_=None):
        element = super(TrdDimensionsType, self).to_etree(parent_element, name_, mapping_)
        if self.x1 is not None:
            element.set('x1', self.x1)
        if self.x2 is not None:
            element.set('x2', self.x2)
        if self.y1 is not None:
            element.set('y1', self.y1)
        if self.y2 is not None:
            element.set('y2', self.y2)
        if self.z is not None:
            element.set('z', self.z)
        if self.lunit is not None:
            element.set('lunit', self.gds_format_string(self.lunit))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TrdDimensionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.add('x1')
            showIndent(outfile, level)
            outfile.write('x1=%s,\n' % (self.x1,))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.add('x2')
            showIndent(outfile, level)
            outfile.write('x2=%s,\n' % (self.x2,))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.add('y1')
            showIndent(outfile, level)
            outfile.write('y1=%s,\n' % (self.y1,))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.add('y2')
            showIndent(outfile, level)
            outfile.write('y2=%s,\n' % (self.y2,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        if self.lunit is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            showIndent(outfile, level)
            outfile.write('lunit="%s",\n' % (self.lunit,))
        super(TrdDimensionsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TrdDimensionsType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('x1', node)
        if value is not None and 'x1' not in already_processed:
            already_processed.add('x1')
            self.x1 = value
            self.validate_ExpressionOrIDREFType(self.x1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('x2', node)
        if value is not None and 'x2' not in already_processed:
            already_processed.add('x2')
            self.x2 = value
            self.validate_ExpressionOrIDREFType(self.x2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y1', node)
        if value is not None and 'y1' not in already_processed:
            already_processed.add('y1')
            self.y1 = value
            self.validate_ExpressionOrIDREFType(self.y1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y2', node)
        if value is not None and 'y2' not in already_processed:
            already_processed.add('y2')
            self.y2 = value
            self.validate_ExpressionOrIDREFType(self.y2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('lunit', node)
        if value is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            self.lunit = value
        super(TrdDimensionsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TrdDimensionsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TrdDimensionsType


class TrapDimensionsType(DimensionsType):
    """Dimensions for parametrised Trap."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DimensionsType
    def __init__(self, z='1.0', theta='1.0', phi='1.0', y1='1.0', x1='1.0', x2='1.0', alpha1='1.0', y2='1.0', x3='1.0', x4='1.0', alpha2='1.0', lunit='mm', aunit='radian', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TrapDimensionsType, self).__init__( **kwargs_)
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.theta = _cast(None, theta)
        self.theta_nsprefix_ = None
        self.phi = _cast(None, phi)
        self.phi_nsprefix_ = None
        self.y1 = _cast(None, y1)
        self.y1_nsprefix_ = None
        self.x1 = _cast(None, x1)
        self.x1_nsprefix_ = None
        self.x2 = _cast(None, x2)
        self.x2_nsprefix_ = None
        self.alpha1 = _cast(None, alpha1)
        self.alpha1_nsprefix_ = None
        self.y2 = _cast(None, y2)
        self.y2_nsprefix_ = None
        self.x3 = _cast(None, x3)
        self.x3_nsprefix_ = None
        self.x4 = _cast(None, x4)
        self.x4_nsprefix_ = None
        self.alpha2 = _cast(None, alpha2)
        self.alpha2_nsprefix_ = None
        self.lunit = _cast(None, lunit)
        self.lunit_nsprefix_ = None
        self.aunit = _cast(None, aunit)
        self.aunit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrapDimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrapDimensionsType.subclass:
            return TrapDimensionsType.subclass(*args_, **kwargs_)
        else:
            return TrapDimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_theta(self):
        return self.theta
    def set_theta(self, theta):
        self.theta = theta
    thetaProp = property(get_theta, set_theta)
    def get_phi(self):
        return self.phi
    def set_phi(self, phi):
        self.phi = phi
    phiProp = property(get_phi, set_phi)
    def get_y1(self):
        return self.y1
    def set_y1(self, y1):
        self.y1 = y1
    y1Prop = property(get_y1, set_y1)
    def get_x1(self):
        return self.x1
    def set_x1(self, x1):
        self.x1 = x1
    x1Prop = property(get_x1, set_x1)
    def get_x2(self):
        return self.x2
    def set_x2(self, x2):
        self.x2 = x2
    x2Prop = property(get_x2, set_x2)
    def get_alpha1(self):
        return self.alpha1
    def set_alpha1(self, alpha1):
        self.alpha1 = alpha1
    alpha1Prop = property(get_alpha1, set_alpha1)
    def get_y2(self):
        return self.y2
    def set_y2(self, y2):
        self.y2 = y2
    y2Prop = property(get_y2, set_y2)
    def get_x3(self):
        return self.x3
    def set_x3(self, x3):
        self.x3 = x3
    x3Prop = property(get_x3, set_x3)
    def get_x4(self):
        return self.x4
    def set_x4(self, x4):
        self.x4 = x4
    x4Prop = property(get_x4, set_x4)
    def get_alpha2(self):
        return self.alpha2
    def set_alpha2(self, alpha2):
        self.alpha2 = alpha2
    alpha2Prop = property(get_alpha2, set_alpha2)
    def get_lunit(self):
        return self.lunit
    def set_lunit(self, lunit):
        self.lunit = lunit
    lunitProp = property(get_lunit, set_lunit)
    def get_aunit(self):
        return self.aunit
    def set_aunit(self, aunit):
        self.aunit = aunit
    aunitProp = property(get_aunit, set_aunit)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(TrapDimensionsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TrapDimensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrapDimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TrapDimensionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TrapDimensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TrapDimensionsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TrapDimensionsType'):
        super(TrapDimensionsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TrapDimensionsType')
        if self.z != "1.0" and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.theta != "1.0" and 'theta' not in already_processed:
            already_processed.add('theta')
            outfile.write(' theta=%s' % (quote_attrib(self.theta), ))
        if self.phi != "1.0" and 'phi' not in already_processed:
            already_processed.add('phi')
            outfile.write(' phi=%s' % (quote_attrib(self.phi), ))
        if self.y1 != "1.0" and 'y1' not in already_processed:
            already_processed.add('y1')
            outfile.write(' y1=%s' % (quote_attrib(self.y1), ))
        if self.x1 != "1.0" and 'x1' not in already_processed:
            already_processed.add('x1')
            outfile.write(' x1=%s' % (quote_attrib(self.x1), ))
        if self.x2 != "1.0" and 'x2' not in already_processed:
            already_processed.add('x2')
            outfile.write(' x2=%s' % (quote_attrib(self.x2), ))
        if self.alpha1 != "1.0" and 'alpha1' not in already_processed:
            already_processed.add('alpha1')
            outfile.write(' alpha1=%s' % (quote_attrib(self.alpha1), ))
        if self.y2 != "1.0" and 'y2' not in already_processed:
            already_processed.add('y2')
            outfile.write(' y2=%s' % (quote_attrib(self.y2), ))
        if self.x3 != "1.0" and 'x3' not in already_processed:
            already_processed.add('x3')
            outfile.write(' x3=%s' % (quote_attrib(self.x3), ))
        if self.x4 != "1.0" and 'x4' not in already_processed:
            already_processed.add('x4')
            outfile.write(' x4=%s' % (quote_attrib(self.x4), ))
        if self.alpha2 != "1.0" and 'alpha2' not in already_processed:
            already_processed.add('alpha2')
            outfile.write(' alpha2=%s' % (quote_attrib(self.alpha2), ))
        if self.lunit != "mm" and 'lunit' not in already_processed:
            already_processed.add('lunit')
            outfile.write(' lunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lunit), input_name='lunit')), ))
        if self.aunit != "radian" and 'aunit' not in already_processed:
            already_processed.add('aunit')
            outfile.write(' aunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aunit), input_name='aunit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TrapDimensionsType', fromsubclass_=False, pretty_print=True):
        super(TrapDimensionsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='TrapDimensionsType', mapping_=None, nsmap_=None):
        element = super(TrapDimensionsType, self).to_etree(parent_element, name_, mapping_)
        if self.z is not None:
            element.set('z', self.z)
        if self.theta is not None:
            element.set('theta', self.theta)
        if self.phi is not None:
            element.set('phi', self.phi)
        if self.y1 is not None:
            element.set('y1', self.y1)
        if self.x1 is not None:
            element.set('x1', self.x1)
        if self.x2 is not None:
            element.set('x2', self.x2)
        if self.alpha1 is not None:
            element.set('alpha1', self.alpha1)
        if self.y2 is not None:
            element.set('y2', self.y2)
        if self.x3 is not None:
            element.set('x3', self.x3)
        if self.x4 is not None:
            element.set('x4', self.x4)
        if self.alpha2 is not None:
            element.set('alpha2', self.alpha2)
        if self.lunit is not None:
            element.set('lunit', self.gds_format_string(self.lunit))
        if self.aunit is not None:
            element.set('aunit', self.gds_format_string(self.aunit))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TrapDimensionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        if self.theta is not None and 'theta' not in already_processed:
            already_processed.add('theta')
            showIndent(outfile, level)
            outfile.write('theta=%s,\n' % (self.theta,))
        if self.phi is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            showIndent(outfile, level)
            outfile.write('phi=%s,\n' % (self.phi,))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.add('y1')
            showIndent(outfile, level)
            outfile.write('y1=%s,\n' % (self.y1,))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.add('x1')
            showIndent(outfile, level)
            outfile.write('x1=%s,\n' % (self.x1,))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.add('x2')
            showIndent(outfile, level)
            outfile.write('x2=%s,\n' % (self.x2,))
        if self.alpha1 is not None and 'alpha1' not in already_processed:
            already_processed.add('alpha1')
            showIndent(outfile, level)
            outfile.write('alpha1=%s,\n' % (self.alpha1,))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.add('y2')
            showIndent(outfile, level)
            outfile.write('y2=%s,\n' % (self.y2,))
        if self.x3 is not None and 'x3' not in already_processed:
            already_processed.add('x3')
            showIndent(outfile, level)
            outfile.write('x3=%s,\n' % (self.x3,))
        if self.x4 is not None and 'x4' not in already_processed:
            already_processed.add('x4')
            showIndent(outfile, level)
            outfile.write('x4=%s,\n' % (self.x4,))
        if self.alpha2 is not None and 'alpha2' not in already_processed:
            already_processed.add('alpha2')
            showIndent(outfile, level)
            outfile.write('alpha2=%s,\n' % (self.alpha2,))
        if self.lunit is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            showIndent(outfile, level)
            outfile.write('lunit="%s",\n' % (self.lunit,))
        if self.aunit is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            showIndent(outfile, level)
            outfile.write('aunit="%s",\n' % (self.aunit,))
        super(TrapDimensionsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TrapDimensionsType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('theta', node)
        if value is not None and 'theta' not in already_processed:
            already_processed.add('theta')
            self.theta = value
            self.validate_ExpressionOrIDREFType(self.theta)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('phi', node)
        if value is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            self.phi = value
            self.validate_ExpressionOrIDREFType(self.phi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y1', node)
        if value is not None and 'y1' not in already_processed:
            already_processed.add('y1')
            self.y1 = value
            self.validate_ExpressionOrIDREFType(self.y1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('x1', node)
        if value is not None and 'x1' not in already_processed:
            already_processed.add('x1')
            self.x1 = value
            self.validate_ExpressionOrIDREFType(self.x1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('x2', node)
        if value is not None and 'x2' not in already_processed:
            already_processed.add('x2')
            self.x2 = value
            self.validate_ExpressionOrIDREFType(self.x2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('alpha1', node)
        if value is not None and 'alpha1' not in already_processed:
            already_processed.add('alpha1')
            self.alpha1 = value
            self.validate_ExpressionOrIDREFType(self.alpha1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y2', node)
        if value is not None and 'y2' not in already_processed:
            already_processed.add('y2')
            self.y2 = value
            self.validate_ExpressionOrIDREFType(self.y2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('x3', node)
        if value is not None and 'x3' not in already_processed:
            already_processed.add('x3')
            self.x3 = value
            self.validate_ExpressionOrIDREFType(self.x3)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('x4', node)
        if value is not None and 'x4' not in already_processed:
            already_processed.add('x4')
            self.x4 = value
            self.validate_ExpressionOrIDREFType(self.x4)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('alpha2', node)
        if value is not None and 'alpha2' not in already_processed:
            already_processed.add('alpha2')
            self.alpha2 = value
            self.validate_ExpressionOrIDREFType(self.alpha2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('lunit', node)
        if value is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            self.lunit = value
        value = find_attr_value_('aunit', node)
        if value is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            self.aunit = value
        super(TrapDimensionsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TrapDimensionsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TrapDimensionsType


class TubeDimensionsType(DimensionsType):
    """Dimensions for parametrised Tubes."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DimensionsType
    def __init__(self, DeltaPhi='1.0', InR='1.0', OutR='1.0', StartPhi='0.0', hz='1.0', lunit='mm', aunit='radian', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TubeDimensionsType, self).__init__( **kwargs_)
        self.DeltaPhi = _cast(None, DeltaPhi)
        self.DeltaPhi_nsprefix_ = None
        self.InR = _cast(None, InR)
        self.InR_nsprefix_ = None
        self.OutR = _cast(None, OutR)
        self.OutR_nsprefix_ = None
        self.StartPhi = _cast(None, StartPhi)
        self.StartPhi_nsprefix_ = None
        self.hz = _cast(None, hz)
        self.hz_nsprefix_ = None
        self.lunit = _cast(None, lunit)
        self.lunit_nsprefix_ = None
        self.aunit = _cast(None, aunit)
        self.aunit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TubeDimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TubeDimensionsType.subclass:
            return TubeDimensionsType.subclass(*args_, **kwargs_)
        else:
            return TubeDimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DeltaPhi(self):
        return self.DeltaPhi
    def set_DeltaPhi(self, DeltaPhi):
        self.DeltaPhi = DeltaPhi
    DeltaPhiProp = property(get_DeltaPhi, set_DeltaPhi)
    def get_InR(self):
        return self.InR
    def set_InR(self, InR):
        self.InR = InR
    InRProp = property(get_InR, set_InR)
    def get_OutR(self):
        return self.OutR
    def set_OutR(self, OutR):
        self.OutR = OutR
    OutRProp = property(get_OutR, set_OutR)
    def get_StartPhi(self):
        return self.StartPhi
    def set_StartPhi(self, StartPhi):
        self.StartPhi = StartPhi
    StartPhiProp = property(get_StartPhi, set_StartPhi)
    def get_hz(self):
        return self.hz
    def set_hz(self, hz):
        self.hz = hz
    hzProp = property(get_hz, set_hz)
    def get_lunit(self):
        return self.lunit
    def set_lunit(self, lunit):
        self.lunit = lunit
    lunitProp = property(get_lunit, set_lunit)
    def get_aunit(self):
        return self.aunit
    def set_aunit(self, aunit):
        self.aunit = aunit
    aunitProp = property(get_aunit, set_aunit)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(TubeDimensionsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TubeDimensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TubeDimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TubeDimensionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TubeDimensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TubeDimensionsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TubeDimensionsType'):
        super(TubeDimensionsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TubeDimensionsType')
        if self.DeltaPhi != "1.0" and 'DeltaPhi' not in already_processed:
            already_processed.add('DeltaPhi')
            outfile.write(' DeltaPhi=%s' % (quote_attrib(self.DeltaPhi), ))
        if self.InR != "1.0" and 'InR' not in already_processed:
            already_processed.add('InR')
            outfile.write(' InR=%s' % (quote_attrib(self.InR), ))
        if self.OutR != "1.0" and 'OutR' not in already_processed:
            already_processed.add('OutR')
            outfile.write(' OutR=%s' % (quote_attrib(self.OutR), ))
        if self.StartPhi != "0.0" and 'StartPhi' not in already_processed:
            already_processed.add('StartPhi')
            outfile.write(' StartPhi=%s' % (quote_attrib(self.StartPhi), ))
        if self.hz != "1.0" and 'hz' not in already_processed:
            already_processed.add('hz')
            outfile.write(' hz=%s' % (quote_attrib(self.hz), ))
        if self.lunit != "mm" and 'lunit' not in already_processed:
            already_processed.add('lunit')
            outfile.write(' lunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lunit), input_name='lunit')), ))
        if self.aunit != "radian" and 'aunit' not in already_processed:
            already_processed.add('aunit')
            outfile.write(' aunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aunit), input_name='aunit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TubeDimensionsType', fromsubclass_=False, pretty_print=True):
        super(TubeDimensionsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='TubeDimensionsType', mapping_=None, nsmap_=None):
        element = super(TubeDimensionsType, self).to_etree(parent_element, name_, mapping_)
        if self.DeltaPhi is not None:
            element.set('DeltaPhi', self.DeltaPhi)
        if self.InR is not None:
            element.set('InR', self.InR)
        if self.OutR is not None:
            element.set('OutR', self.OutR)
        if self.StartPhi is not None:
            element.set('StartPhi', self.StartPhi)
        if self.hz is not None:
            element.set('hz', self.hz)
        if self.lunit is not None:
            element.set('lunit', self.gds_format_string(self.lunit))
        if self.aunit is not None:
            element.set('aunit', self.gds_format_string(self.aunit))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TubeDimensionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DeltaPhi is not None and 'DeltaPhi' not in already_processed:
            already_processed.add('DeltaPhi')
            showIndent(outfile, level)
            outfile.write('DeltaPhi=%s,\n' % (self.DeltaPhi,))
        if self.InR is not None and 'InR' not in already_processed:
            already_processed.add('InR')
            showIndent(outfile, level)
            outfile.write('InR=%s,\n' % (self.InR,))
        if self.OutR is not None and 'OutR' not in already_processed:
            already_processed.add('OutR')
            showIndent(outfile, level)
            outfile.write('OutR=%s,\n' % (self.OutR,))
        if self.StartPhi is not None and 'StartPhi' not in already_processed:
            already_processed.add('StartPhi')
            showIndent(outfile, level)
            outfile.write('StartPhi=%s,\n' % (self.StartPhi,))
        if self.hz is not None and 'hz' not in already_processed:
            already_processed.add('hz')
            showIndent(outfile, level)
            outfile.write('hz=%s,\n' % (self.hz,))
        if self.lunit is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            showIndent(outfile, level)
            outfile.write('lunit="%s",\n' % (self.lunit,))
        if self.aunit is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            showIndent(outfile, level)
            outfile.write('aunit="%s",\n' % (self.aunit,))
        super(TubeDimensionsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TubeDimensionsType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaPhi', node)
        if value is not None and 'DeltaPhi' not in already_processed:
            already_processed.add('DeltaPhi')
            self.DeltaPhi = value
            self.validate_ExpressionOrIDREFType(self.DeltaPhi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('InR', node)
        if value is not None and 'InR' not in already_processed:
            already_processed.add('InR')
            self.InR = value
            self.validate_ExpressionOrIDREFType(self.InR)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('OutR', node)
        if value is not None and 'OutR' not in already_processed:
            already_processed.add('OutR')
            self.OutR = value
            self.validate_ExpressionOrIDREFType(self.OutR)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('StartPhi', node)
        if value is not None and 'StartPhi' not in already_processed:
            already_processed.add('StartPhi')
            self.StartPhi = value
            self.validate_ExpressionOrIDREFType(self.StartPhi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('hz', node)
        if value is not None and 'hz' not in already_processed:
            already_processed.add('hz')
            self.hz = value
            self.validate_ExpressionOrIDREFType(self.hz)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('lunit', node)
        if value is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            self.lunit = value
        value = find_attr_value_('aunit', node)
        if value is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            self.aunit = value
        super(TubeDimensionsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TubeDimensionsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TubeDimensionsType


class ConeDimensionsType(DimensionsType):
    """Dimensions for parametrised Cones."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DimensionsType
    def __init__(self, rmin1='1.0', rmax1='1.0', rmin2='1.0', rmax2='1.0', z='1.0', startphi='0.0', deltaphi='1.0', lunit='mm', aunit='radian', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ConeDimensionsType, self).__init__( **kwargs_)
        self.rmin1 = _cast(None, rmin1)
        self.rmin1_nsprefix_ = None
        self.rmax1 = _cast(None, rmax1)
        self.rmax1_nsprefix_ = None
        self.rmin2 = _cast(None, rmin2)
        self.rmin2_nsprefix_ = None
        self.rmax2 = _cast(None, rmax2)
        self.rmax2_nsprefix_ = None
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.startphi = _cast(None, startphi)
        self.startphi_nsprefix_ = None
        self.deltaphi = _cast(None, deltaphi)
        self.deltaphi_nsprefix_ = None
        self.lunit = _cast(None, lunit)
        self.lunit_nsprefix_ = None
        self.aunit = _cast(None, aunit)
        self.aunit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConeDimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConeDimensionsType.subclass:
            return ConeDimensionsType.subclass(*args_, **kwargs_)
        else:
            return ConeDimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_rmin1(self):
        return self.rmin1
    def set_rmin1(self, rmin1):
        self.rmin1 = rmin1
    rmin1Prop = property(get_rmin1, set_rmin1)
    def get_rmax1(self):
        return self.rmax1
    def set_rmax1(self, rmax1):
        self.rmax1 = rmax1
    rmax1Prop = property(get_rmax1, set_rmax1)
    def get_rmin2(self):
        return self.rmin2
    def set_rmin2(self, rmin2):
        self.rmin2 = rmin2
    rmin2Prop = property(get_rmin2, set_rmin2)
    def get_rmax2(self):
        return self.rmax2
    def set_rmax2(self, rmax2):
        self.rmax2 = rmax2
    rmax2Prop = property(get_rmax2, set_rmax2)
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_startphi(self):
        return self.startphi
    def set_startphi(self, startphi):
        self.startphi = startphi
    startphiProp = property(get_startphi, set_startphi)
    def get_deltaphi(self):
        return self.deltaphi
    def set_deltaphi(self, deltaphi):
        self.deltaphi = deltaphi
    deltaphiProp = property(get_deltaphi, set_deltaphi)
    def get_lunit(self):
        return self.lunit
    def set_lunit(self, lunit):
        self.lunit = lunit
    lunitProp = property(get_lunit, set_lunit)
    def get_aunit(self):
        return self.aunit
    def set_aunit(self, aunit):
        self.aunit = aunit
    aunitProp = property(get_aunit, set_aunit)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(ConeDimensionsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConeDimensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConeDimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConeDimensionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConeDimensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConeDimensionsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConeDimensionsType'):
        super(ConeDimensionsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConeDimensionsType')
        if self.rmin1 != "1.0" and 'rmin1' not in already_processed:
            already_processed.add('rmin1')
            outfile.write(' rmin1=%s' % (quote_attrib(self.rmin1), ))
        if self.rmax1 != "1.0" and 'rmax1' not in already_processed:
            already_processed.add('rmax1')
            outfile.write(' rmax1=%s' % (quote_attrib(self.rmax1), ))
        if self.rmin2 != "1.0" and 'rmin2' not in already_processed:
            already_processed.add('rmin2')
            outfile.write(' rmin2=%s' % (quote_attrib(self.rmin2), ))
        if self.rmax2 != "1.0" and 'rmax2' not in already_processed:
            already_processed.add('rmax2')
            outfile.write(' rmax2=%s' % (quote_attrib(self.rmax2), ))
        if self.z != "1.0" and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.startphi != "0.0" and 'startphi' not in already_processed:
            already_processed.add('startphi')
            outfile.write(' startphi=%s' % (quote_attrib(self.startphi), ))
        if self.deltaphi != "1.0" and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            outfile.write(' deltaphi=%s' % (quote_attrib(self.deltaphi), ))
        if self.lunit != "mm" and 'lunit' not in already_processed:
            already_processed.add('lunit')
            outfile.write(' lunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lunit), input_name='lunit')), ))
        if self.aunit != "radian" and 'aunit' not in already_processed:
            already_processed.add('aunit')
            outfile.write(' aunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aunit), input_name='aunit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConeDimensionsType', fromsubclass_=False, pretty_print=True):
        super(ConeDimensionsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='ConeDimensionsType', mapping_=None, nsmap_=None):
        element = super(ConeDimensionsType, self).to_etree(parent_element, name_, mapping_)
        if self.rmin1 is not None:
            element.set('rmin1', self.rmin1)
        if self.rmax1 is not None:
            element.set('rmax1', self.rmax1)
        if self.rmin2 is not None:
            element.set('rmin2', self.rmin2)
        if self.rmax2 is not None:
            element.set('rmax2', self.rmax2)
        if self.z is not None:
            element.set('z', self.z)
        if self.startphi is not None:
            element.set('startphi', self.startphi)
        if self.deltaphi is not None:
            element.set('deltaphi', self.deltaphi)
        if self.lunit is not None:
            element.set('lunit', self.gds_format_string(self.lunit))
        if self.aunit is not None:
            element.set('aunit', self.gds_format_string(self.aunit))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ConeDimensionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rmin1 is not None and 'rmin1' not in already_processed:
            already_processed.add('rmin1')
            showIndent(outfile, level)
            outfile.write('rmin1=%s,\n' % (self.rmin1,))
        if self.rmax1 is not None and 'rmax1' not in already_processed:
            already_processed.add('rmax1')
            showIndent(outfile, level)
            outfile.write('rmax1=%s,\n' % (self.rmax1,))
        if self.rmin2 is not None and 'rmin2' not in already_processed:
            already_processed.add('rmin2')
            showIndent(outfile, level)
            outfile.write('rmin2=%s,\n' % (self.rmin2,))
        if self.rmax2 is not None and 'rmax2' not in already_processed:
            already_processed.add('rmax2')
            showIndent(outfile, level)
            outfile.write('rmax2=%s,\n' % (self.rmax2,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        if self.startphi is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            showIndent(outfile, level)
            outfile.write('startphi=%s,\n' % (self.startphi,))
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            showIndent(outfile, level)
            outfile.write('deltaphi=%s,\n' % (self.deltaphi,))
        if self.lunit is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            showIndent(outfile, level)
            outfile.write('lunit="%s",\n' % (self.lunit,))
        if self.aunit is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            showIndent(outfile, level)
            outfile.write('aunit="%s",\n' % (self.aunit,))
        super(ConeDimensionsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ConeDimensionsType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rmin1', node)
        if value is not None and 'rmin1' not in already_processed:
            already_processed.add('rmin1')
            self.rmin1 = value
            self.validate_ExpressionOrIDREFType(self.rmin1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmax1', node)
        if value is not None and 'rmax1' not in already_processed:
            already_processed.add('rmax1')
            self.rmax1 = value
            self.validate_ExpressionOrIDREFType(self.rmax1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmin2', node)
        if value is not None and 'rmin2' not in already_processed:
            already_processed.add('rmin2')
            self.rmin2 = value
            self.validate_ExpressionOrIDREFType(self.rmin2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmax2', node)
        if value is not None and 'rmax2' not in already_processed:
            already_processed.add('rmax2')
            self.rmax2 = value
            self.validate_ExpressionOrIDREFType(self.rmax2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('startphi', node)
        if value is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            self.startphi = value
            self.validate_ExpressionOrIDREFType(self.startphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('deltaphi', node)
        if value is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            self.deltaphi = value
            self.validate_ExpressionOrIDREFType(self.deltaphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('lunit', node)
        if value is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            self.lunit = value
        value = find_attr_value_('aunit', node)
        if value is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            self.aunit = value
        super(ConeDimensionsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ConeDimensionsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ConeDimensionsType


class SphereDimensionsType(DimensionsType):
    """Dimensions for parametrised Spheres."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DimensionsType
    def __init__(self, rmin='1.0', rmax='1.0', starttheta='0.0', deltatheta='1.0', startphi='0.0', deltaphi='1.0', lunit='mm', aunit='radian', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(SphereDimensionsType, self).__init__( **kwargs_)
        self.rmin = _cast(None, rmin)
        self.rmin_nsprefix_ = None
        self.rmax = _cast(None, rmax)
        self.rmax_nsprefix_ = None
        self.starttheta = _cast(None, starttheta)
        self.starttheta_nsprefix_ = None
        self.deltatheta = _cast(None, deltatheta)
        self.deltatheta_nsprefix_ = None
        self.startphi = _cast(None, startphi)
        self.startphi_nsprefix_ = None
        self.deltaphi = _cast(None, deltaphi)
        self.deltaphi_nsprefix_ = None
        self.lunit = _cast(None, lunit)
        self.lunit_nsprefix_ = None
        self.aunit = _cast(None, aunit)
        self.aunit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SphereDimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SphereDimensionsType.subclass:
            return SphereDimensionsType.subclass(*args_, **kwargs_)
        else:
            return SphereDimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_rmin(self):
        return self.rmin
    def set_rmin(self, rmin):
        self.rmin = rmin
    rminProp = property(get_rmin, set_rmin)
    def get_rmax(self):
        return self.rmax
    def set_rmax(self, rmax):
        self.rmax = rmax
    rmaxProp = property(get_rmax, set_rmax)
    def get_starttheta(self):
        return self.starttheta
    def set_starttheta(self, starttheta):
        self.starttheta = starttheta
    startthetaProp = property(get_starttheta, set_starttheta)
    def get_deltatheta(self):
        return self.deltatheta
    def set_deltatheta(self, deltatheta):
        self.deltatheta = deltatheta
    deltathetaProp = property(get_deltatheta, set_deltatheta)
    def get_startphi(self):
        return self.startphi
    def set_startphi(self, startphi):
        self.startphi = startphi
    startphiProp = property(get_startphi, set_startphi)
    def get_deltaphi(self):
        return self.deltaphi
    def set_deltaphi(self, deltaphi):
        self.deltaphi = deltaphi
    deltaphiProp = property(get_deltaphi, set_deltaphi)
    def get_lunit(self):
        return self.lunit
    def set_lunit(self, lunit):
        self.lunit = lunit
    lunitProp = property(get_lunit, set_lunit)
    def get_aunit(self):
        return self.aunit
    def set_aunit(self, aunit):
        self.aunit = aunit
    aunitProp = property(get_aunit, set_aunit)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(SphereDimensionsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SphereDimensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SphereDimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SphereDimensionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SphereDimensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SphereDimensionsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SphereDimensionsType'):
        super(SphereDimensionsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SphereDimensionsType')
        if self.rmin != "1.0" and 'rmin' not in already_processed:
            already_processed.add('rmin')
            outfile.write(' rmin=%s' % (quote_attrib(self.rmin), ))
        if self.rmax != "1.0" and 'rmax' not in already_processed:
            already_processed.add('rmax')
            outfile.write(' rmax=%s' % (quote_attrib(self.rmax), ))
        if self.starttheta != "0.0" and 'starttheta' not in already_processed:
            already_processed.add('starttheta')
            outfile.write(' starttheta=%s' % (quote_attrib(self.starttheta), ))
        if self.deltatheta != "1.0" and 'deltatheta' not in already_processed:
            already_processed.add('deltatheta')
            outfile.write(' deltatheta=%s' % (quote_attrib(self.deltatheta), ))
        if self.startphi != "0.0" and 'startphi' not in already_processed:
            already_processed.add('startphi')
            outfile.write(' startphi=%s' % (quote_attrib(self.startphi), ))
        if self.deltaphi != "1.0" and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            outfile.write(' deltaphi=%s' % (quote_attrib(self.deltaphi), ))
        if self.lunit != "mm" and 'lunit' not in already_processed:
            already_processed.add('lunit')
            outfile.write(' lunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lunit), input_name='lunit')), ))
        if self.aunit != "radian" and 'aunit' not in already_processed:
            already_processed.add('aunit')
            outfile.write(' aunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aunit), input_name='aunit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SphereDimensionsType', fromsubclass_=False, pretty_print=True):
        super(SphereDimensionsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='SphereDimensionsType', mapping_=None, nsmap_=None):
        element = super(SphereDimensionsType, self).to_etree(parent_element, name_, mapping_)
        if self.rmin is not None:
            element.set('rmin', self.rmin)
        if self.rmax is not None:
            element.set('rmax', self.rmax)
        if self.starttheta is not None:
            element.set('starttheta', self.starttheta)
        if self.deltatheta is not None:
            element.set('deltatheta', self.deltatheta)
        if self.startphi is not None:
            element.set('startphi', self.startphi)
        if self.deltaphi is not None:
            element.set('deltaphi', self.deltaphi)
        if self.lunit is not None:
            element.set('lunit', self.gds_format_string(self.lunit))
        if self.aunit is not None:
            element.set('aunit', self.gds_format_string(self.aunit))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='SphereDimensionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rmin is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            showIndent(outfile, level)
            outfile.write('rmin=%s,\n' % (self.rmin,))
        if self.rmax is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            showIndent(outfile, level)
            outfile.write('rmax=%s,\n' % (self.rmax,))
        if self.starttheta is not None and 'starttheta' not in already_processed:
            already_processed.add('starttheta')
            showIndent(outfile, level)
            outfile.write('starttheta=%s,\n' % (self.starttheta,))
        if self.deltatheta is not None and 'deltatheta' not in already_processed:
            already_processed.add('deltatheta')
            showIndent(outfile, level)
            outfile.write('deltatheta=%s,\n' % (self.deltatheta,))
        if self.startphi is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            showIndent(outfile, level)
            outfile.write('startphi=%s,\n' % (self.startphi,))
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            showIndent(outfile, level)
            outfile.write('deltaphi=%s,\n' % (self.deltaphi,))
        if self.lunit is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            showIndent(outfile, level)
            outfile.write('lunit="%s",\n' % (self.lunit,))
        if self.aunit is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            showIndent(outfile, level)
            outfile.write('aunit="%s",\n' % (self.aunit,))
        super(SphereDimensionsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SphereDimensionsType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rmin', node)
        if value is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            self.rmin = value
            self.validate_ExpressionOrIDREFType(self.rmin)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmax', node)
        if value is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            self.rmax = value
            self.validate_ExpressionOrIDREFType(self.rmax)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('starttheta', node)
        if value is not None and 'starttheta' not in already_processed:
            already_processed.add('starttheta')
            self.starttheta = value
            self.validate_ExpressionOrIDREFType(self.starttheta)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('deltatheta', node)
        if value is not None and 'deltatheta' not in already_processed:
            already_processed.add('deltatheta')
            self.deltatheta = value
            self.validate_ExpressionOrIDREFType(self.deltatheta)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('startphi', node)
        if value is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            self.startphi = value
            self.validate_ExpressionOrIDREFType(self.startphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('deltaphi', node)
        if value is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            self.deltaphi = value
            self.validate_ExpressionOrIDREFType(self.deltaphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('lunit', node)
        if value is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            self.lunit = value
        value = find_attr_value_('aunit', node)
        if value is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            self.aunit = value
        super(SphereDimensionsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SphereDimensionsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SphereDimensionsType


class OrbDimensionsType(DimensionsType):
    """Dimensions for parametrised Orbs."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DimensionsType
    def __init__(self, r='1.0', lunit='mm', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(OrbDimensionsType, self).__init__( **kwargs_)
        self.r = _cast(None, r)
        self.r_nsprefix_ = None
        self.lunit = _cast(None, lunit)
        self.lunit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrbDimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrbDimensionsType.subclass:
            return OrbDimensionsType.subclass(*args_, **kwargs_)
        else:
            return OrbDimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_r(self):
        return self.r
    def set_r(self, r):
        self.r = r
    rProp = property(get_r, set_r)
    def get_lunit(self):
        return self.lunit
    def set_lunit(self, lunit):
        self.lunit = lunit
    lunitProp = property(get_lunit, set_lunit)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(OrbDimensionsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OrbDimensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrbDimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OrbDimensionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrbDimensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OrbDimensionsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OrbDimensionsType'):
        super(OrbDimensionsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrbDimensionsType')
        if self.r != "1.0" and 'r' not in already_processed:
            already_processed.add('r')
            outfile.write(' r=%s' % (quote_attrib(self.r), ))
        if self.lunit != "mm" and 'lunit' not in already_processed:
            already_processed.add('lunit')
            outfile.write(' lunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lunit), input_name='lunit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OrbDimensionsType', fromsubclass_=False, pretty_print=True):
        super(OrbDimensionsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='OrbDimensionsType', mapping_=None, nsmap_=None):
        element = super(OrbDimensionsType, self).to_etree(parent_element, name_, mapping_)
        if self.r is not None:
            element.set('r', self.r)
        if self.lunit is not None:
            element.set('lunit', self.gds_format_string(self.lunit))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='OrbDimensionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.r is not None and 'r' not in already_processed:
            already_processed.add('r')
            showIndent(outfile, level)
            outfile.write('r=%s,\n' % (self.r,))
        if self.lunit is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            showIndent(outfile, level)
            outfile.write('lunit="%s",\n' % (self.lunit,))
        super(OrbDimensionsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrbDimensionsType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('r', node)
        if value is not None and 'r' not in already_processed:
            already_processed.add('r')
            self.r = value
            self.validate_ExpressionOrIDREFType(self.r)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('lunit', node)
        if value is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            self.lunit = value
        super(OrbDimensionsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(OrbDimensionsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class OrbDimensionsType


class TorusDimensionsType(DimensionsType):
    """Dimensions for parametrised Torus."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DimensionsType
    def __init__(self, rmin='1.0', rmax='1.0', rtor='1.0', startphi='0.0', deltaphi='1.0', lunit='mm', aunit='radian', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TorusDimensionsType, self).__init__( **kwargs_)
        self.rmin = _cast(None, rmin)
        self.rmin_nsprefix_ = None
        self.rmax = _cast(None, rmax)
        self.rmax_nsprefix_ = None
        self.rtor = _cast(None, rtor)
        self.rtor_nsprefix_ = None
        self.startphi = _cast(None, startphi)
        self.startphi_nsprefix_ = None
        self.deltaphi = _cast(None, deltaphi)
        self.deltaphi_nsprefix_ = None
        self.lunit = _cast(None, lunit)
        self.lunit_nsprefix_ = None
        self.aunit = _cast(None, aunit)
        self.aunit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TorusDimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TorusDimensionsType.subclass:
            return TorusDimensionsType.subclass(*args_, **kwargs_)
        else:
            return TorusDimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_rmin(self):
        return self.rmin
    def set_rmin(self, rmin):
        self.rmin = rmin
    rminProp = property(get_rmin, set_rmin)
    def get_rmax(self):
        return self.rmax
    def set_rmax(self, rmax):
        self.rmax = rmax
    rmaxProp = property(get_rmax, set_rmax)
    def get_rtor(self):
        return self.rtor
    def set_rtor(self, rtor):
        self.rtor = rtor
    rtorProp = property(get_rtor, set_rtor)
    def get_startphi(self):
        return self.startphi
    def set_startphi(self, startphi):
        self.startphi = startphi
    startphiProp = property(get_startphi, set_startphi)
    def get_deltaphi(self):
        return self.deltaphi
    def set_deltaphi(self, deltaphi):
        self.deltaphi = deltaphi
    deltaphiProp = property(get_deltaphi, set_deltaphi)
    def get_lunit(self):
        return self.lunit
    def set_lunit(self, lunit):
        self.lunit = lunit
    lunitProp = property(get_lunit, set_lunit)
    def get_aunit(self):
        return self.aunit
    def set_aunit(self, aunit):
        self.aunit = aunit
    aunitProp = property(get_aunit, set_aunit)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(TorusDimensionsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TorusDimensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TorusDimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TorusDimensionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TorusDimensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TorusDimensionsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TorusDimensionsType'):
        super(TorusDimensionsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TorusDimensionsType')
        if self.rmin != "1.0" and 'rmin' not in already_processed:
            already_processed.add('rmin')
            outfile.write(' rmin=%s' % (quote_attrib(self.rmin), ))
        if self.rmax != "1.0" and 'rmax' not in already_processed:
            already_processed.add('rmax')
            outfile.write(' rmax=%s' % (quote_attrib(self.rmax), ))
        if self.rtor != "1.0" and 'rtor' not in already_processed:
            already_processed.add('rtor')
            outfile.write(' rtor=%s' % (quote_attrib(self.rtor), ))
        if self.startphi != "0.0" and 'startphi' not in already_processed:
            already_processed.add('startphi')
            outfile.write(' startphi=%s' % (quote_attrib(self.startphi), ))
        if self.deltaphi != "1.0" and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            outfile.write(' deltaphi=%s' % (quote_attrib(self.deltaphi), ))
        if self.lunit != "mm" and 'lunit' not in already_processed:
            already_processed.add('lunit')
            outfile.write(' lunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lunit), input_name='lunit')), ))
        if self.aunit != "radian" and 'aunit' not in already_processed:
            already_processed.add('aunit')
            outfile.write(' aunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aunit), input_name='aunit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TorusDimensionsType', fromsubclass_=False, pretty_print=True):
        super(TorusDimensionsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='TorusDimensionsType', mapping_=None, nsmap_=None):
        element = super(TorusDimensionsType, self).to_etree(parent_element, name_, mapping_)
        if self.rmin is not None:
            element.set('rmin', self.rmin)
        if self.rmax is not None:
            element.set('rmax', self.rmax)
        if self.rtor is not None:
            element.set('rtor', self.rtor)
        if self.startphi is not None:
            element.set('startphi', self.startphi)
        if self.deltaphi is not None:
            element.set('deltaphi', self.deltaphi)
        if self.lunit is not None:
            element.set('lunit', self.gds_format_string(self.lunit))
        if self.aunit is not None:
            element.set('aunit', self.gds_format_string(self.aunit))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TorusDimensionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rmin is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            showIndent(outfile, level)
            outfile.write('rmin=%s,\n' % (self.rmin,))
        if self.rmax is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            showIndent(outfile, level)
            outfile.write('rmax=%s,\n' % (self.rmax,))
        if self.rtor is not None and 'rtor' not in already_processed:
            already_processed.add('rtor')
            showIndent(outfile, level)
            outfile.write('rtor=%s,\n' % (self.rtor,))
        if self.startphi is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            showIndent(outfile, level)
            outfile.write('startphi=%s,\n' % (self.startphi,))
        if self.deltaphi is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            showIndent(outfile, level)
            outfile.write('deltaphi=%s,\n' % (self.deltaphi,))
        if self.lunit is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            showIndent(outfile, level)
            outfile.write('lunit="%s",\n' % (self.lunit,))
        if self.aunit is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            showIndent(outfile, level)
            outfile.write('aunit="%s",\n' % (self.aunit,))
        super(TorusDimensionsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TorusDimensionsType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rmin', node)
        if value is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            self.rmin = value
            self.validate_ExpressionOrIDREFType(self.rmin)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmax', node)
        if value is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            self.rmax = value
            self.validate_ExpressionOrIDREFType(self.rmax)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rtor', node)
        if value is not None and 'rtor' not in already_processed:
            already_processed.add('rtor')
            self.rtor = value
            self.validate_ExpressionOrIDREFType(self.rtor)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('startphi', node)
        if value is not None and 'startphi' not in already_processed:
            already_processed.add('startphi')
            self.startphi = value
            self.validate_ExpressionOrIDREFType(self.startphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('deltaphi', node)
        if value is not None and 'deltaphi' not in already_processed:
            already_processed.add('deltaphi')
            self.deltaphi = value
            self.validate_ExpressionOrIDREFType(self.deltaphi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('lunit', node)
        if value is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            self.lunit = value
        value = find_attr_value_('aunit', node)
        if value is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            self.aunit = value
        super(TorusDimensionsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TorusDimensionsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TorusDimensionsType


class EllipsoidDimensionsType(DimensionsType):
    """Dimensions for parametrised Ellipsoid."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DimensionsType
    def __init__(self, ax='1.0', by='1.0', cz='1.0', zcut1='-1000000.0', zcut2='1000000.0', lunit='mm', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(EllipsoidDimensionsType, self).__init__( **kwargs_)
        self.ax = _cast(None, ax)
        self.ax_nsprefix_ = None
        self.by = _cast(None, by)
        self.by_nsprefix_ = None
        self.cz = _cast(None, cz)
        self.cz_nsprefix_ = None
        self.zcut1 = _cast(None, zcut1)
        self.zcut1_nsprefix_ = None
        self.zcut2 = _cast(None, zcut2)
        self.zcut2_nsprefix_ = None
        self.lunit = _cast(None, lunit)
        self.lunit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EllipsoidDimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EllipsoidDimensionsType.subclass:
            return EllipsoidDimensionsType.subclass(*args_, **kwargs_)
        else:
            return EllipsoidDimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ax(self):
        return self.ax
    def set_ax(self, ax):
        self.ax = ax
    axProp = property(get_ax, set_ax)
    def get_by(self):
        return self.by
    def set_by(self, by):
        self.by = by
    byProp = property(get_by, set_by)
    def get_cz(self):
        return self.cz
    def set_cz(self, cz):
        self.cz = cz
    czProp = property(get_cz, set_cz)
    def get_zcut1(self):
        return self.zcut1
    def set_zcut1(self, zcut1):
        self.zcut1 = zcut1
    zcut1Prop = property(get_zcut1, set_zcut1)
    def get_zcut2(self):
        return self.zcut2
    def set_zcut2(self, zcut2):
        self.zcut2 = zcut2
    zcut2Prop = property(get_zcut2, set_zcut2)
    def get_lunit(self):
        return self.lunit
    def set_lunit(self, lunit):
        self.lunit = lunit
    lunitProp = property(get_lunit, set_lunit)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(EllipsoidDimensionsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EllipsoidDimensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EllipsoidDimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EllipsoidDimensionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EllipsoidDimensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EllipsoidDimensionsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EllipsoidDimensionsType'):
        super(EllipsoidDimensionsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EllipsoidDimensionsType')
        if self.ax != "1.0" and 'ax' not in already_processed:
            already_processed.add('ax')
            outfile.write(' ax=%s' % (quote_attrib(self.ax), ))
        if self.by != "1.0" and 'by' not in already_processed:
            already_processed.add('by')
            outfile.write(' by=%s' % (quote_attrib(self.by), ))
        if self.cz != "1.0" and 'cz' not in already_processed:
            already_processed.add('cz')
            outfile.write(' cz=%s' % (quote_attrib(self.cz), ))
        if self.zcut1 != "-1000000.0" and 'zcut1' not in already_processed:
            already_processed.add('zcut1')
            outfile.write(' zcut1=%s' % (quote_attrib(self.zcut1), ))
        if self.zcut2 != "1000000.0" and 'zcut2' not in already_processed:
            already_processed.add('zcut2')
            outfile.write(' zcut2=%s' % (quote_attrib(self.zcut2), ))
        if self.lunit != "mm" and 'lunit' not in already_processed:
            already_processed.add('lunit')
            outfile.write(' lunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lunit), input_name='lunit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EllipsoidDimensionsType', fromsubclass_=False, pretty_print=True):
        super(EllipsoidDimensionsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='EllipsoidDimensionsType', mapping_=None, nsmap_=None):
        element = super(EllipsoidDimensionsType, self).to_etree(parent_element, name_, mapping_)
        if self.ax is not None:
            element.set('ax', self.ax)
        if self.by is not None:
            element.set('by', self.by)
        if self.cz is not None:
            element.set('cz', self.cz)
        if self.zcut1 is not None:
            element.set('zcut1', self.zcut1)
        if self.zcut2 is not None:
            element.set('zcut2', self.zcut2)
        if self.lunit is not None:
            element.set('lunit', self.gds_format_string(self.lunit))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='EllipsoidDimensionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ax is not None and 'ax' not in already_processed:
            already_processed.add('ax')
            showIndent(outfile, level)
            outfile.write('ax=%s,\n' % (self.ax,))
        if self.by is not None and 'by' not in already_processed:
            already_processed.add('by')
            showIndent(outfile, level)
            outfile.write('by=%s,\n' % (self.by,))
        if self.cz is not None and 'cz' not in already_processed:
            already_processed.add('cz')
            showIndent(outfile, level)
            outfile.write('cz=%s,\n' % (self.cz,))
        if self.zcut1 is not None and 'zcut1' not in already_processed:
            already_processed.add('zcut1')
            showIndent(outfile, level)
            outfile.write('zcut1=%s,\n' % (self.zcut1,))
        if self.zcut2 is not None and 'zcut2' not in already_processed:
            already_processed.add('zcut2')
            showIndent(outfile, level)
            outfile.write('zcut2=%s,\n' % (self.zcut2,))
        if self.lunit is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            showIndent(outfile, level)
            outfile.write('lunit="%s",\n' % (self.lunit,))
        super(EllipsoidDimensionsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EllipsoidDimensionsType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ax', node)
        if value is not None and 'ax' not in already_processed:
            already_processed.add('ax')
            self.ax = value
            self.validate_ExpressionOrIDREFType(self.ax)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('by', node)
        if value is not None and 'by' not in already_processed:
            already_processed.add('by')
            self.by = value
            self.validate_ExpressionOrIDREFType(self.by)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('cz', node)
        if value is not None and 'cz' not in already_processed:
            already_processed.add('cz')
            self.cz = value
            self.validate_ExpressionOrIDREFType(self.cz)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('zcut1', node)
        if value is not None and 'zcut1' not in already_processed:
            already_processed.add('zcut1')
            self.zcut1 = value
            self.validate_ExpressionOrIDREFType(self.zcut1)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('zcut2', node)
        if value is not None and 'zcut2' not in already_processed:
            already_processed.add('zcut2')
            self.zcut2 = value
            self.validate_ExpressionOrIDREFType(self.zcut2)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('lunit', node)
        if value is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            self.lunit = value
        super(EllipsoidDimensionsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(EllipsoidDimensionsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EllipsoidDimensionsType


class ParaDimensionsType(DimensionsType):
    """Dimensions for parametrised Paras."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DimensionsType
    def __init__(self, x='1.0', y='1.0', z='1.0', alpha='1.0', theta='1.0', phi='1.0', lunit='mm', aunit='radian', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ParaDimensionsType, self).__init__( **kwargs_)
        self.x = _cast(None, x)
        self.x_nsprefix_ = None
        self.y = _cast(None, y)
        self.y_nsprefix_ = None
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.alpha = _cast(None, alpha)
        self.alpha_nsprefix_ = None
        self.theta = _cast(None, theta)
        self.theta_nsprefix_ = None
        self.phi = _cast(None, phi)
        self.phi_nsprefix_ = None
        self.lunit = _cast(None, lunit)
        self.lunit_nsprefix_ = None
        self.aunit = _cast(None, aunit)
        self.aunit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParaDimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParaDimensionsType.subclass:
            return ParaDimensionsType.subclass(*args_, **kwargs_)
        else:
            return ParaDimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_x(self):
        return self.x
    def set_x(self, x):
        self.x = x
    xProp = property(get_x, set_x)
    def get_y(self):
        return self.y
    def set_y(self, y):
        self.y = y
    yProp = property(get_y, set_y)
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_alpha(self):
        return self.alpha
    def set_alpha(self, alpha):
        self.alpha = alpha
    alphaProp = property(get_alpha, set_alpha)
    def get_theta(self):
        return self.theta
    def set_theta(self, theta):
        self.theta = theta
    thetaProp = property(get_theta, set_theta)
    def get_phi(self):
        return self.phi
    def set_phi(self, phi):
        self.phi = phi
    phiProp = property(get_phi, set_phi)
    def get_lunit(self):
        return self.lunit
    def set_lunit(self, lunit):
        self.lunit = lunit
    lunitProp = property(get_lunit, set_lunit)
    def get_aunit(self):
        return self.aunit
    def set_aunit(self, aunit):
        self.aunit = aunit
    aunitProp = property(get_aunit, set_aunit)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(ParaDimensionsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParaDimensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParaDimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParaDimensionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParaDimensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParaDimensionsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParaDimensionsType'):
        super(ParaDimensionsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParaDimensionsType')
        if self.x != "1.0" and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x=%s' % (quote_attrib(self.x), ))
        if self.y != "1.0" and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y=%s' % (quote_attrib(self.y), ))
        if self.z != "1.0" and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.alpha != "1.0" and 'alpha' not in already_processed:
            already_processed.add('alpha')
            outfile.write(' alpha=%s' % (quote_attrib(self.alpha), ))
        if self.theta != "1.0" and 'theta' not in already_processed:
            already_processed.add('theta')
            outfile.write(' theta=%s' % (quote_attrib(self.theta), ))
        if self.phi != "1.0" and 'phi' not in already_processed:
            already_processed.add('phi')
            outfile.write(' phi=%s' % (quote_attrib(self.phi), ))
        if self.lunit != "mm" and 'lunit' not in already_processed:
            already_processed.add('lunit')
            outfile.write(' lunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lunit), input_name='lunit')), ))
        if self.aunit != "radian" and 'aunit' not in already_processed:
            already_processed.add('aunit')
            outfile.write(' aunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aunit), input_name='aunit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParaDimensionsType', fromsubclass_=False, pretty_print=True):
        super(ParaDimensionsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='ParaDimensionsType', mapping_=None, nsmap_=None):
        element = super(ParaDimensionsType, self).to_etree(parent_element, name_, mapping_)
        if self.x is not None:
            element.set('x', self.x)
        if self.y is not None:
            element.set('y', self.y)
        if self.z is not None:
            element.set('z', self.z)
        if self.alpha is not None:
            element.set('alpha', self.alpha)
        if self.theta is not None:
            element.set('theta', self.theta)
        if self.phi is not None:
            element.set('phi', self.phi)
        if self.lunit is not None:
            element.set('lunit', self.gds_format_string(self.lunit))
        if self.aunit is not None:
            element.set('aunit', self.gds_format_string(self.aunit))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ParaDimensionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%s,\n' % (self.x,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%s,\n' % (self.y,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        if self.alpha is not None and 'alpha' not in already_processed:
            already_processed.add('alpha')
            showIndent(outfile, level)
            outfile.write('alpha=%s,\n' % (self.alpha,))
        if self.theta is not None and 'theta' not in already_processed:
            already_processed.add('theta')
            showIndent(outfile, level)
            outfile.write('theta=%s,\n' % (self.theta,))
        if self.phi is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            showIndent(outfile, level)
            outfile.write('phi=%s,\n' % (self.phi,))
        if self.lunit is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            showIndent(outfile, level)
            outfile.write('lunit="%s",\n' % (self.lunit,))
        if self.aunit is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            showIndent(outfile, level)
            outfile.write('aunit="%s",\n' % (self.aunit,))
        super(ParaDimensionsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ParaDimensionsType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            self.x = value
            self.validate_ExpressionOrIDREFType(self.x)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            self.y = value
            self.validate_ExpressionOrIDREFType(self.y)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('alpha', node)
        if value is not None and 'alpha' not in already_processed:
            already_processed.add('alpha')
            self.alpha = value
            self.validate_ExpressionOrIDREFType(self.alpha)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('theta', node)
        if value is not None and 'theta' not in already_processed:
            already_processed.add('theta')
            self.theta = value
            self.validate_ExpressionOrIDREFType(self.theta)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('phi', node)
        if value is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            self.phi = value
            self.validate_ExpressionOrIDREFType(self.phi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('lunit', node)
        if value is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            self.lunit = value
        value = find_attr_value_('aunit', node)
        if value is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            self.aunit = value
        super(ParaDimensionsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ParaDimensionsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ParaDimensionsType


class PolyconeDimensionsType(DimensionsType):
    """Dimensions for parametrised Polycone."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DimensionsType
    def __init__(self, numRZ='1.0', startPhi='0.0', openPhi='1.0', lunit='mm', aunit='radian', zplane=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PolyconeDimensionsType, self).__init__( **kwargs_)
        self.numRZ = _cast(None, numRZ)
        self.numRZ_nsprefix_ = None
        self.startPhi = _cast(None, startPhi)
        self.startPhi_nsprefix_ = None
        self.openPhi = _cast(None, openPhi)
        self.openPhi_nsprefix_ = None
        self.lunit = _cast(None, lunit)
        self.lunit_nsprefix_ = None
        self.aunit = _cast(None, aunit)
        self.aunit_nsprefix_ = None
        if zplane is None:
            self.zplane = []
        else:
            self.zplane = zplane
        self.zplane_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PolyconeDimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PolyconeDimensionsType.subclass:
            return PolyconeDimensionsType.subclass(*args_, **kwargs_)
        else:
            return PolyconeDimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_zplane(self):
        return self.zplane
    def set_zplane(self, zplane):
        self.zplane = zplane
    def add_zplane(self, value):
        self.zplane.append(value)
    def insert_zplane_at(self, index, value):
        self.zplane.insert(index, value)
    def replace_zplane_at(self, index, value):
        self.zplane[index] = value
    zplaneProp = property(get_zplane, set_zplane)
    def get_numRZ(self):
        return self.numRZ
    def set_numRZ(self, numRZ):
        self.numRZ = numRZ
    numRZProp = property(get_numRZ, set_numRZ)
    def get_startPhi(self):
        return self.startPhi
    def set_startPhi(self, startPhi):
        self.startPhi = startPhi
    startPhiProp = property(get_startPhi, set_startPhi)
    def get_openPhi(self):
        return self.openPhi
    def set_openPhi(self, openPhi):
        self.openPhi = openPhi
    openPhiProp = property(get_openPhi, set_openPhi)
    def get_lunit(self):
        return self.lunit
    def set_lunit(self, lunit):
        self.lunit = lunit
    lunitProp = property(get_lunit, set_lunit)
    def get_aunit(self):
        return self.aunit
    def set_aunit(self, aunit):
        self.aunit = aunit
    aunitProp = property(get_aunit, set_aunit)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.zplane or
            super(PolyconeDimensionsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PolyconeDimensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PolyconeDimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PolyconeDimensionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PolyconeDimensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PolyconeDimensionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PolyconeDimensionsType'):
        super(PolyconeDimensionsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PolyconeDimensionsType')
        if self.numRZ != "1.0" and 'numRZ' not in already_processed:
            already_processed.add('numRZ')
            outfile.write(' numRZ=%s' % (quote_attrib(self.numRZ), ))
        if self.startPhi != "0.0" and 'startPhi' not in already_processed:
            already_processed.add('startPhi')
            outfile.write(' startPhi=%s' % (quote_attrib(self.startPhi), ))
        if self.openPhi != "1.0" and 'openPhi' not in already_processed:
            already_processed.add('openPhi')
            outfile.write(' openPhi=%s' % (quote_attrib(self.openPhi), ))
        if self.lunit != "mm" and 'lunit' not in already_processed:
            already_processed.add('lunit')
            outfile.write(' lunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lunit), input_name='lunit')), ))
        if self.aunit != "radian" and 'aunit' not in already_processed:
            already_processed.add('aunit')
            outfile.write(' aunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aunit), input_name='aunit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PolyconeDimensionsType', fromsubclass_=False, pretty_print=True):
        super(PolyconeDimensionsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for zplane_ in self.zplane:
            namespaceprefix_ = self.zplane_nsprefix_ + ':' if (UseCapturedNS_ and self.zplane_nsprefix_) else ''
            zplane_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='zplane', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PolyconeDimensionsType', mapping_=None, nsmap_=None):
        element = super(PolyconeDimensionsType, self).to_etree(parent_element, name_, mapping_)
        if self.numRZ is not None:
            element.set('numRZ', self.numRZ)
        if self.startPhi is not None:
            element.set('startPhi', self.startPhi)
        if self.openPhi is not None:
            element.set('openPhi', self.openPhi)
        if self.lunit is not None:
            element.set('lunit', self.gds_format_string(self.lunit))
        if self.aunit is not None:
            element.set('aunit', self.gds_format_string(self.aunit))
        for zplane_ in self.zplane:
            zplane_.to_etree(element, name_='zplane', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='PolyconeDimensionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numRZ is not None and 'numRZ' not in already_processed:
            already_processed.add('numRZ')
            showIndent(outfile, level)
            outfile.write('numRZ=%s,\n' % (self.numRZ,))
        if self.startPhi is not None and 'startPhi' not in already_processed:
            already_processed.add('startPhi')
            showIndent(outfile, level)
            outfile.write('startPhi=%s,\n' % (self.startPhi,))
        if self.openPhi is not None and 'openPhi' not in already_processed:
            already_processed.add('openPhi')
            showIndent(outfile, level)
            outfile.write('openPhi=%s,\n' % (self.openPhi,))
        if self.lunit is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            showIndent(outfile, level)
            outfile.write('lunit="%s",\n' % (self.lunit,))
        if self.aunit is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            showIndent(outfile, level)
            outfile.write('aunit="%s",\n' % (self.aunit,))
        super(PolyconeDimensionsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PolyconeDimensionsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('zplane=[\n')
        level += 1
        for zplane_ in self.zplane:
            showIndent(outfile, level)
            outfile.write('model_.ZPlaneType(\n')
            zplane_.exportLiteral(outfile, level, name_='ZPlaneType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numRZ', node)
        if value is not None and 'numRZ' not in already_processed:
            already_processed.add('numRZ')
            self.numRZ = value
            self.validate_ExpressionOrIDREFType(self.numRZ)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('startPhi', node)
        if value is not None and 'startPhi' not in already_processed:
            already_processed.add('startPhi')
            self.startPhi = value
            self.validate_ExpressionOrIDREFType(self.startPhi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('openPhi', node)
        if value is not None and 'openPhi' not in already_processed:
            already_processed.add('openPhi')
            self.openPhi = value
            self.validate_ExpressionOrIDREFType(self.openPhi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('lunit', node)
        if value is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            self.lunit = value
        value = find_attr_value_('aunit', node)
        if value is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            self.aunit = value
        super(PolyconeDimensionsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'zplane':
            obj_ = ZPlaneType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.zplane.append(obj_)
            obj_.original_tagname_ = 'zplane'
        super(PolyconeDimensionsType, self).buildChildren(child_, node, nodeName_, True)
# end class PolyconeDimensionsType


class PolyhedraDimensionsType(DimensionsType):
    """Dimensions for parametrised Polyhedra."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DimensionsType
    def __init__(self, numRZ='1.0', numSide='1.0', startPhi='1.0', openPhi='1.0', lunit='mm', aunit='radian', zplane=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PolyhedraDimensionsType, self).__init__( **kwargs_)
        self.numRZ = _cast(None, numRZ)
        self.numRZ_nsprefix_ = None
        self.numSide = _cast(None, numSide)
        self.numSide_nsprefix_ = None
        self.startPhi = _cast(None, startPhi)
        self.startPhi_nsprefix_ = None
        self.openPhi = _cast(None, openPhi)
        self.openPhi_nsprefix_ = None
        self.lunit = _cast(None, lunit)
        self.lunit_nsprefix_ = None
        self.aunit = _cast(None, aunit)
        self.aunit_nsprefix_ = None
        if zplane is None:
            self.zplane = []
        else:
            self.zplane = zplane
        self.zplane_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PolyhedraDimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PolyhedraDimensionsType.subclass:
            return PolyhedraDimensionsType.subclass(*args_, **kwargs_)
        else:
            return PolyhedraDimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_zplane(self):
        return self.zplane
    def set_zplane(self, zplane):
        self.zplane = zplane
    def add_zplane(self, value):
        self.zplane.append(value)
    def insert_zplane_at(self, index, value):
        self.zplane.insert(index, value)
    def replace_zplane_at(self, index, value):
        self.zplane[index] = value
    zplaneProp = property(get_zplane, set_zplane)
    def get_numRZ(self):
        return self.numRZ
    def set_numRZ(self, numRZ):
        self.numRZ = numRZ
    numRZProp = property(get_numRZ, set_numRZ)
    def get_numSide(self):
        return self.numSide
    def set_numSide(self, numSide):
        self.numSide = numSide
    numSideProp = property(get_numSide, set_numSide)
    def get_startPhi(self):
        return self.startPhi
    def set_startPhi(self, startPhi):
        self.startPhi = startPhi
    startPhiProp = property(get_startPhi, set_startPhi)
    def get_openPhi(self):
        return self.openPhi
    def set_openPhi(self, openPhi):
        self.openPhi = openPhi
    openPhiProp = property(get_openPhi, set_openPhi)
    def get_lunit(self):
        return self.lunit
    def set_lunit(self, lunit):
        self.lunit = lunit
    lunitProp = property(get_lunit, set_lunit)
    def get_aunit(self):
        return self.aunit
    def set_aunit(self, aunit):
        self.aunit = aunit
    aunitProp = property(get_aunit, set_aunit)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.zplane or
            super(PolyhedraDimensionsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PolyhedraDimensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PolyhedraDimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PolyhedraDimensionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PolyhedraDimensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PolyhedraDimensionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PolyhedraDimensionsType'):
        super(PolyhedraDimensionsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PolyhedraDimensionsType')
        if self.numRZ != "1.0" and 'numRZ' not in already_processed:
            already_processed.add('numRZ')
            outfile.write(' numRZ=%s' % (quote_attrib(self.numRZ), ))
        if self.numSide != "1.0" and 'numSide' not in already_processed:
            already_processed.add('numSide')
            outfile.write(' numSide=%s' % (quote_attrib(self.numSide), ))
        if self.startPhi != "1.0" and 'startPhi' not in already_processed:
            already_processed.add('startPhi')
            outfile.write(' startPhi=%s' % (quote_attrib(self.startPhi), ))
        if self.openPhi != "1.0" and 'openPhi' not in already_processed:
            already_processed.add('openPhi')
            outfile.write(' openPhi=%s' % (quote_attrib(self.openPhi), ))
        if self.lunit != "mm" and 'lunit' not in already_processed:
            already_processed.add('lunit')
            outfile.write(' lunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lunit), input_name='lunit')), ))
        if self.aunit != "radian" and 'aunit' not in already_processed:
            already_processed.add('aunit')
            outfile.write(' aunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aunit), input_name='aunit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PolyhedraDimensionsType', fromsubclass_=False, pretty_print=True):
        super(PolyhedraDimensionsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for zplane_ in self.zplane:
            namespaceprefix_ = self.zplane_nsprefix_ + ':' if (UseCapturedNS_ and self.zplane_nsprefix_) else ''
            zplane_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='zplane', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PolyhedraDimensionsType', mapping_=None, nsmap_=None):
        element = super(PolyhedraDimensionsType, self).to_etree(parent_element, name_, mapping_)
        if self.numRZ is not None:
            element.set('numRZ', self.numRZ)
        if self.numSide is not None:
            element.set('numSide', self.numSide)
        if self.startPhi is not None:
            element.set('startPhi', self.startPhi)
        if self.openPhi is not None:
            element.set('openPhi', self.openPhi)
        if self.lunit is not None:
            element.set('lunit', self.gds_format_string(self.lunit))
        if self.aunit is not None:
            element.set('aunit', self.gds_format_string(self.aunit))
        for zplane_ in self.zplane:
            zplane_.to_etree(element, name_='zplane', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='PolyhedraDimensionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numRZ is not None and 'numRZ' not in already_processed:
            already_processed.add('numRZ')
            showIndent(outfile, level)
            outfile.write('numRZ=%s,\n' % (self.numRZ,))
        if self.numSide is not None and 'numSide' not in already_processed:
            already_processed.add('numSide')
            showIndent(outfile, level)
            outfile.write('numSide=%s,\n' % (self.numSide,))
        if self.startPhi is not None and 'startPhi' not in already_processed:
            already_processed.add('startPhi')
            showIndent(outfile, level)
            outfile.write('startPhi=%s,\n' % (self.startPhi,))
        if self.openPhi is not None and 'openPhi' not in already_processed:
            already_processed.add('openPhi')
            showIndent(outfile, level)
            outfile.write('openPhi=%s,\n' % (self.openPhi,))
        if self.lunit is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            showIndent(outfile, level)
            outfile.write('lunit="%s",\n' % (self.lunit,))
        if self.aunit is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            showIndent(outfile, level)
            outfile.write('aunit="%s",\n' % (self.aunit,))
        super(PolyhedraDimensionsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PolyhedraDimensionsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('zplane=[\n')
        level += 1
        for zplane_ in self.zplane:
            showIndent(outfile, level)
            outfile.write('model_.ZPlaneParamType(\n')
            zplane_.exportLiteral(outfile, level, name_='ZPlaneParamType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numRZ', node)
        if value is not None and 'numRZ' not in already_processed:
            already_processed.add('numRZ')
            self.numRZ = value
            self.validate_ExpressionOrIDREFType(self.numRZ)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('numSide', node)
        if value is not None and 'numSide' not in already_processed:
            already_processed.add('numSide')
            self.numSide = value
            self.validate_ExpressionOrIDREFType(self.numSide)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('startPhi', node)
        if value is not None and 'startPhi' not in already_processed:
            already_processed.add('startPhi')
            self.startPhi = value
            self.validate_ExpressionOrIDREFType(self.startPhi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('openPhi', node)
        if value is not None and 'openPhi' not in already_processed:
            already_processed.add('openPhi')
            self.openPhi = value
            self.validate_ExpressionOrIDREFType(self.openPhi)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('lunit', node)
        if value is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            self.lunit = value
        value = find_attr_value_('aunit', node)
        if value is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            self.aunit = value
        super(PolyhedraDimensionsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'zplane':
            obj_ = ZPlaneParamType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.zplane.append(obj_)
            obj_.original_tagname_ = 'zplane'
        super(PolyhedraDimensionsType, self).buildChildren(child_, node, nodeName_, True)
# end class PolyhedraDimensionsType


class ZPlaneParamType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, z='0.0', rmin='0.0', rmax='1.0', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.rmin = _cast(None, rmin)
        self.rmin_nsprefix_ = None
        self.rmax = _cast(None, rmax)
        self.rmax_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ZPlaneParamType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ZPlaneParamType.subclass:
            return ZPlaneParamType.subclass(*args_, **kwargs_)
        else:
            return ZPlaneParamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_rmin(self):
        return self.rmin
    def set_rmin(self, rmin):
        self.rmin = rmin
    rminProp = property(get_rmin, set_rmin)
    def get_rmax(self):
        return self.rmax
    def set_rmax(self, rmax):
        self.rmax = rmax
    rmaxProp = property(get_rmax, set_rmax)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ZPlaneParamType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ZPlaneParamType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ZPlaneParamType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ZPlaneParamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ZPlaneParamType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ZPlaneParamType'):
        if self.z != "0.0" and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.rmin != "0.0" and 'rmin' not in already_processed:
            already_processed.add('rmin')
            outfile.write(' rmin=%s' % (quote_attrib(self.rmin), ))
        if self.rmax != "1.0" and 'rmax' not in already_processed:
            already_processed.add('rmax')
            outfile.write(' rmax=%s' % (quote_attrib(self.rmax), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ZPlaneParamType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='ZPlaneParamType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.z is not None:
            element.set('z', self.z)
        if self.rmin is not None:
            element.set('rmin', self.rmin)
        if self.rmax is not None:
            element.set('rmax', self.rmax)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ZPlaneParamType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        if self.rmin is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            showIndent(outfile, level)
            outfile.write('rmin=%s,\n' % (self.rmin,))
        if self.rmax is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            showIndent(outfile, level)
            outfile.write('rmax=%s,\n' % (self.rmax,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmin', node)
        if value is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            self.rmin = value
            self.validate_ExpressionOrIDREFType(self.rmin)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmax', node)
        if value is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            self.rmax = value
            self.validate_ExpressionOrIDREFType(self.rmax)    # validate type ExpressionOrIDREFType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ZPlaneParamType


class HypeDimensionsType(DimensionsType):
    """Dimensions for parametrised Hypes."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DimensionsType
    def __init__(self, rmin='1.0', rmax='1.0', inst='1.0', outst='1.0', z='1.0', lunit='mm', aunit='radian', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(HypeDimensionsType, self).__init__( **kwargs_)
        self.rmin = _cast(None, rmin)
        self.rmin_nsprefix_ = None
        self.rmax = _cast(None, rmax)
        self.rmax_nsprefix_ = None
        self.inst = _cast(None, inst)
        self.inst_nsprefix_ = None
        self.outst = _cast(None, outst)
        self.outst_nsprefix_ = None
        self.z = _cast(None, z)
        self.z_nsprefix_ = None
        self.lunit = _cast(None, lunit)
        self.lunit_nsprefix_ = None
        self.aunit = _cast(None, aunit)
        self.aunit_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HypeDimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HypeDimensionsType.subclass:
            return HypeDimensionsType.subclass(*args_, **kwargs_)
        else:
            return HypeDimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_rmin(self):
        return self.rmin
    def set_rmin(self, rmin):
        self.rmin = rmin
    rminProp = property(get_rmin, set_rmin)
    def get_rmax(self):
        return self.rmax
    def set_rmax(self, rmax):
        self.rmax = rmax
    rmaxProp = property(get_rmax, set_rmax)
    def get_inst(self):
        return self.inst
    def set_inst(self, inst):
        self.inst = inst
    instProp = property(get_inst, set_inst)
    def get_outst(self):
        return self.outst
    def set_outst(self, outst):
        self.outst = outst
    outstProp = property(get_outst, set_outst)
    def get_z(self):
        return self.z
    def set_z(self, z):
        self.z = z
    zProp = property(get_z, set_z)
    def get_lunit(self):
        return self.lunit
    def set_lunit(self, lunit):
        self.lunit = lunit
    lunitProp = property(get_lunit, set_lunit)
    def get_aunit(self):
        return self.aunit
    def set_aunit(self, aunit):
        self.aunit = aunit
    aunitProp = property(get_aunit, set_aunit)
    def validate_ExpressionOrIDREFType(self, value):
        # Validate type ExpressionOrIDREFType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(HypeDimensionsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HypeDimensionsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HypeDimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HypeDimensionsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HypeDimensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HypeDimensionsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HypeDimensionsType'):
        super(HypeDimensionsType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HypeDimensionsType')
        if self.rmin != "1.0" and 'rmin' not in already_processed:
            already_processed.add('rmin')
            outfile.write(' rmin=%s' % (quote_attrib(self.rmin), ))
        if self.rmax != "1.0" and 'rmax' not in already_processed:
            already_processed.add('rmax')
            outfile.write(' rmax=%s' % (quote_attrib(self.rmax), ))
        if self.inst != "1.0" and 'inst' not in already_processed:
            already_processed.add('inst')
            outfile.write(' inst=%s' % (quote_attrib(self.inst), ))
        if self.outst != "1.0" and 'outst' not in already_processed:
            already_processed.add('outst')
            outfile.write(' outst=%s' % (quote_attrib(self.outst), ))
        if self.z != "1.0" and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (quote_attrib(self.z), ))
        if self.lunit != "mm" and 'lunit' not in already_processed:
            already_processed.add('lunit')
            outfile.write(' lunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lunit), input_name='lunit')), ))
        if self.aunit != "radian" and 'aunit' not in already_processed:
            already_processed.add('aunit')
            outfile.write(' aunit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aunit), input_name='aunit')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HypeDimensionsType', fromsubclass_=False, pretty_print=True):
        super(HypeDimensionsType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='HypeDimensionsType', mapping_=None, nsmap_=None):
        element = super(HypeDimensionsType, self).to_etree(parent_element, name_, mapping_)
        if self.rmin is not None:
            element.set('rmin', self.rmin)
        if self.rmax is not None:
            element.set('rmax', self.rmax)
        if self.inst is not None:
            element.set('inst', self.inst)
        if self.outst is not None:
            element.set('outst', self.outst)
        if self.z is not None:
            element.set('z', self.z)
        if self.lunit is not None:
            element.set('lunit', self.gds_format_string(self.lunit))
        if self.aunit is not None:
            element.set('aunit', self.gds_format_string(self.aunit))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='HypeDimensionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rmin is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            showIndent(outfile, level)
            outfile.write('rmin=%s,\n' % (self.rmin,))
        if self.rmax is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            showIndent(outfile, level)
            outfile.write('rmax=%s,\n' % (self.rmax,))
        if self.inst is not None and 'inst' not in already_processed:
            already_processed.add('inst')
            showIndent(outfile, level)
            outfile.write('inst=%s,\n' % (self.inst,))
        if self.outst is not None and 'outst' not in already_processed:
            already_processed.add('outst')
            showIndent(outfile, level)
            outfile.write('outst=%s,\n' % (self.outst,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z=%s,\n' % (self.z,))
        if self.lunit is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            showIndent(outfile, level)
            outfile.write('lunit="%s",\n' % (self.lunit,))
        if self.aunit is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            showIndent(outfile, level)
            outfile.write('aunit="%s",\n' % (self.aunit,))
        super(HypeDimensionsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HypeDimensionsType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rmin', node)
        if value is not None and 'rmin' not in already_processed:
            already_processed.add('rmin')
            self.rmin = value
            self.validate_ExpressionOrIDREFType(self.rmin)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('rmax', node)
        if value is not None and 'rmax' not in already_processed:
            already_processed.add('rmax')
            self.rmax = value
            self.validate_ExpressionOrIDREFType(self.rmax)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('inst', node)
        if value is not None and 'inst' not in already_processed:
            already_processed.add('inst')
            self.inst = value
            self.validate_ExpressionOrIDREFType(self.inst)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('outst', node)
        if value is not None and 'outst' not in already_processed:
            already_processed.add('outst')
            self.outst = value
            self.validate_ExpressionOrIDREFType(self.outst)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
            self.validate_ExpressionOrIDREFType(self.z)    # validate type ExpressionOrIDREFType
        value = find_attr_value_('lunit', node)
        if value is not None and 'lunit' not in already_processed:
            already_processed.add('lunit')
            self.lunit = value
        value = find_attr_value_('aunit', node)
        if value is not None and 'aunit' not in already_processed:
            already_processed.add('aunit')
            self.aunit = value
        super(HypeDimensionsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(HypeDimensionsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class HypeDimensionsType


class ParameterisationAlgorithmType(GeneratedsSuper):
    """Abstract base for parameterised placement strategies"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterisationAlgorithmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterisationAlgorithmType.subclass:
            return ParameterisationAlgorithmType.subclass(*args_, **kwargs_)
        else:
            return ParameterisationAlgorithmType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParameterisationAlgorithmType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterisationAlgorithmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParameterisationAlgorithmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParameterisationAlgorithmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParameterisationAlgorithmType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParameterisationAlgorithmType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParameterisationAlgorithmType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='ParameterisationAlgorithmType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ParameterisationAlgorithmType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ParameterisationAlgorithmType


class PositionSizeParameterisationAlgorithmType(ParameterisationAlgorithmType):
    """Parameterised volumes get created using
    the tabularized position and sizes."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ParameterisationAlgorithmType
    def __init__(self, parameters=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PositionSizeParameterisationAlgorithmType, self).__init__( **kwargs_)
        if parameters is None:
            self.parameters = []
        else:
            self.parameters = parameters
        self.parameters_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PositionSizeParameterisationAlgorithmType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PositionSizeParameterisationAlgorithmType.subclass:
            return PositionSizeParameterisationAlgorithmType.subclass(*args_, **kwargs_)
        else:
            return PositionSizeParameterisationAlgorithmType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def add_parameters(self, value):
        self.parameters.append(value)
    def insert_parameters_at(self, index, value):
        self.parameters.insert(index, value)
    def replace_parameters_at(self, index, value):
        self.parameters[index] = value
    parametersProp = property(get_parameters, set_parameters)
    def hasContent_(self):
        if (
            self.parameters or
            super(PositionSizeParameterisationAlgorithmType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PositionSizeParameterisationAlgorithmType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PositionSizeParameterisationAlgorithmType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PositionSizeParameterisationAlgorithmType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PositionSizeParameterisationAlgorithmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PositionSizeParameterisationAlgorithmType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PositionSizeParameterisationAlgorithmType'):
        super(PositionSizeParameterisationAlgorithmType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PositionSizeParameterisationAlgorithmType')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PositionSizeParameterisationAlgorithmType', fromsubclass_=False, pretty_print=True):
        super(PositionSizeParameterisationAlgorithmType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for parameters_ in self.parameters:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            parameters_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parameters', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PositionSizeParameterisationAlgorithmType', mapping_=None, nsmap_=None):
        element = super(PositionSizeParameterisationAlgorithmType, self).to_etree(parent_element, name_, mapping_)
        for parameters_ in self.parameters:
            parameters_.to_etree(element, name_='parameters', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='PositionSizeParameterisationAlgorithmType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PositionSizeParameterisationAlgorithmType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PositionSizeParameterisationAlgorithmType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('parameters=[\n')
        level += 1
        for parameters_ in self.parameters:
            showIndent(outfile, level)
            outfile.write('model_.ParametersType(\n')
            parameters_.exportLiteral(outfile, level, name_='ParametersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PositionSizeParameterisationAlgorithmType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'parameters':
            obj_ = ParametersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters.append(obj_)
            obj_.original_tagname_ = 'parameters'
        super(PositionSizeParameterisationAlgorithmType, self).buildChildren(child_, node, nodeName_, True)
# end class PositionSizeParameterisationAlgorithmType


class ParameterisedPlacementType(GeneratedsSuper):
    """Base type for parameterised volumes"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ncopies=None, volumeref=None, ParameterisationAlgorithm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ncopies = _cast(int, ncopies)
        self.ncopies_nsprefix_ = None
        self.volumeref = volumeref
        self.volumeref_nsprefix_ = None
        self.ParameterisationAlgorithm = ParameterisationAlgorithm
        self.ParameterisationAlgorithm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterisedPlacementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterisedPlacementType.subclass:
            return ParameterisedPlacementType.subclass(*args_, **kwargs_)
        else:
            return ParameterisedPlacementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_volumeref(self):
        return self.volumeref
    def set_volumeref(self, volumeref):
        self.volumeref = volumeref
    volumerefProp = property(get_volumeref, set_volumeref)
    def get_ParameterisationAlgorithm(self):
        return self.ParameterisationAlgorithm
    def set_ParameterisationAlgorithm(self, ParameterisationAlgorithm):
        self.ParameterisationAlgorithm = ParameterisationAlgorithm
    ParameterisationAlgorithmProp = property(get_ParameterisationAlgorithm, set_ParameterisationAlgorithm)
    def get_ncopies(self):
        return self.ncopies
    def set_ncopies(self, ncopies):
        self.ncopies = ncopies
    ncopiesProp = property(get_ncopies, set_ncopies)
    def hasContent_(self):
        if (
            self.volumeref is not None or
            self.ParameterisationAlgorithm is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParameterisedPlacementType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterisedPlacementType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParameterisedPlacementType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParameterisedPlacementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParameterisedPlacementType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParameterisedPlacementType'):
        if self.ncopies is not None and 'ncopies' not in already_processed:
            already_processed.add('ncopies')
            outfile.write(' ncopies="%s"' % self.gds_format_integer(self.ncopies, input_name='ncopies'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParameterisedPlacementType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.volumeref is not None:
            namespaceprefix_ = self.volumeref_nsprefix_ + ':' if (UseCapturedNS_ and self.volumeref_nsprefix_) else ''
            self.volumeref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='volumeref', pretty_print=pretty_print)
        if self.ParameterisationAlgorithm is not None:
            self.ParameterisationAlgorithm.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ParameterisedPlacementType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.ncopies is not None:
            element.set('ncopies', self.gds_format_integer(self.ncopies))
        if self.volumeref is not None:
            volumeref_ = self.volumeref
            volumeref_.to_etree(element, name_='volumeref', mapping_=mapping_, nsmap_=nsmap_)
        if self.ParameterisationAlgorithm is not None:
            ParameterisationAlgorithm_ = self.ParameterisationAlgorithm
            ParameterisationAlgorithm_.to_etree(element, name_='ParameterisationAlgorithm', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ParameterisedPlacementType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ncopies is not None and 'ncopies' not in already_processed:
            already_processed.add('ncopies')
            showIndent(outfile, level)
            outfile.write('ncopies=%d,\n' % (self.ncopies,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.volumeref is not None:
            showIndent(outfile, level)
            outfile.write('volumeref=model_.ReferenceType(\n')
            self.volumeref.exportLiteral(outfile, level, name_='volumeref')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ParameterisationAlgorithm is not None:
            showIndent(outfile, level)
            outfile.write('ParameterisationAlgorithm=model_.ParameterisationAlgorithm(\n')
            self.ParameterisationAlgorithm.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ncopies', node)
        if value is not None and 'ncopies' not in already_processed:
            already_processed.add('ncopies')
            self.ncopies = self.gds_parse_integer(value, node, 'ncopies')
            if self.ncopies <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'volumeref':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.volumeref = obj_
            obj_.original_tagname_ = 'volumeref'
        elif nodeName_ == 'ParameterisationAlgorithm':
            class_obj_ = self.get_class_obj_(child_, ParameterisationAlgorithmType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterisationAlgorithm = obj_
            obj_.original_tagname_ = 'ParameterisationAlgorithm'
        elif nodeName_ == 'parameterised_position_size':
            obj_ = PositionSizeParameterisationAlgorithmType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterisationAlgorithm = obj_
            obj_.original_tagname_ = 'parameterised_position_size'
# end class ParameterisedPlacementType


class ParametersType(GeneratedsSuper):
    """Holds parameteres for parameterised volumes."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, number=None, position=None, Dimensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.number = _cast(int, number)
        self.number_nsprefix_ = None
        self.position = position
        self.position_nsprefix_ = None
        self.Dimensions = Dimensions
        self.Dimensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParametersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParametersType.subclass:
            return ParametersType.subclass(*args_, **kwargs_)
        else:
            return ParametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    positionProp = property(get_position, set_position)
    def get_Dimensions(self):
        return self.Dimensions
    def set_Dimensions(self, Dimensions):
        self.Dimensions = Dimensions
    DimensionsProp = property(get_Dimensions, set_Dimensions)
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    numberProp = property(get_number, set_number)
    def hasContent_(self):
        if (
            self.position is not None or
            self.Dimensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParametersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParametersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParametersType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParametersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParametersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParametersType'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParametersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.position is not None:
            namespaceprefix_ = self.position_nsprefix_ + ':' if (UseCapturedNS_ and self.position_nsprefix_) else ''
            self.position.export(outfile, level, namespaceprefix_, namespacedef_='', name_='position', pretty_print=pretty_print)
        if self.Dimensions is not None:
            self.Dimensions.export(outfile, level, namespaceprefix_, namespacedef_='', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ParametersType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.number is not None:
            element.set('number', self.gds_format_integer(self.number))
        if self.position is not None:
            position_ = self.position
            position_.to_etree(element, name_='position', mapping_=mapping_, nsmap_=nsmap_)
        if self.Dimensions is not None:
            Dimensions_ = self.Dimensions
            Dimensions_.to_etree(element, name_='Dimensions', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ParametersType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            showIndent(outfile, level)
            outfile.write('number=%d,\n' % (self.number,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.position is not None:
            showIndent(outfile, level)
            outfile.write('position=model_.positionType(\n')
            self.position.exportLiteral(outfile, level, name_='position')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Dimensions is not None:
            showIndent(outfile, level)
            outfile.write('Dimensions=model_.Dimensions(\n')
            self.Dimensions.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = self.gds_parse_integer(value, node, 'number')
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'position':
            obj_ = positionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.position = obj_
            obj_.original_tagname_ = 'position'
        elif nodeName_ == 'Dimensions':
            class_obj_ = self.get_class_obj_(child_, DimensionsType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'Dimensions'
        elif nodeName_ == 'box_dimensions':
            obj_ = BoxDimensionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'box_dimensions'
        elif nodeName_ == 'trd_dimensions':
            obj_ = TrdDimensionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'trd_dimensions'
        elif nodeName_ == 'trap_dimensions':
            obj_ = TrapDimensionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'trap_dimensions'
        elif nodeName_ == 'tube_dimensions':
            obj_ = TubeDimensionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'tube_dimensions'
        elif nodeName_ == 'cone_dimensions':
            obj_ = ConeDimensionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'cone_dimensions'
        elif nodeName_ == 'sphere_dimensions':
            obj_ = SphereDimensionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'sphere_dimensions'
        elif nodeName_ == 'orb_dimensions':
            obj_ = OrbDimensionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'orb_dimensions'
        elif nodeName_ == 'torus_dimensions':
            obj_ = TorusDimensionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'torus_dimensions'
        elif nodeName_ == 'ellipsoid_dimensions':
            obj_ = EllipsoidDimensionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'ellipsoid_dimensions'
        elif nodeName_ == 'para_dimensions':
            obj_ = ParaDimensionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'para_dimensions'
        elif nodeName_ == 'polycone_dimensions':
            obj_ = PolyconeDimensionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'polycone_dimensions'
        elif nodeName_ == 'polyhedra_dimensions':
            obj_ = PolyhedraDimensionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'polyhedra_dimensions'
        elif nodeName_ == 'hype_dimensions':
            obj_ = HypeDimensionsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'hype_dimensions'
# end class ParametersType


class userinfoType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, auxiliary=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if auxiliary is None:
            self.auxiliary = []
        else:
            self.auxiliary = auxiliary
        self.auxiliary_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, userinfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if userinfoType.subclass:
            return userinfoType.subclass(*args_, **kwargs_)
        else:
            return userinfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_auxiliary(self):
        return self.auxiliary
    def set_auxiliary(self, auxiliary):
        self.auxiliary = auxiliary
    def add_auxiliary(self, value):
        self.auxiliary.append(value)
    def insert_auxiliary_at(self, index, value):
        self.auxiliary.insert(index, value)
    def replace_auxiliary_at(self, index, value):
        self.auxiliary[index] = value
    auxiliaryProp = property(get_auxiliary, set_auxiliary)
    def hasContent_(self):
        if (
            self.auxiliary
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='userinfoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('userinfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'userinfoType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='userinfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='userinfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='userinfoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='userinfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for auxiliary_ in self.auxiliary:
            namespaceprefix_ = self.auxiliary_nsprefix_ + ':' if (UseCapturedNS_ and self.auxiliary_nsprefix_) else ''
            auxiliary_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='auxiliary', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='userinfoType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        for auxiliary_ in self.auxiliary:
            auxiliary_.to_etree(element, name_='auxiliary', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='userinfoType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('auxiliary=[\n')
        level += 1
        for auxiliary_ in self.auxiliary:
            showIndent(outfile, level)
            outfile.write('model_.AuxiliaryType(\n')
            auxiliary_.exportLiteral(outfile, level, name_='AuxiliaryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'auxiliary':
            obj_ = AuxiliaryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.auxiliary.append(obj_)
            obj_.original_tagname_ = 'auxiliary'
# end class userinfoType


class setupType(GeneratedsSuper):
    """Geometry setup representing the particular geometry hierarchy by
    refferring to
    a given volume which becomes the top level volume"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, version=None, world=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.world = world
        self.world_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, setupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if setupType.subclass:
            return setupType.subclass(*args_, **kwargs_)
        else:
            return setupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_world(self):
        return self.world
    def set_world(self, world):
        self.world = world
    worldProp = property(get_world, set_world)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    versionProp = property(get_version, set_version)
    def hasContent_(self):
        if (
            self.world is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setupType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('setupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'setupType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='setupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='setupType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='setupType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.world is not None:
            namespaceprefix_ = self.world_nsprefix_ + ':' if (UseCapturedNS_ and self.world_nsprefix_) else ''
            self.world.export(outfile, level, namespaceprefix_, namespacedef_='', name_='world', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='setupType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.version is not None:
            element.set('version', self.gds_format_string(self.version))
        if self.world is not None:
            world_ = self.world
            world_.to_etree(element, name_='world', mapping_=mapping_, nsmap_=nsmap_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='setupType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.world is not None:
            showIndent(outfile, level)
            outfile.write('world=model_.ReferenceType(\n')
            self.world.exportLiteral(outfile, level, name_='world')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'world':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.world = obj_
            obj_.original_tagname_ = 'world'
# end class setupType


class propertyType(ReferenceType):
    """General material property (const or vector)"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(propertyType, self).__init__(ref,  **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyType.subclass:
            return propertyType.subclass(*args_, **kwargs_)
        else:
            return propertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def hasContent_(self):
        if (
            super(propertyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='propertyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('propertyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'propertyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='propertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='propertyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='propertyType'):
        super(propertyType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='propertyType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='propertyType', fromsubclass_=False, pretty_print=True):
        super(propertyType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='propertyType', mapping_=None, nsmap_=None):
        element = super(propertyType, self).to_etree(parent_element, name_, mapping_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='propertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(propertyType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(propertyType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(propertyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(propertyType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class propertyType


class RLType(QuantityType):
    """Radiation length"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuantityType
    def __init__(self, value=None, unit=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RLType, self).__init__(value, unit, type_,  **kwargs_)
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RLType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RLType.subclass:
            return RLType.subclass(*args_, **kwargs_)
        else:
            return RLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            super(RLType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RLType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RLType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RLType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RLType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RLType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RLType'):
        super(RLType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RLType')
        if self.unit != "cm" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.type_ != "X0" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RLType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='RLType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='RLType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(RLType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RLType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(RLType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RLType


class ALType(QuantityType):
    """Absorption length"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuantityType
    def __init__(self, value=None, unit=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ALType, self).__init__(value, unit, type_,  **kwargs_)
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ALType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ALType.subclass:
            return ALType.subclass(*args_, **kwargs_)
        else:
            return ALType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            super(ALType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ALType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ALType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ALType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ALType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ALType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ALType'):
        super(ALType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ALType')
        if self.unit != "cm" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.type_ != "lambda" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ALType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='ALType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ALType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(ALType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ALType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(ALType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ALType


class TType(QuantityType):
    """Temperature"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuantityType
    def __init__(self, value=None, unit=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TType, self).__init__(value, unit, type_,  **kwargs_)
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TType.subclass:
            return TType.subclass(*args_, **kwargs_)
        else:
            return TType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            super(TType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TType'):
        super(TType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TType')
        if self.unit != "K" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.type_ != "temperature" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='TType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(TType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(TType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TType


class PType(QuantityType):
    """Pressure"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuantityType
    def __init__(self, value=None, unit=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PType, self).__init__(value, unit, type_,  **kwargs_)
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PType.subclass:
            return PType.subclass(*args_, **kwargs_)
        else:
            return PType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            super(PType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PType'):
        super(PType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PType')
        if self.unit != "pascal" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.type_ != "pressure" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='PType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='PType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(PType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(PType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PType


class MEEType(QuantityType):
    """Ionisation potential or Mean Excitation Energy"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuantityType
    def __init__(self, value=None, unit=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(MEEType, self).__init__(value, unit, type_,  **kwargs_)
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MEEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MEEType.subclass:
            return MEEType.subclass(*args_, **kwargs_)
        else:
            return MEEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            super(MEEType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MEEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MEEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MEEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MEEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MEEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MEEType'):
        super(MEEType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MEEType')
        if self.unit != "eV" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.type_ != "excitationE" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MEEType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='MEEType', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='MEEType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(MEEType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MEEType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(MEEType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class MEEType


class propertyType1(ReferenceType):
    """General material property (const or vector)"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(propertyType1, self).__init__(ref,  **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyType1.subclass:
            return propertyType1.subclass(*args_, **kwargs_)
        else:
            return propertyType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def hasContent_(self):
        if (
            super(propertyType1, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='propertyType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('propertyType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'propertyType1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='propertyType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='propertyType1', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='propertyType1'):
        super(propertyType1, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='propertyType1')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='propertyType1', fromsubclass_=False, pretty_print=True):
        super(propertyType1, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='propertyType1', mapping_=None, nsmap_=None):
        element = super(propertyType1, self).to_etree(parent_element, name_, mapping_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='propertyType1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(propertyType1, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(propertyType1, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(propertyType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(propertyType1, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class propertyType1


class RLType2(QuantityType):
    """Radiation length"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuantityType
    def __init__(self, value=None, unit=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(RLType2, self).__init__(value, unit, type_,  **kwargs_)
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RLType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RLType2.subclass:
            return RLType2.subclass(*args_, **kwargs_)
        else:
            return RLType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            super(RLType2, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RLType2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RLType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RLType2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RLType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RLType2', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RLType2'):
        super(RLType2, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RLType2')
        if self.unit != "cm" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.type_ != "X0" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RLType2', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='RLType2', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='RLType2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(RLType2, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RLType2, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(RLType2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RLType2


class ALType3(QuantityType):
    """Absorption length"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuantityType
    def __init__(self, value=None, unit=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(ALType3, self).__init__(value, unit, type_,  **kwargs_)
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ALType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ALType3.subclass:
            return ALType3.subclass(*args_, **kwargs_)
        else:
            return ALType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            super(ALType3, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ALType3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ALType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ALType3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ALType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ALType3', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ALType3'):
        super(ALType3, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ALType3')
        if self.unit != "cm" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.type_ != "lambda" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ALType3', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='ALType3', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='ALType3'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(ALType3, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ALType3, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(ALType3, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ALType3


class TType4(QuantityType):
    """Temperature"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuantityType
    def __init__(self, value=None, unit=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(TType4, self).__init__(value, unit, type_,  **kwargs_)
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TType4.subclass:
            return TType4.subclass(*args_, **kwargs_)
        else:
            return TType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            super(TType4, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TType4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TType4':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TType4', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TType4'):
        super(TType4, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TType4')
        if self.unit != "K" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.type_ != "temperature" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TType4', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='TType4', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='TType4'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(TType4, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TType4, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(TType4, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TType4


class PType5(QuantityType):
    """Pressure"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuantityType
    def __init__(self, value=None, unit=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(PType5, self).__init__(value, unit, type_,  **kwargs_)
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PType5.subclass:
            return PType5.subclass(*args_, **kwargs_)
        else:
            return PType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            super(PType5, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PType5', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PType5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PType5':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PType5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PType5', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PType5'):
        super(PType5, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PType5')
        if self.unit != "pascal" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.type_ != "pressure" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PType5', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='PType5', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='PType5'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(PType5, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PType5, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(PType5, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PType5


class MEEType6(QuantityType):
    """Ionisation potential or Mean Excitation Energy"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = QuantityType
    def __init__(self, value=None, unit=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(MEEType6, self).__init__(value, unit, type_,  **kwargs_)
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MEEType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MEEType6.subclass:
            return MEEType6.subclass(*args_, **kwargs_)
        else:
            return MEEType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            super(MEEType6, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MEEType6', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MEEType6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MEEType6':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MEEType6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MEEType6', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MEEType6'):
        super(MEEType6, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MEEType6')
        if self.unit != "eV" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.type_ != "excitationE" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MEEType6', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='MEEType6', mapping_=None, nsmap_=None):
        if parent_element is None:
            element = etree_.Element('{}' + name_, nsmap=nsmap_)
        else:
            element = etree_.SubElement(parent_element, '{}' + name_, nsmap=nsmap_)
        if self.unit is not None:
            element.set('unit', self.gds_format_string(self.unit))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='MEEType6'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(MEEType6, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MEEType6, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(MEEType6, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class MEEType6


class fractionType(ReferenceType):
    """An isotope fraction of an element where n is the actual amount
    of the isotope in the element"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, n=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(fractionType, self).__init__(ref,  **kwargs_)
        self.n = _cast(float, n)
        self.n_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fractionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fractionType.subclass:
            return fractionType.subclass(*args_, **kwargs_)
        else:
            return fractionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_n(self):
        return self.n
    def set_n(self, n):
        self.n = n
    nProp = property(get_n, set_n)
    def hasContent_(self):
        if (
            super(fractionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fractionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fractionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fractionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fractionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fractionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fractionType'):
        super(fractionType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fractionType')
        if self.n is not None and 'n' not in already_processed:
            already_processed.add('n')
            outfile.write(' n="%s"' % self.gds_format_double(self.n, input_name='n'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fractionType', fromsubclass_=False, pretty_print=True):
        super(fractionType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='fractionType', mapping_=None, nsmap_=None):
        element = super(fractionType, self).to_etree(parent_element, name_, mapping_)
        if self.n is not None:
            element.set('n', self.gds_format_double(self.n))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='fractionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.n is not None and 'n' not in already_processed:
            already_processed.add('n')
            showIndent(outfile, level)
            outfile.write('n=%e,\n' % (self.n,))
        super(fractionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(fractionType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('n', node)
        if value is not None and 'n' not in already_processed:
            already_processed.add('n')
            value = self.gds_parse_double(value, node, 'n')
            self.n = value
        super(fractionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(fractionType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class fractionType


class compositeType(ReferenceType):
    """Elements of this composite material specified as a set of local
    references
    to already defined simple elements where value of n in each means the
    number of atoms"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, n=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(compositeType, self).__init__(ref,  **kwargs_)
        self.n = _cast(int, n)
        self.n_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, compositeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if compositeType.subclass:
            return compositeType.subclass(*args_, **kwargs_)
        else:
            return compositeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_n(self):
        return self.n
    def set_n(self, n):
        self.n = n
    nProp = property(get_n, set_n)
    def hasContent_(self):
        if (
            super(compositeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='compositeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('compositeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'compositeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='compositeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='compositeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='compositeType'):
        super(compositeType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='compositeType')
        if self.n is not None and 'n' not in already_processed:
            already_processed.add('n')
            outfile.write(' n="%s"' % self.gds_format_integer(self.n, input_name='n'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='compositeType', fromsubclass_=False, pretty_print=True):
        super(compositeType, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='compositeType', mapping_=None, nsmap_=None):
        element = super(compositeType, self).to_etree(parent_element, name_, mapping_)
        if self.n is not None:
            element.set('n', self.gds_format_integer(self.n))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='compositeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.n is not None and 'n' not in already_processed:
            already_processed.add('n')
            showIndent(outfile, level)
            outfile.write('n=%d,\n' % (self.n,))
        super(compositeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(compositeType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('n', node)
        if value is not None and 'n' not in already_processed:
            already_processed.add('n')
            self.n = self.gds_parse_integer(value, node, 'n')
            if self.n <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        super(compositeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(compositeType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class compositeType


class fractionType7(ReferenceType):
    """Fractions of this mixture specified as a set of local references to
    already defined
    elements or other mixtures where value of n in each means the fraction of
    the whole
    material in the range 0.0 < n < 1.0"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, n=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(fractionType7, self).__init__(ref,  **kwargs_)
        self.n = _cast(float, n)
        self.n_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fractionType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fractionType7.subclass:
            return fractionType7.subclass(*args_, **kwargs_)
        else:
            return fractionType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_n(self):
        return self.n
    def set_n(self, n):
        self.n = n
    nProp = property(get_n, set_n)
    def hasContent_(self):
        if (
            super(fractionType7, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fractionType7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fractionType7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fractionType7':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fractionType7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fractionType7', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fractionType7'):
        super(fractionType7, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fractionType7')
        if self.n is not None and 'n' not in already_processed:
            already_processed.add('n')
            outfile.write(' n="%s"' % self.gds_format_double(self.n, input_name='n'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fractionType7', fromsubclass_=False, pretty_print=True):
        super(fractionType7, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='fractionType7', mapping_=None, nsmap_=None):
        element = super(fractionType7, self).to_etree(parent_element, name_, mapping_)
        if self.n is not None:
            element.set('n', self.gds_format_double(self.n))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='fractionType7'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.n is not None and 'n' not in already_processed:
            already_processed.add('n')
            showIndent(outfile, level)
            outfile.write('n=%e,\n' % (self.n,))
        super(fractionType7, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(fractionType7, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('n', node)
        if value is not None and 'n' not in already_processed:
            already_processed.add('n')
            value = self.gds_parse_double(value, node, 'n')
            self.n = value
        super(fractionType7, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(fractionType7, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class fractionType7


class propertyType8(ReferenceType):
    """General optical surface property (const or vector)"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(propertyType8, self).__init__(ref,  **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyType8.subclass:
            return propertyType8.subclass(*args_, **kwargs_)
        else:
            return propertyType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def hasContent_(self):
        if (
            super(propertyType8, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='propertyType8', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('propertyType8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'propertyType8':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='propertyType8')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='propertyType8', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='propertyType8'):
        super(propertyType8, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='propertyType8')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='propertyType8', fromsubclass_=False, pretty_print=True):
        super(propertyType8, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='propertyType8', mapping_=None, nsmap_=None):
        element = super(propertyType8, self).to_etree(parent_element, name_, mapping_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='propertyType8'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(propertyType8, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(propertyType8, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(propertyType8, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(propertyType8, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class propertyType8


class propertyType9(ReferenceType):
    """General optical surface property (const or vector)"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ReferenceType
    def __init__(self, ref=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(propertyType9, self).__init__(ref,  **kwargs_)
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, propertyType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if propertyType9.subclass:
            return propertyType9.subclass(*args_, **kwargs_)
        else:
            return propertyType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def hasContent_(self):
        if (
            super(propertyType9, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='propertyType9', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('propertyType9')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'propertyType9':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='propertyType9')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='propertyType9', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='propertyType9'):
        super(propertyType9, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='propertyType9')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='propertyType9', fromsubclass_=False, pretty_print=True):
        super(propertyType9, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='propertyType9', mapping_=None, nsmap_=None):
        element = super(propertyType9, self).to_etree(parent_element, name_, mapping_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def exportLiteral(self, outfile, level, name_='propertyType9'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(propertyType9, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(propertyType9, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(propertyType9, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(propertyType9, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class propertyType9


GDSClassesMapping = {
    'Dimensions': DimensionsType,
    'Facet': FacetType,
    'ParameterisationAlgorithm': ParameterisationAlgorithmType,
    'ReplicationAlgorithm': ReplicationAlgorithmType,
    'Solid': SolidType,
    'Surface': LogicalSurfaceType,
    'SurfaceProperty': SurfacePropertyType,
    'box_dimensions': BoxDimensionsType,
    'cone_dimensions': ConeDimensionsType,
    'define': defineType,
    'direction': directionType,
    'ellipsoid_dimensions': EllipsoidDimensionsType,
    'hype_dimensions': HypeDimensionsType,
    'intersection': BooleanSolidType,
    'offset': QuantityType,
    'orb_dimensions': OrbDimensionsType,
    'para_dimensions': ParaDimensionsType,
    'parameterised_position_size': PositionSizeParameterisationAlgorithmType,
    'paramvol': ParameterisedPlacementType,
    'polycone_dimensions': PolyconeDimensionsType,
    'polyhedra_dimensions': PolyhedraDimensionsType,
    'replicate_along_axis': AxisReplicationAlgorithmType,
    'replicavol': ReplicaPlacementType,
    'sphere_dimensions': SphereDimensionsType,
    'subtraction': BooleanSolidType,
    'torus_dimensions': TorusDimensionsType,
    'trap_dimensions': TrapDimensionsType,
    'trd_dimensions': TrdDimensionsType,
    'tube_dimensions': TubeDimensionsType,
    'union': BooleanSolidType,
    'width': QuantityType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'gdml'
        rootClass = gdml
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'gdml'
        rootClass = gdml
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if mapping is None:
        mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping, nsmap_=nsmap)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'gdml'
        rootClass = gdml
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'gdml'
        rootClass = gdml
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from gdmlClasses import *\n\n')
        sys.stdout.write('import gdmlClasses as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {}

__all__ = [
    "ALType",
    "ALType3",
    "AssemblyVolumeType",
    "AtomType",
    "AuxiliaryType",
    "AxisReplicationAlgorithmType",
    "BooleanSolidType",
    "BoxDimensionsType",
    "ConeDimensionsType",
    "ConstantType",
    "DensityType",
    "DimensionsType",
    "DivisionPlacementType",
    "EllipsoidDimensionsType",
    "FacetType",
    "FileReferenceType",
    "HypeDimensionsType",
    "IdentifiableConstantType",
    "IdentifiableExpressionType",
    "IdentifiableQuantityType",
    "IdentifiableQuantityVectorType",
    "IdentifiableThreeVectorType",
    "IdentifiableVariableType",
    "IdentifiableVolumeType",
    "LogicalSurfaceType",
    "MEEType",
    "MEEType6",
    "MaterialElementType",
    "MaterialIsotopeType",
    "MaterialMixtureType",
    "MaterialType",
    "MatrixType",
    "OrbDimensionsType",
    "PType",
    "PType5",
    "ParaDimensionsType",
    "ParameterisationAlgorithmType",
    "ParameterisedPlacementType",
    "ParametersType",
    "PolyconeDimensionsType",
    "PolyhedraDimensionsType",
    "PositionSizeParameterisationAlgorithmType",
    "QuantityType",
    "QuantityVectorType",
    "RLType",
    "RLType2",
    "RZPointType",
    "ReferenceListType",
    "ReferenceType",
    "ReplicaPlacementType",
    "ReplicationAlgorithmType",
    "SectionType",
    "SinglePlacementType",
    "SolidType",
    "SphereDimensionsType",
    "SurfacePropertyType",
    "TType",
    "TType4",
    "ThreeVectorType",
    "TorusDimensionsType",
    "TrapDimensionsType",
    "TrdDimensionsType",
    "TubeDimensionsType",
    "TwoDimVertexType",
    "VariableType",
    "VolumeType",
    "ZPlaneParamType",
    "ZPlaneType",
    "arb8",
    "bordersurface",
    "box",
    "compositeType",
    "cone",
    "cutTube",
    "defineType",
    "directionType",
    "elcone",
    "ellipsoid",
    "eltube",
    "fractionType",
    "fractionType7",
    "gdml",
    "genericPolycone",
    "genericPolyhedra",
    "hype",
    "loop",
    "materials",
    "multiUnion",
    "multiUnionNode",
    "opticalsurface",
    "orb",
    "para",
    "paraboloid",
    "polycone",
    "polyhedra",
    "positionType",
    "propertyType",
    "propertyType1",
    "propertyType8",
    "propertyType9",
    "quadrangular",
    "reflectedSolid",
    "rotationType",
    "scaleType",
    "scaledSolid",
    "setupType",
    "skinsurface",
    "solids",
    "sphere",
    "structure",
    "tessellated",
    "tet",
    "torus",
    "trap",
    "trd",
    "triangular",
    "tube",
    "twistedbox",
    "twistedtrap",
    "twistedtrd",
    "twistedtubs",
    "userinfoType",
    "xtru"
]
